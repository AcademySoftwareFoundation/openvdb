<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: CFunctionBase Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__1.html">v8_1</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax.html">ax</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1codegen.html">codegen</a></li><li class="navelem"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html">CFunctionBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CFunctionBase Struct Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>The base class for all C bindings.  
 <a href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="FunctionTypes_8h_source.html">FunctionTypes.h</a>&gt;</code></p>

<p>Inherits <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html">Function</a>.</p>

<p>Inherited by <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunction.html">CFunction&lt; SignatureT &gt;</a>.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad99778adb8c85c822cfd12e9dd57a9ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html#ad99778adb8c85c822cfd12e9dd57a9ea">Ptr</a> = std::shared_ptr&lt; <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html">CFunctionBase</a> &gt;</td></tr>
<tr class="separator:ad99778adb8c85c822cfd12e9dd57a9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8c90b86fef2410c5903bcdd9df708c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a> { <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708cac9d3e887722f2bc482bcca9d41c512af">None</a> = 0, 
<a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708caff9abf2b1a689f70a77a18da50c01d9f">Size</a>, 
<a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708ca81a198911eba60d4033c233d3ec90ea1">Implicit</a>, 
<a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708cad2dd6ed7eca9210b09941bee2c62735f">Explicit</a>
 }<tr class="memdesc:aee8c90b86fef2410c5903bcdd9df708c"><td class="mdescLeft">&#160;</td><td class="mdescRight">The result type from calls to <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#ada1a5e0db7a1333bb336dc130f75a5d0" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:aee8c90b86fef2410c5903bcdd9df708c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac732ba1d7a9a55bf71be88c9a47a6ed8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html#ac732ba1d7a9a55bf71be88c9a47a6ed8">~CFunctionBase</a> () override=default</td></tr>
<tr class="separator:ac732ba1d7a9a55bf71be88c9a47a6ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2d0cbb03b257ffb000c68e1ba3bf88"><td class="memItemLeft" align="right" valign="top">virtual uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html#a9d2d0cbb03b257ffb000c68e1ba3bf88">address</a> () const  =0</td></tr>
<tr class="memdesc:a9d2d0cbb03b257ffb000c68e1ba3bf88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the global address of this function.  <a href="#a9d2d0cbb03b257ffb000c68e1ba3bf88">More...</a><br /></td></tr>
<tr class="separator:a9d2d0cbb03b257ffb000c68e1ba3bf88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31e5847bbc4d67cfaf0be3c2e3c48184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html#a31e5847bbc4d67cfaf0be3c2e3c48184">setConstantFold</a> (bool on)</td></tr>
<tr class="separator:a31e5847bbc4d67cfaf0be3c2e3c48184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f009138e6bdf1d632cf310cf2b51a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html#a85f009138e6bdf1d632cf310cf2b51a7">hasConstantFold</a> () const </td></tr>
<tr class="separator:a85f009138e6bdf1d632cf310cf2b51a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e740ea8bb949d01f304a83cd8b85a3f"><td class="memItemLeft" align="right" valign="top">virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html#a8e740ea8bb949d01f304a83cd8b85a3f">fold</a> (const std::vector&lt; llvm::Value * &gt; &amp;, llvm::LLVMContext &amp;) const </td></tr>
<tr class="separator:a8e740ea8bb949d01f304a83cd8b85a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e75a6e74e69d1563a9d41d626b30a0"><td class="memItemLeft" align="right" valign="top">virtual llvm::Type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#ad2e75a6e74e69d1563a9d41d626b30a0">types</a> (std::vector&lt; llvm::Type * &gt; &amp;, llvm::LLVMContext &amp;) const  =0</td></tr>
<tr class="memdesc:ad2e75a6e74e69d1563a9d41d626b30a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a vector of llvm::Types which describe this function signature. This method is used by <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a1c7d49fb9a9339c775f3a83d7dac9d69" title="Converts and creates this AX function into a llvm Function. ">Function::create</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#abd8791caa902661a1de7954693348c4a" title="Print this function&#39;s signature to the provided ostream. ">Function::print</a> and <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#ada1a5e0db7a1333bb336dc130f75a5d0" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>.  <a href="#ad2e75a6e74e69d1563a9d41d626b30a0">More...</a><br /></td></tr>
<tr class="separator:ad2e75a6e74e69d1563a9d41d626b30a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7d49fb9a9339c775f3a83d7dac9d69"><td class="memItemLeft" align="right" valign="top">virtual llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a1c7d49fb9a9339c775f3a83d7dac9d69">create</a> (llvm::LLVMContext &amp;C, llvm::Module *M=nullptr) const </td></tr>
<tr class="memdesc:a1c7d49fb9a9339c775f3a83d7dac9d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts and creates this AX function into a llvm <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a>.  <a href="#a1c7d49fb9a9339c775f3a83d7dac9d69">More...</a><br /></td></tr>
<tr class="separator:a1c7d49fb9a9339c775f3a83d7dac9d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fea737cad05b175de71a0ebdc13612f"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a5fea737cad05b175de71a0ebdc13612f">create</a> (llvm::Module &amp;M) const </td></tr>
<tr class="memdesc:a5fea737cad05b175de71a0ebdc13612f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method which always uses the provided module to find the function or insert it if necessary.  <a href="#a5fea737cad05b175de71a0ebdc13612f">More...</a><br /></td></tr>
<tr class="separator:a5fea737cad05b175de71a0ebdc13612f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d858554d7539c0e7fce6435b45de4b"><td class="memItemLeft" align="right" valign="top">llvm::Function *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aa8d858554d7539c0e7fce6435b45de4b">get</a> (const llvm::Module &amp;M) const </td></tr>
<tr class="memdesc:aa8d858554d7539c0e7fce6435b45de4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method for calling M.getFunction(symbol). Returns a nullptr if the function has not yet been created or if it is embedded IR.  <a href="#aa8d858554d7539c0e7fce6435b45de4b">More...</a><br /></td></tr>
<tr class="separator:aa8d858554d7539c0e7fce6435b45de4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756495c036ac3d363d304fa97fe9fb7a"><td class="memItemLeft" align="right" valign="top">virtual llvm::Value *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a756495c036ac3d363d304fa97fe9fb7a">call</a> (const std::vector&lt; llvm::Value * &gt; &amp;args, llvm::IRBuilder&lt;&gt; &amp;B, const bool <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a3c7bbe5ddababca6b3a2da7a23a25fc1">cast</a>=false) const </td></tr>
<tr class="memdesc:a756495c036ac3d363d304fa97fe9fb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uses the IRBuilder to create a call to this function with the given arguments, creating the function and inserting it into the IRBuilder's Module if necessary (through <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a1c7d49fb9a9339c775f3a83d7dac9d69" title="Converts and creates this AX function into a llvm Function. ">Function::create</a>). Returns the result of the function call which can be a nullptr if the function is a non-sret void call.  <a href="#a756495c036ac3d363d304fa97fe9fb7a">More...</a><br /></td></tr>
<tr class="separator:a756495c036ac3d363d304fa97fe9fb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada1a5e0db7a1333bb336dc130f75a5d0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#ada1a5e0db7a1333bb336dc130f75a5d0">match</a> (const std::vector&lt; llvm::Type * &gt; &amp;inputs, llvm::LLVMContext &amp;C) const </td></tr>
<tr class="memdesc:ada1a5e0db7a1333bb336dc130f75a5d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base implementation for determining how a vector of llvm arguments translates to this functions signature. Returns an enum which represents the available mapping.  <a href="#ada1a5e0db7a1333bb336dc130f75a5d0">More...</a><br /></td></tr>
<tr class="separator:ada1a5e0db7a1333bb336dc130f75a5d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac782da1f912bceb5d8ad00c8dc892ac"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aac782da1f912bceb5d8ad00c8dc892ac">size</a> () const </td></tr>
<tr class="memdesc:aac782da1f912bceb5d8ad00c8dc892ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of arguments that this function has.  <a href="#aac782da1f912bceb5d8ad00c8dc892ac">More...</a><br /></td></tr>
<tr class="separator:aac782da1f912bceb5d8ad00c8dc892ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7735bbeb07320c3f746b21c6a598c732"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a7735bbeb07320c3f746b21c6a598c732">symbol</a> () const </td></tr>
<tr class="memdesc:a7735bbeb07320c3f746b21c6a598c732"><td class="mdescLeft">&#160;</td><td class="mdescRight">The function symbol name.  <a href="#a7735bbeb07320c3f746b21c6a598c732">More...</a><br /></td></tr>
<tr class="separator:a7735bbeb07320c3f746b21c6a598c732"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54251bc604333f3dbb1a5ea4a4a808b8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a54251bc604333f3dbb1a5ea4a4a808b8">argName</a> (const size_t idx) const </td></tr>
<tr class="memdesc:a54251bc604333f3dbb1a5ea4a4a808b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the descriptive name of the given argument index.  <a href="#a54251bc604333f3dbb1a5ea4a4a808b8">More...</a><br /></td></tr>
<tr class="separator:a54251bc604333f3dbb1a5ea4a4a808b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8791caa902661a1de7954693348c4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#abd8791caa902661a1de7954693348c4a">print</a> (llvm::LLVMContext &amp;C, std::ostream &amp;os, const char *name=nullptr, const bool axTypes=true) const </td></tr>
<tr class="memdesc:abd8791caa902661a1de7954693348c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print this function's signature to the provided ostream.  <a href="#abd8791caa902661a1de7954693348c4a">More...</a><br /></td></tr>
<tr class="separator:abd8791caa902661a1de7954693348c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93871197f41264952182593a5c638a3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aa93871197f41264952182593a5c638a3">hasParamAttribute</a> (const size_t i, const llvm::Attribute::AttrKind &amp;kind) const </td></tr>
<tr class="memdesc:aa93871197f41264952182593a5c638a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builder methods.  <a href="#aa93871197f41264952182593a5c638a3">More...</a><br /></td></tr>
<tr class="separator:aa93871197f41264952182593a5c638a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6187793e0d3c6b1098b1d037e5b9530"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#af6187793e0d3c6b1098b1d037e5b9530">setArgumentNames</a> (std::vector&lt; const char * &gt; names)</td></tr>
<tr class="separator:af6187793e0d3c6b1098b1d037e5b9530"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5158708275b343f58432634eff78ecf"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; const char * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#ac5158708275b343f58432634eff78ecf">dependencies</a> () const </td></tr>
<tr class="separator:ac5158708275b343f58432634eff78ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130dc8b5cf81200428494e2d63384483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a130dc8b5cf81200428494e2d63384483">setDependencies</a> (std::vector&lt; const char * &gt; deps)</td></tr>
<tr class="separator:a130dc8b5cf81200428494e2d63384483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb0a8f2ddba1d3d98741894a5db5f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a6fb0a8f2ddba1d3d98741894a5db5f03">setFnAttributes</a> (const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;in)</td></tr>
<tr class="separator:a6fb0a8f2ddba1d3d98741894a5db5f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51952659e55f5546f5e3d8f6a4e56eb3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a51952659e55f5546f5e3d8f6a4e56eb3">setRetAttributes</a> (const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;in)</td></tr>
<tr class="separator:a51952659e55f5546f5e3d8f6a4e56eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359ce980d9f1de2430296ca2f3e42409"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a359ce980d9f1de2430296ca2f3e42409">setParamAttributes</a> (const size_t i, const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;in)</td></tr>
<tr class="separator:a359ce980d9f1de2430296ca2f3e42409"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac0e630c5cdb1ac4c91ebe9be00352690"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html#ac0e630c5cdb1ac4c91ebe9be00352690">CFunctionBase</a> (const size_t <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aac782da1f912bceb5d8ad00c8dc892ac">size</a>, const std::string &amp;<a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a7735bbeb07320c3f746b21c6a598c732">symbol</a>)</td></tr>
<tr class="separator:ac0e630c5cdb1ac4c91ebe9be00352690"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a3c7bbe5ddababca6b3a2da7a23a25fc1"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a3c7bbe5ddababca6b3a2da7a23a25fc1">cast</a> (std::vector&lt; llvm::Value * &gt; &amp;args, const std::vector&lt; llvm::Type * &gt; &amp;<a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#ad2e75a6e74e69d1563a9d41d626b30a0">types</a>, llvm::IRBuilder&lt;&gt; &amp;B)</td></tr>
<tr class="memdesc:a3c7bbe5ddababca6b3a2da7a23a25fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast the provided arguments to the given type as supported by implicit casting of function types. If the types already match OR if a cast cannot be performed, nothing is done to the argument.  <a href="#a3c7bbe5ddababca6b3a2da7a23a25fc1">More...</a><br /></td></tr>
<tr class="separator:a3c7bbe5ddababca6b3a2da7a23a25fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The base class for all C bindings. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ad99778adb8c85c822cfd12e9dd57a9ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a70d985fa48c8b1bd1f0d85cf96ec82d6">Ptr</a> =  std::shared_ptr&lt;<a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html">CFunctionBase</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="aee8c90b86fef2410c5903bcdd9df708c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The result type from calls to <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#ada1a5e0db7a1333bb336dc130f75a5d0" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="aee8c90b86fef2410c5903bcdd9df708cac9d3e887722f2bc482bcca9d41c512af"></a>None&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee8c90b86fef2410c5903bcdd9df708caff9abf2b1a689f70a77a18da50c01d9f"></a>Size&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee8c90b86fef2410c5903bcdd9df708ca81a198911eba60d4033c233d3ec90ea1"></a>Implicit&#160;</td><td class="fielddoc">
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="aee8c90b86fef2410c5903bcdd9df708cad2dd6ed7eca9210b09941bee2c62735f"></a>Explicit&#160;</td><td class="fielddoc">
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac732ba1d7a9a55bf71be88c9a47a6ed8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html">CFunctionBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac0e630c5cdb1ac4c91ebe9be00352690"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionBase.html">CFunctionBase</a> </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a9d2d0cbb03b257ffb000c68e1ba3bf88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint64_t address </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the global address of this function. </p>
<dl class="section note"><dt>Note</dt><dd>This is only required for C bindings. </dd></dl>

<p>Implemented in <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunction.html#a9c356f30a3b870881e0707253e77f3da">CFunction&lt; SignatureT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a54251bc604333f3dbb1a5ea4a4a808b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* argName </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the descriptive name of the given argument index. </p>
<p>If the index is greater than the number of arguments, an empty string is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td>The index of the argument </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a756495c036ac3d363d304fa97fe9fb7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Value* call </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>cast</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uses the IRBuilder to create a call to this function with the given arguments, creating the function and inserting it into the IRBuilder's Module if necessary (through <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a1c7d49fb9a9339c775f3a83d7dac9d69" title="Converts and creates this AX function into a llvm Function. ">Function::create</a>). Returns the result of the function call which can be a nullptr if the function is a non-sret void call. </p>
<dl class="section note"><dt>Note</dt><dd>The IRBuilder must have a valid llvm Module/Function/Block attached </dd>
<dd>
If the number of provided arguments do not match the size of the current function, invalid IR will be generated. </dd>
<dd>
If the provided argument types do not match the current function and cast is false, invalid IR will be generated. Additionally, invalid IR will be generated if cast is true but no valid cast exists for a given argument. </dd>
<dd>
When casting arguments, the readonly flags of the function are not checked (unlike <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#ada1a5e0db7a1333bb336dc130f75a5d0" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>). Casting an argument will cause a new copy of the argument to be created and passed to the function. These new values do not propagate back any changes to the original argument. Separate functions for all writable argument types must be created.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>The llvm Value arguments to call this function with </td></tr>
    <tr><td class="paramname">B</td><td>The llvm IRBuilder </td></tr>
    <tr><td class="paramname">cast</td><td>Whether to allow implicit casting of arguments </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1IRFunctionBase.html#a53beecbf86146a2e18686add3c227c3e">IRFunctionBase</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunction.html#a53beecbf86146a2e18686add3c227c3e">CFunction&lt; SignatureT &gt;</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1SRetFunction.html#a53beecbf86146a2e18686add3c227c3e">SRetFunction&lt; SignatureT, CFunction&lt; SignatureT &gt; &gt;</a>, and <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1SRetFunction.html#a53beecbf86146a2e18686add3c227c3e">SRetFunction&lt; SignatureT, IRFunction&lt; SignatureT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="a3c7bbe5ddababca6b3a2da7a23a25fc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void cast </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname"><em>args</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;&#160;</td>
          <td class="paramname"><em>types</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::IRBuilder&lt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast the provided arguments to the given type as supported by implicit casting of function types. If the types already match OR if a cast cannot be performed, nothing is done to the argument. </p>

</div>
</div>
<a class="anchor" id="a1c7d49fb9a9339c775f3a83d7dac9d69"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Function* create </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::Module *&#160;</td>
          <td class="paramname"><em>M</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts and creates this AX function into a llvm <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html" title="The base/abstract representation of an AX function. Derived classes must implement the Function::type...">Function</a>. </p>
<p>This method uses the result from <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#ad2e75a6e74e69d1563a9d41d626b30a0" title="Populate a vector of llvm::Types which describe this function signature. This method is used by Funct...">Function::types()</a> to construct a llvm::FunctionType and a subsequent a llvm::Function. Any parameter, return or function attributes are also added to the function. If a module is provided, the module if first checked to see if the function already exists. If it does, it is immediately returned. If the function doesn't exist in the module, its prototype is created and also inserted into the end of the modules function list. If no module is provided, the function is left detached and must be added to a valid Module to be callable. </p><dl class="section warning"><dt>Warning</dt><dd>If a module is not provided, the caller takes ownership of the returned function and is responsible for deallocating it. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The body of the function is left to derived classes to implement. As you need a Module to generate the prototype/body, this function serves two purposes. The first is to return the detached function signature if only a context is provided. The second is to ensure the function prototype and body (if required) is inserted into the module prior to returning. </dd>
<dd>
It is possible to end up with function symbol collisions if you do not have unique function symbols in your module</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The LLVM Context </td></tr>
    <tr><td class="paramname">M</td><td>The Module to write the function to </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1IRFunctionBase.html#afcd5821fd845e43ac5beca4358eef9b2">IRFunctionBase</a>.</p>

</div>
</div>
<a class="anchor" id="a5fea737cad05b175de71a0ebdc13612f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function* create </td>
          <td>(</td>
          <td class="paramtype">llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method which always uses the provided module to find the function or insert it if necessary. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The llvm::Module to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac5158708275b343f58432634eff78ecf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;const char*&gt;&amp; dependencies </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e740ea8bb949d01f304a83cd8b85a3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Value* fold </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Value * &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunction.html#a96b56fae5369165d3fe11afe9d9fa848">CFunction&lt; SignatureT &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="aa8d858554d7539c0e7fce6435b45de4b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">llvm::Function* get </td>
          <td>(</td>
          <td class="paramtype">const llvm::Module &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method for calling M.getFunction(symbol). Returns a nullptr if the function has not yet been created or if it is embedded IR. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">M</td><td>The llvm::Module to use </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a85f009138e6bdf1d632cf310cf2b51a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasConstantFold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa93871197f41264952182593a5c638a3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasParamAttribute </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const llvm::Attribute::AttrKind &amp;&#160;</td>
          <td class="paramname"><em>kind</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Builder methods. </p>

</div>
</div>
<a class="anchor" id="ada1a5e0db7a1333bb336dc130f75a5d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#aee8c90b86fef2410c5903bcdd9df708c">SignatureMatch</a> match </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Type * &gt; &amp;&#160;</td>
          <td class="paramname"><em>inputs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The base implementation for determining how a vector of llvm arguments translates to this functions signature. Returns an enum which represents the available mapping. </p>
<p>This method calls <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#ad2e75a6e74e69d1563a9d41d626b30a0" title="Populate a vector of llvm::Types which describe this function signature. This method is used by Funct...">types()</a> to figure out the function signature, then compares each argument type to the type in the input vector. If the types match exactly, an Explicit match is found. If the sizes of the inputs and signature differ, no match is found and None is returned. If however, the sizes match and there exists a valid implicit cast from the input type to the signature type for every input, an Implicit match is returned. Finally, if the sizes match but there is no implicit cast mapping, Size is returned. i8 -&gt; i32 : Implicit i32 -&gt; i32 : Explicit str -&gt; i32 : Size (i32,i32) -&gt; i32 : None </p><dl class="section note"><dt>Note</dt><dd>Due to the way <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunctionSRet.html" title="Represents a concrete C function binding with the first argument as its return type. ">CFunctionSRet</a> is implemented, the LLVM Context must be provided in case we have a zero arg function signature with a SRET. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputs</td><td>The input types </td></tr>
    <tr><td class="paramname">C</td><td>The LLVM Context </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1SRetFunction.html#ae3478e56d6f1d7325e335df6cd51d951">SRetFunction&lt; SignatureT, CFunction&lt; SignatureT &gt; &gt;</a>, and <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1SRetFunction.html#ae3478e56d6f1d7325e335df6cd51d951">SRetFunction&lt; SignatureT, IRFunction&lt; SignatureT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="abd8791caa902661a1de7954693348c4a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void print </td>
          <td>(</td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>axTypes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print this function's signature to the provided ostream. </p>
<p>This is intended to return a descriptive front end user string rather than the function's IR representation. This function is virtual so that derived classes can customize how they present frontend information. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1codegen.html#afd914562ed48960251bfe636ebe62045" title="Print a function signature to the provided ostream. ">printSignature</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>The llvm context </td></tr>
    <tr><td class="paramname">os</td><td>The ostream to print to </td></tr>
    <tr><td class="paramname">name</td><td>The name to insert into the description. </td></tr>
    <tr><td class="paramname">axTypes</td><td>Whether to print llvm IR or AX Types. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1SRetFunction.html#a47ee0943e6ecb389b72cda657aaaeced">SRetFunction&lt; SignatureT, CFunction&lt; SignatureT &gt; &gt;</a>, and <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1SRetFunction.html#a47ee0943e6ecb389b72cda657aaaeced">SRetFunction&lt; SignatureT, IRFunction&lt; SignatureT &gt; &gt;</a>.</p>

</div>
</div>
<a class="anchor" id="af6187793e0d3c6b1098b1d037e5b9530"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setArgumentNames </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>names</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a31e5847bbc4d67cfaf0be3c2e3c48184"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setConstantFold </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a130dc8b5cf81200428494e2d63384483"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setDependencies </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; const char * &gt;&#160;</td>
          <td class="paramname"><em>deps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6fb0a8f2ddba1d3d98741894a5db5f03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setFnAttributes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a359ce980d9f1de2430296ca2f3e42409"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setParamAttributes </td>
          <td>(</td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a51952659e55f5546f5e3d8f6a4e56eb3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setRetAttributes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; llvm::Attribute::AttrKind &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aac782da1f912bceb5d8ad00c8dc892ac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The number of arguments that this function has. </p>

</div>
</div>
<a class="anchor" id="a7735bbeb07320c3f746b21c6a598c732"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* symbol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The function symbol name. </p>
<p>This will be used as its identifier in IR and must be unique. </p>

</div>
</div>
<a class="anchor" id="ad2e75a6e74e69d1563a9d41d626b30a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual llvm::Type* types </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; llvm::Type * &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">llvm::LLVMContext &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate a vector of llvm::Types which describe this function signature. This method is used by <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#a1c7d49fb9a9339c775f3a83d7dac9d69" title="Converts and creates this AX function into a llvm Function. ">Function::create</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#abd8791caa902661a1de7954693348c4a" title="Print this function&#39;s signature to the provided ostream. ">Function::print</a> and <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1Function.html#ada1a5e0db7a1333bb336dc130f75a5d0" title="The base implementation for determining how a vector of llvm arguments translates to this functions s...">Function::match</a>. </p>

<p>Implemented in <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1IRFunction.html#a04b75f35c6d4d6956bed1cbba4837069">IRFunction&lt; SignatureT &gt;</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1IRFunctionBase.html#aba87622bfcd6b5a4d1d04a750dacb0ea">IRFunctionBase</a>, and <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1codegen_1_1CFunction.html#a04b75f35c6d4d6956bed1cbba4837069">CFunction&lt; SignatureT &gt;</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="FunctionTypes_8h_source.html">FunctionTypes.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
