<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: OpenVDB AX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenVDB</a></li><li class="navelem"><a class="el" href="openvdbax.html">OpenVDB AX</a></li><li class="navelem"><a class="el" href="ax.html">AX</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">OpenVDB AX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div style="width:800px;text-align:justify;"></div><div style="width:800px;text-align:justify;"></div><h1><a class="anchor" id="axcdocs"></a>
AX C++ Documentation</h1>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>The following documentation focuses on the C++ design and API of OpenVDB AX, <b>not</b> the front end AX language. For the latter, see the <a class="el" href="ax.html">AX Language documentation</a>. For more specific function API information, search for the relevant function doxygen. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>These documents are actively being worked on and are subject to change. See the API doxygen comments or contact us for more information.</dd></dl>
</div><h1><a class="anchor" id="vdbaxcontents"></a>
Contents</h1>
<div style="width:800px;text-align:justify;"><ul>
<li><a class="el" href="axcplusplus.html#vdbaxapiabi">Versioning, API and ABI</a></li>
<li><a class="el" href="axcplusplus.html#vdbaxrepo">OpenVDB AX Repository</a><ul>
<li><a class="el" href="axcplusplus.html#vdbaxgrammar">The Grammar</a></li>
<li><a class="el" href="axcplusplus.html#vdbaxast">The AST</a><ul>
<li><a class="el" href="axcplusplus.html#vdbaxastscanners">Scanners</a></li>
</ul>
</li>
<li><a class="el" href="axcplusplus.html#vdbaxcompilerpipe">The Compiler Pipeline</a><ul>
<li><a class="el" href="axcplusplus.html#vdbaxcompilerlogging">Logging</a></li>
<li><a class="el" href="axcplusplus.html#vdbaxcompilerexe">Executables</a></li>
<li><a class="el" href="axcplusplus.html#vdbaxcompilercustomdata">Custom Data</a></li>
<li><a class="el" href="axcplusplus.html#vdbaxcodegen">Codegen</a></li>
<li><a class="el" href="axcplusplus.html#vdbaxcompiler">The Compiler</a></li>
</ul>
</li>
<li><a class="el" href="axcplusplus.html#vdbaxbinary">The Command Line Binary</a></li>
</ul>
</li>
<li><a class="el" href="axcplusplus.html#vdbaxtoaxtypes">OpenVDB / OpenVDB AX Types</a></li>
<li><a class="el" href="axcplusplus.html#vdbaxextend">Extending OpenVDB AX</a></li>
</ul>
</div><div style="width:800px;text-align:justify;"><hr/>
</div><div style="width:800px;text-align:justify;"></div><h1><a class="anchor" id="vdbaxapiabi"></a>
Versioning, API and ABI</h1>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>AX is a self contained library which currently has a one way dependency on OpenVDB; any downstream artifact that uses AX will need to build and link against both OpenVDB and OpenVDB AX. There are a few important factors to be aware of with this integration: </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li>OpenVDB AX is tied to the OpenVDB library version. There is no explicit OpenVDB AX version. This includes the OpenVDB namespaced API, the shared library version suffix on relevant platforms and the OpenVDB ABI. It <em>may</em> be possible to build OpenVDB AX against a different version of OpenVDB however this is not explicitly supported.</li>
<li>There are no ABI compatibility guarantees for OpenVDB AX components i.e. AX components do not support the transfer of themselves as binary representations across dynamic library boundaries to applications where AX has been compiled at a different location in the OpenVDB repository. Support for this may change in the future. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>In general, anything in the public namespace (defined as anything not labelled "internal") comes with standard API guarantees; that is, classes and methods will not change visible behaviour or signatures and deprecations will occur with appropriate replacements (where necessary) prior to removal. However, due to the nature of the project and its infancy, it's encouraged to continue reading below into the relevant AX components. These provide a better description of their intended public consumption and completeness.</dd></dl>
<hr/>
</div><div style="width:800px;text-align:justify;"></div><h1><a class="anchor" id="vdbaxrepo"></a>
OpenVDB AX Repository</h1>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>The AX repository has been laid out using a modular design. Each subdirectory encompasses a set of similar tools with a fairly consistent (one-way) dependency diagram to other tools in the repository. The following provides a short description of each directory, listed in this ad-hoc dependency order (from highest to lowest): </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li><b>grammar:</b> Provides the flex/bison lexer/grammar rules for generating the OpenVDB AX language, as well as the pre-generated <code>.c</code> files.</li>
<li><b>ast:</b> The definition of an AX Abstract Syntax Tree, its node types and methods to work explicitly with them.</li>
<li><b>compiler:</b> The frontend C++ user interface for building and using AX.</li>
<li><b>codegen:</b> The backend LLVM IR code generation for AX. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>Additional tools include (in no particular order): </dd></dl>
<dl class="section user"><dt></dt><dd><ul>
<li><b>cmd:</b> Command line binary tools for AX.</li>
<li><b>math:</b> Various mathematical methods, typically used by the AX code generators when building native functions.</li>
<li><b>test:</b> Unit testing framework for AX.</li>
</ul>
</dd></dl>
</div><h2><a class="anchor" id="vdbaxgrammar"></a>
The Grammar</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>The subdirectory <b>grammar</b> contains the rules used to generate an AX abstract syntax tree, as defined by the <a class="el" href="ax.html">AX Language specification.</a> These files do not provide an API per-se and are primarily used internally by the <b>ast</b> module. The grammar syntax rules are specified in files with <b>.y</b> suffix and the tokenziers are specified by the <b>.l</b> suffix. These files are designed to work with two UNIX tools, GNU <a href="https://www.gnu.org/software/bison/manual/">Bison</a> and <a href="https://westes.github.io/flex/manual/">Flex</a>. Together these tools provide a workflow for developers to create develop a wide range of language parsers. It's encouraged to visit the corresponding manuals for more information on their use. </dd></dl>
<dl class="section user"><dt></dt><dd>The AX grammar is defined with a <a href="https://en.wikipedia.org/wiki/LR_parser">LR parser</a>. In simplest terms, this means that the syntactical rules define a grammar which is parsed bottom-up, left-to-right, deterministically and context free (for the most part). These are fairly typical traits of parsers used to define computer languages. The parser is <b>not</b> designed to be interactive, nor reentrant (is not thread safe, each string is parsed sequentially) however such limitations are not imposed by AX and may be removed in the future. Note that the internal function symbols are correctly prefixed (with <b>ax</b>), so AX should be compatible with other software that also uses Bison/Flex. </dd></dl>
<dl class="section user"><dt></dt><dd>The <b>.y</b> and <b>.l</b> files are typically not part of the normal build process. Bison and Flex use them to generate compatible C/C++ code, however this code is always pre-generated and provided with the AX repository within the <b>grammar/generated</b> subdirectory. This C/C++ code is compiled into the AX library. Thus, the grammar is provided for two reasons; to demonstrate how the syntactical rules are implemented and to provide expert users the ability to regenerate the C/C++ bindings (see <a class="el" href="build.html">the build instructions</a>). Importantly, AX does not install any of the files in the grammar folder; the parser is accessed through the <b>ast</b> module.</dd></dl>
</div><h2><a class="anchor" id="vdbaxast"></a>
The AST</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>The <b>ast</b> module provides:<ul>
<li>The complete implemenation of an <a class="el" href="AST_8h.html">AX abstract syntax tree</a></li>
<li>The <a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a2491bde6ba71abbbf4dfa96e2bf98a76" title="Construct an abstract syntax tree from a code snippet. A runtime exception will be thrown with the fi...">openvdb::ax::ast::parse()</a> method</li>
<li>The <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Visitor.html">AST Visitor</a></li>
<li>AST scanners and tools </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>All methods in this module are designed to work around an AX AST, which represents the syntactical constructs of the AX language as a hierarchy of C++ objects (nodes). The complete AST hierarchy is visualized by the <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">doxygen class graph for an openvdb::ax::ast::Node</a>, which represents the top most node in the AST. The AST API exists in a nested namespace (<code>openvdb::ax::ast</code>) and can be used by clients for more granular control and modifications to an AST. Importantly, the AST API contains the <a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a2491bde6ba71abbbf4dfa96e2bf98a76" title="Construct an abstract syntax tree from a code snippet. A runtime exception will be thrown with the fi...">openvdb::ax::ast::parse()</a> method, which invokes the C/C++ functions built by the grammar to iteratively construct an AST from a provided character string. </dd></dl>
<dl class="section user"><dt></dt><dd>A number of other tools are provided by the module to work with an AST such as tools to re-interpret the AST back to AX compatible code, printing of the AST's node hierarchy/layout and scanners which are able to query details from AST branches. All these methods use the <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Visitor.html">AX visitor framework</a>, a visitor pattern traversal class strongly influenced by <a href="https://clang.llvm.org/doxygen/classclang_1_1RecursiveASTVisitor.html">Clang's RecursiveVisitor</a>. Clients can use the AX visitor to implement their own AST analysis or modifications (see <a class="el" href="axcplusplus.html#vdbaxextend">Extending OpenVDB AX</a>).</dd></dl>
</div><h3><a class="anchor" id="vdbaxastscanners"></a>
Scanners</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>todo</dd></dl>
</div><h2><a class="anchor" id="vdbaxcompilerpipe"></a>
The Compiler Pipeline</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>The <b>compiler</b> subdirectory contains the bulk of the C++ API intended to be used directly by clients of OpenVDB AX. It links together the grammar, AST and code generation to produce AX executable objects, forming a pipeline from an initial string of AX code to final execution across some geometry. The following sections detail the core components to the Compiler pipeline.</dd></dl>
</div><h3><a class="anchor" id="vdbaxcompilerlogging"></a>
Logging</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Anyone familiar with programming languages will undoubtedly be aware of the huge variety and quantity of feedback that's presented to clients during use. This information, when properly presented, can be invaluable and help to advise users during their usage of the language. AX provides <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Logger.html">a Logger class</a> which can be used throughout the Compiler pipeline to store and report this information. By default, this class reports all errors to <a href="https://en.cppreference.com/w/cpp/io/cerr">std::cerr</a> and swallows warnings, but can be customised depending on your needs e.g: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Logger_8h.html">openvdb_ax/compiler/Logger.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Create a logger which sends errors and warnings to std::cerr</span></div><div class="line">openvdb::ax::Logger</div><div class="line">    logs([](<span class="keyword">const</span> std::string&amp; msg) { std::cerr &lt;&lt; msg &lt;&lt; std::endl; },</div><div class="line">         [](<span class="keyword">const</span> std::string&amp; msg) { std::cerr &lt;&lt; msg &lt;&lt; std::endl; });</div><div class="line"></div><div class="line">logs.setMaxErrors(5); <span class="comment">// stop reporting after 5 errors</span></div><div class="line">logs.setWarningsAsErrors(<span class="keyword">false</span>); <span class="comment">// don&#39;t count warnings as an error</span></div><div class="line">logs.setPrintLines(<span class="keyword">true</span>); <span class="comment">// print code lines</span></div><div class="line">logs.setNumberedOutput(<span class="keyword">true</span>); <span class="comment">// number each error/warning reported</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>A <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Logger.html">Logger</a> should be passed to the relevant pipeline methods as detailed in the following sections.</dd></dl>
</div><h3><a class="anchor" id="vdbaxcompilerexe"></a>
Executables</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>The "executable" terminology comes from the binary representation of the compiled function which is invoked. AX executables essentially wrap the generated function calls from the AX codegen with an efficient multi-threaded invoke for the type of geometry being processed. The executable classes are designed to be lightweight to store, modify and copy with a consolidated interface for running and customising execution. </dd></dl>
<dl class="section user"><dt></dt><dd>There are two main types of executables; the <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a>, designed to work with all OpenVDB Volumes and the <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1PointExecutable.html">PointExecutable</a> which works with OpenVDB <code>PointDataGrids</code>. They are not expected to be created directly; instead these objects are returned by the <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Compiler.html">AX Compiler</a> depending on the selected <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Compiler.html#ab40446d8dc41bae9519c7051d0a0b4f2">Compiler::compile() </a> function. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>There is no inherent limitation to the design of the <code>VolumeExecutable</code> which stops it working on <code>PointDataGrids</code> but it's not particular useful in it's current form and can be confusing so it is explicitly disallowed. </dd></dl>
<dl class="section user"><dt></dt><dd>The executables are distinctly detached from the <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Compiler.html">Compiler</a> once they have been built and can be safely used no matter previous or subsequent compilations of AX code. There are a variety of settings on the executables to control runtime behaviour - below demonstrates an example of using this API: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceopenvdb.html">openvdb</a>;</div><div class="line"></div><div class="line">ax::Compiler compiler;  <span class="comment">// compiler</span></div><div class="line"></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> a;</div><div class="line">a.setName(<span class="stringliteral">&quot;a&quot;</span>);</div><div class="line">a.tree().setValueOn({0,0,0}, 1.0f); <span class="comment">// set single coordinate to active 1.0f</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> ax::VolumeExecutable::Ptr exe1 =</div><div class="line">    compiler.compile&lt;ax::VolumeExecutable&gt;(<span class="stringliteral">&quot;f@a += 1.0f;&quot;</span>);</div><div class="line">exe1-&gt;execute(a); <span class="comment">// run over active leaf voxels in parallel</span></div><div class="line"></div><div class="line">ax::VolumeExecutable::Ptr exe2 =</div><div class="line">    compiler.compile&lt;ax::VolumeExecutable&gt;(<span class="stringliteral">&quot;f@a += 2.0f;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// set to process all voxels</span></div><div class="line">exe2-&gt;setValueIterator(<a class="code" href="namespaceopenvdb_1_1v8__1_1_1points_1_1index.html#a5d74787dedbc4e11c1ab15bf487e61f8ab1d5eac4b1dca480c8056eaea7663b7a">ax::VolumeExecutable::IterType::ALL</a>);</div><div class="line">exe2-&gt;execute(a); <span class="comment">// run over active and inactive leaf voxels in parallel</span></div><div class="line"></div><div class="line">std::cout &lt;&lt; a.tree().getValue({0,0,0}) &lt;&lt; std::endl; <span class="comment">// prints 4.0f</span></div><div class="line">std::cout &lt;&lt; a.tree().getValue({1,0,0}) &lt;&lt; std::endl; <span class="comment">// prints 2.0f</span></div></div><!-- fragment --></dd></dl>
<dl class="section user"><dt>Executable Thread Safety</dt><dd>The executables are responsible for launching the compiled AX kernels and may internally use multiple threads. Multiple executables of any type can co-exist and be executed concurrently with unique arguments. For example: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> a1, a2; <span class="comment">// assume both are named &quot;a&quot;</span></div><div class="line"><span class="keyword">auto</span> exe1 = compiler.compile&lt;ax::VolumeExecutable&gt;(<span class="stringliteral">&quot;f@a += 1.0f;&quot;</span>);</div><div class="line"><span class="keyword">auto</span> exe2 = compiler.compile&lt;ax::VolumeExecutable&gt;(<span class="stringliteral">&quot;f@a += 2.0f;&quot;</span>);</div><div class="line"></div><div class="line">std::thread t1([&amp;]() { exe1-&gt;execute(a1); } );</div><div class="line">std::thread t2([&amp;]() {</div><div class="line">    exe1-&gt;execute(a2); <span class="comment">// safe even if exe1::execute is being used by another thread</span></div><div class="line">    exe2-&gt;execute(a2); <span class="comment">// safe, can be running alongside another executable</span></div><div class="line">});</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>This is, however, only safe depending on the access pattern of the AX code, the iteration patterns of the executables and the grid data being fed to the <code>execute</code> methods. When we talk about the thread safety of these classes we are referring to the invocation of their execution method <b>with the same argument data</b> by multiple threads, <b>not</b> how many threads the executables themselves use (which can be configured by the <code>grainSize()</code> setting). Importantly, for a given VDB grid or VDB Points attribute <b>"foo"</b>:<ul>
<li>For The <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1VolumeExecutable.html">VolumeExecutable</a> it is safe to call <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1VolumeExecutable.html">VolumeExecutable::execute</a> <b>from</b> multiple threads only if:<ul>
<li>All relevant AX kernels <b>do not write</b> to grid <b>foo</b>.</li>
</ul>
</li>
<li>For The <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1PointExecutable.html">PointExecutable</a> it is safe to call <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1PointExecutable.html">PointExecutable::execute</a> <b>from</b> multiple threads only if:<ul>
<li>All relevant AX kernels <b>do not write</b> to attribute <b>foo</b>.</li>
<li>All relevant AX kernels <b>do not create</b> any attributes or groups.</li>
<li>All relevant AX kernels <b>do not modify</b> the <b>position</b> "P" attribute. </li>
</ul>
</li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>For example: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keyword">auto</span> exe = compiler.compile&lt;ax::VolumeExecutable&gt;(<span class="stringliteral">&quot;@a = @b&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Grid a1 and a2 called &quot;a&quot;, b called &quot;b&quot;. Grid b is given to both threads.</span></div><div class="line"><span class="comment">// This is safe as we guarantee b is only read from</span></div><div class="line">std::thread t1([&amp;]() { <a class="code" href="namespaceopenvdb_1_1v8__1.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a> v{a1,b}; exe1-&gt;execute(v); } );</div><div class="line">std::thread t2([&amp;]() { <a class="code" href="namespaceopenvdb_1_1v8__1.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a> v{a2,b}; exe1-&gt;execute(v); } );</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>You can use the tools provided in <a class="el" href="Scanners_8h.html">Scanners.h</a> to query data accesses on AX ASTs to verify access patterns of your data.</dd></dl>
</div><h3><a class="anchor" id="vdbaxcompilercustomdata"></a>
Custom Data</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>The AX language provides two main tokens to access memory which has not been allocated by AX itself. The first token, <b>@</b> (the "at" symbol), is designed to provide read/write access to geometry attributes. The second token is the dollar character <b>$</b>. This allows <b>read only</b> access to custom data that can be modified in C++ i.e. outside the scope of an AX program. In the same way as the <b>@attribute</b> syntax, the value of this data can change without the need for AX to re-compile the program. It is, however, solely on the C++ clients of AX to make sure that this data is setup correctly when integrating AX into their applications. </dd></dl>
<dl class="section user"><dt></dt><dd>Consider this trivial example: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">f@density = f$my_value;</div><div class="line"><span class="comment">// f$my_value = f@density; NOTE: writing to $ values is disallowed</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>When compiled, this program will attempt to read a single float type value with the storage name "my_value". If the value cannot be found, a zero intialized block of memory (with size of the desired type) is returned. So, with no further setup, this will assign each value of <b>density</b> to 0.0f. </dd></dl>
<dl class="section user"><dt></dt><dd>The <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1CustomData.html">CustomData</a> class provides the intermediary storage for this data between the code generation and the compiler. Clients should use this API to create and modify custom data which will become available to AX programs. Although the data is stored as abstract openvdb::Metadata objects, the values are embedded into AX programs as pointers to their location in memory. In practice this means that accessing data stored in this way is almost as fast as accessing an AX local variable, though certain optimizations, such as constant folding, will not apply. As previously mentioned, this also means that the AX program does not need to be recompiled should this value need to be changed. </dd></dl>
<dl class="section user"><dt></dt><dd>The <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1CustomData.html">CustomData</a> starts off detached from an executable and thus must be provided when invoking <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Compiler.html#ab40446d8dc41bae9519c7051d0a0b4f2">Compiler::compile()</a>. It is then tied to the AX executable for its duration. The compiler will validate the types of all accessed data of an AX program and, if it does not exist, the data will be created. Note that multiple executables can access the same <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1CustomData.html">CustomData</a> instance. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceopenvdb.html">openvdb</a>;</div><div class="line"></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#a2ae45d4df056c7d0d936a496fec925ee">FloatGrid</a> density;</div><div class="line">density.setName(<span class="stringliteral">&quot;density&quot;</span>);</div><div class="line"></div><div class="line">ax::Compiler compiler;  <span class="comment">// compiler</span></div><div class="line">ax::CustomData::Ptr data(<span class="keyword">new</span> ax::CustomData);  <span class="comment">// empty custom data</span></div><div class="line"></div><div class="line"><span class="comment">// data provided to compile is now registered with this exe. &quot;m_value&quot; is created</span></div><div class="line">ax::VolumeExecutable::Ptr exe =</div><div class="line">    compiler.compile&lt;ax::VolumeExecutable&gt;(<span class="stringliteral">&quot;f@density = f$my_value;&quot;</span>, data);</div><div class="line">exe-&gt;execute(density); <span class="comment">// my_value doesn&#39;t exist, density set to 0.0f</span></div><div class="line"></div><div class="line"><span class="comment">// Compiler::compile will have created this</span></div><div class="line">assert(data-&gt;hasValue&lt;TypedMetadata&lt;float&gt;&gt;(<span class="stringliteral">&quot;my_value&quot;</span>));</div><div class="line"></div><div class="line"><span class="comment">// get the data in its typed storage wrapper</span></div><div class="line">TypedMetadata&lt;float&gt;* meta = data-&gt;getValue&lt;TypedMetadata&lt;float&gt;&gt;(<span class="stringliteral">&quot;my_value&quot;</span>);</div><div class="line">meta-&gt;set(1.0f);  <span class="comment">// set the value of &quot;my_value&quot; to 1.0f</span></div><div class="line"></div><div class="line"><span class="comment">// don&#39;t need to re-compile</span></div><div class="line">exe-&gt;execute(density); <span class="comment">// density set to 1.0f</span></div></div><!-- fragment --> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Care should be taken to ensure that modifications to custom data values are peformed outside of any calls to <code>execute()</code>. Any attempt to modify the data whilst executables attempt to access it will result in undefined behaviour.</dd></dl>
</div><h3><a class="anchor" id="vdbaxcodegen"></a>
Codegen</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>todo</dd></dl>
</div><h3><a class="anchor" id="vdbaxcompiler"></a>
The Compiler</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>The <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Compiler.html">Compiler</a> brings together the above components. It is responsible setting up LLVM contexts and modules for a given AX program, invoking the compute generators, binding custom data, performing any necessary AX and LLVM optimisations and finally JIT compiling the program to a callable function. The <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Compiler.html#ab40446d8dc41bae9519c7051d0a0b4f2">Compiler::compile() </a> member functions execute the aforementioned steps and, if successful, return a pointer to an executable. </dd></dl>
<dl class="section user"><dt></dt><dd>There are two main ways to invoke compilation; one with an <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Logger.html">AX Logger</a> and one without. The prior will either return a valid pointer to a generated executable on success or a <code>nullptr</code> on failure. It is guaranteed to never throw a code generation runtime error and expects the caller to either query or setup the state of the logger to handle warnings and errors. The latter internally creates a default logger which swallows warnings and prints all possible errors to <code>std::cerr</code>. Note that the latter will throw a runtime error on failure and is thus guaranteed to never return a <code>nullptr</code>. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code" href="namespaceopenvdb.html">openvdb</a>;</div><div class="line"></div><div class="line">ax::Compiler compiler;</div><div class="line">std::vector&lt;std::string&gt; warn, err;</div><div class="line"><span class="comment">// custom logger to collect warnings and errors</span></div><div class="line">ax::Logger logger(</div><div class="line">    [&amp;warn]() { warn.emplace_back(msg); },</div><div class="line">    [&amp;err]()  { err.emplace_back(msg);  }</div><div class="line">);</div><div class="line"></div><div class="line"><span class="comment">// logger provided, exe could be null if input is invalid</span></div><div class="line"><span class="keyword">auto</span> exe = compiler.compile&lt;ax::VolumeExecutable&gt;(<span class="stringliteral">&quot;f@a = 1.0f;&quot;</span>, logger);</div><div class="line"><span class="comment">// print warnings</span></div><div class="line"><span class="keywordflow">for</span> (cosnt <span class="keyword">auto</span>&amp; msg : warn) std::cout &lt;&lt; msg &lt;&lt; std::endl;</div><div class="line"><span class="keywordflow">if</span> (!exe) {</div><div class="line">    <span class="keywordflow">for</span> (cosnt <span class="keyword">auto</span>&amp; msg : err) std::cout &lt;&lt; msg &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// without logger, divison by zero warning won&#39;t be reported</span></div><div class="line">exe = compiler.compile&lt;ax::VolumeExecutable&gt;(<span class="stringliteral">&quot;f@a = 1.0f / 0.0f;&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// without logger, invalid AX will cause a runtime error but</span></div><div class="line"><span class="comment">// also print errors to std::cerr</span></div><div class="line"><span class="keywordflow">try</span> {</div><div class="line">    exe = compiler.compile&lt;ax::VolumeExecutable&gt;(<span class="stringliteral">&quot;foo&quot;</span>);</div><div class="line">}</div><div class="line"><span class="keywordflow">catch</span> (...) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;See above error logs...&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --> </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>A single instance of the <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Compiler.html">AX Compiler</a> uses a uniquely constructed <a href="https://llvm.org/doxygen/classllvm_1_1LLVMContext.html">LLVMContext</a>. This context is <b>shared</b> between copies of the Compiler, however new Compilers create new LLVMContexts. It is therefor unsafe to invoke concurrent calls to <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Compiler.html#ab40446d8dc41bae9519c7051d0a0b4f2">Compiler::compile() </a> on Compilers which share the same underlying LLVMContext. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">ax::Compiler C1, C2;</div><div class="line"></div><div class="line"><span class="comment">// @warning Not safe!</span></div><div class="line"><span class="comment">// std::thread t1([&amp;]() { C1.compile&lt;ax::VolumeExecutable&gt;(&quot;@a;&quot;) } );</span></div><div class="line"><span class="comment">// std::thread t2([&amp;]() { C1.compile&lt;ax::VolumeExecutable&gt;(&quot;@b;&quot;) } );</span></div><div class="line"></div><div class="line"><span class="comment">// the following is safe as C1 and C2 are unique instances</span></div><div class="line">std::thread t1([&amp;]() { C1.compile&lt;ax::VolumeExecutable&gt;(<span class="stringliteral">&quot;@a;&quot;</span>) } );</div><div class="line">std::thread t2([&amp;]() { C2.compile&lt;ax::VolumeExecutable&gt;(<span class="stringliteral">&quot;@a;&quot;</span>) } );</div></div><!-- fragment --></dd></dl>
</div><h2><a class="anchor" id="vdbaxbinary"></a>
The Command Line Binary</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>todo</dd></dl>
<hr/>
</div><div style="width:800px;text-align:justify;"></div><h1><a class="anchor" id="vdbaxtoaxtypes"></a>
OpenVDB / OpenVDB AX Types</h1>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Whilst OpenVDB AX is primarily designed for OpenVDB, it has its own notion of types. This is so that the actual AX language is able to support arithmetic that OpenVDB geometry would perhaps otherwise not support. For example, AX supports 3x3 and 4x4 matrix types. These types are akin to the <code>openvdb::math::Mat</code> types that exist in OpenVDB library - however, historically, these types are not "registered Grid types" by default by OpenVDB. This means that, although you could theoretically create an <code>openvdb::Mat3dGrid</code> OpenVDB may not support the reading or writing of these grid types out the box. Whilst this may change in the future, there may exist other examples of types in AX which suffer from the same limitation of existing geometry types in OpenVDB. </dd></dl>
<dl class="section user"><dt></dt><dd>Native OpenVDB types are types which are <b>a</b>) registered for serialization and <b>b</b>) compilable by the default C++ installation of OpenVDB. This is a bit convoluted, so what does this actually mean in practice? Generally, accessing an <b>attribute</b> in AX requires that data to exist on the underlying geometry. As such, reading or writing to a given attribute (for example <code>bool@myattr</code>) requires both the AX compiler <b>and</b> the underlying geometry to support the given type. As mentioned above, there may be times where this isn't the case. Consider the following: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">vec4i a = {1,2,3,4};</div><div class="line">vec4i@attr = a;</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Now lets assume that a notion of four <code>int32</code> values is not supported for serialization of OpenVDB points or volumes (we assume the type can at least be instantiated). Whilst this code may execute, serializing this data to disk may fail due to unregistered OpenVDB types. AX does <b>not</b> register any additional OpenVDB types. This choice is left to downstream software. In this example, to allow for serialization of <code>vec4</code> types, some variant of the following can be implemented in your application. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>The choice to register Grid types in OpenVDB is left to the OpenVDB maintainers. There are important consequences to registering custom types - other default installations of OpenVDB <b>will not be able to read your files</b> unless compiled with similar instantiations. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#a446befa7deee56e243fee79c37263eaa">openvdb::initialize</a>(); <span class="comment">// standard init of vdb</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#a446befa7deee56e243fee79c37263eaa">openvdb::ax::initialize</a>(); <span class="comment">// standard init of ax</span></div><div class="line"><span class="comment">// Define a Vec4I grid type from the openvdb::math::Vec4&lt;int32_t&gt; class.</span></div><div class="line"><span class="comment">// Use a ValueConverter to ensure the grid has the same configuration as</span></div><div class="line"><span class="comment">// a standard OpenVDB grid type.</span></div><div class="line"><span class="keyword">using</span> Vec4IGrid = <a class="code" href="structopenvdb_1_1v8__1_1_1Grid_1_1ValueConverter.html">openvdb::BoolGrid::ValueConverter&lt;openvdb::Vec4I&gt;::Type</a>;</div><div class="line"><span class="comment">// register this type</span></div><div class="line">Vec4IGrid::registerGrid();</div></div><!-- fragment --></dd></dl>
<hr/>
 </div><h1><a class="anchor" id="vdbaxextend"></a>
Extending OpenVDB AX</h1>
<div style="width:800px;text-align:justify;"></div><div style="width:800px;text-align:justify;"></div> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
