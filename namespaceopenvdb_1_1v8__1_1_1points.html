<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: openvdb::v8_1::points Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__1.html">v8_1</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html">points</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">openvdb::v8_1::points Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1attribute__traits"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1attribute__traits.html">attribute_traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1future"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1future.html">future</a></td></tr>
<tr class="memdesc:namespaceopenvdb_1_1v8__1_1_1points_1_1future"><td class="mdescLeft">&#160;</td><td class="mdescRight">A container for ABI=5 to help ease introduction of upcoming features. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1index"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1index.html">index</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1index__filter__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1index__filter__internal.html">index_filter_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1point__advect__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1point__advect__internal.html">point_advect_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1point__attribute__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1point__attribute__internal.html">point_attribute_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1point__conversion__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1point__conversion__internal.html">point_conversion_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1point__delete__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1point__delete__internal.html">point_delete_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1point__group__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1point__group__internal.html">point_group_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1point__mask__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1point__mask__internal.html">point_mask_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1point__move__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1point__move__internal.html">point_move_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1point__sample__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1point__sample__internal.html">point_sample_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1points_1_1point__scatter__internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points_1_1point__scatter__internal.html">point_scatter_internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1AccessorEval.html">AccessorEval</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accessor to call unsafe get and set methods based on templated Codec and Value.  <a href="structopenvdb_1_1v8__1_1_1points_1_1AccessorEval.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1AccessorEval_3_01UnknownCodec_00_01ValueType_01_4.html">AccessorEval&lt; UnknownCodec, ValueType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial specialization when Codec is not known at compile-time to use the supplied functor instead.  <a href="structopenvdb_1_1v8__1_1_1points_1_1AccessorEval_3_01UnknownCodec_00_01ValueType_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeArray.html">AttributeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for storing attribute data.  <a href="classopenvdb_1_1v8__1_1_1points_1_1AttributeArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeHandle.html">AttributeHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeHashFilter.html">AttributeHashFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeSet.html">AttributeSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ordered collection of uniquely-named attribute arrays.  <a href="classopenvdb_1_1v8__1_1_1points_1_1AttributeSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeWriteHandle.html">AttributeWriteHandle</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write-able version of <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeHandle.html">AttributeHandle</a>.  <a href="classopenvdb_1_1v8__1_1_1points_1_1AttributeWriteHandle.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1BBoxFilter.html">BBoxFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1BinaryFilter.html">BinaryFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1CachedDeformer.html">CachedDeformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Deformer that caches the resulting positions from evaluating another Deformer.  <a href="classopenvdb_1_1v8__1_1_1points_1_1CachedDeformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1DeformerTraits.html">DeformerTraits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deformer Traits for optionally configuring deformers to be applied in index-space. The default is world-space.  <a href="structopenvdb_1_1v8__1_1_1points_1_1DeformerTraits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1DummySampleType.html">DummySampleType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1FilterTraits.html">FilterTraits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1FilterTraits_3_01BBoxFilter_01_4.html">FilterTraits&lt; BBoxFilter &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1FilterTraits_3_01BinaryFilter_3_01T0_00_01T1_00_01And_01_4_01_4.html">FilterTraits&lt; BinaryFilter&lt; T0, T1, And &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1FilterTraits_3_01LevelSetFilter_3_01T_01_4_01_4.html">FilterTraits&lt; LevelSetFilter&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1FixedPointCodec.html">FixedPointCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1GroupCodec.html">GroupCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1GroupFilter.html">GroupFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index filtering on group membership.  <a href="classopenvdb_1_1v8__1_1_1points_1_1GroupFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1GroupHandle.html">GroupHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1GroupWriteHandle.html">GroupWriteHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1IndexIter.html">IndexIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator over array indices with filtering IteratorT can be either <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1IndexIter.html" title="A forward iterator over array indices with filtering IteratorT can be either IndexIter or ValueIndexI...">IndexIter</a> or <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1IndexIter_1_1ValueIndexIter.html" title="A forward iterator over array indices from a value iterator (such as ValueOnCIter) ...">ValueIndexIter</a> (or some custom index iterator) FilterT should be a struct or class with a valid() method than can be evaluated per index Here's a simple filter example that only accepts even indices:  <a href="classopenvdb_1_1v8__1_1_1points_1_1IndexIter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1LevelSetFilter.html">LevelSetFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1MultiGroupFilter.html">MultiGroupFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1NullCodec.html">NullCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1NullDeformer.html">NullDeformer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op deformer (adheres to the deformer interface documented in <a class="el" href="PointMove_8h.html" title="Ability to move VDB Points using a custom deformer. ">PointMove.h</a>)  <a href="structopenvdb_1_1v8__1_1_1points_1_1NullDeformer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A no-op filter that can be used when iterating over all indices.  <a href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1PointAttributeVector.html">PointAttributeVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point-partitioner compatible STL vector attribute wrapper for convenience.  <a href="classopenvdb_1_1v8__1_1_1points_1_1PointAttributeVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1PointDataLeafNode.html">PointDataLeafNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1PositionRange.html">PositionRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1RandomLeafFilter.html">RandomLeafFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1SampleWithRounding.html">SampleWithRounding</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1StringAttributeHandle.html">StringAttributeHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1StringAttributeWriteHandle.html">StringAttributeWriteHandle</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1StringCodec.html">StringCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1StringMetaCache.html">StringMetaCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to compute a string-&gt;index map from all string:N metadata.  <a href="classopenvdb_1_1v8__1_1_1points_1_1StringMetaCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1StringMetaInserter.html">StringMetaInserter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to help with insertion of keyed string values into metadata.  <a href="classopenvdb_1_1v8__1_1_1points_1_1StringMetaInserter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1TreeConverter.html">TreeConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similiar to ValueConverter, but allows for tree configuration conversion to a PointDataTree. ValueConverter&lt;PointDataIndex32&gt; cannot be used as a <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1PointDataLeafNode.html">PointDataLeafNode</a> is not a specialization of LeafNode.  <a href="structopenvdb_1_1v8__1_1_1points_1_1TreeConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1TruncateCodec.html">TruncateCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typed class for storing attribute data.  <a href="classopenvdb_1_1v8__1_1_1points_1_1TypedAttributeArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1UnitRange.html">UnitRange</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1UnitVecCodec.html">UnitVecCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1UnknownCodec.html">UnknownCodec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Index filtering on active / inactive state of host voxel.  <a href="classopenvdb_1_1v8__1_1_1points_1_1ValueMaskFilter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1ValueVoxelCIter.html">ValueVoxelCIter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward iterator over array indices in a single voxel.  <a href="classopenvdb_1_1v8__1_1_1points_1_1ValueVoxelCIter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:af44fac5036c56999ca811116b73eca72"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#af44fac5036c56999ca811116b73eca72">StringAttributeArray</a> = <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a>&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1StringCodec.html">StringCodec</a>&lt; false &gt;&gt;</td></tr>
<tr class="separator:af44fac5036c56999ca811116b73eca72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc95058fb208e9baa08dab77d98c5fa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a9bc95058fb208e9baa08dab77d98c5fa">GroupAttributeArray</a> = <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a>&lt; <a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a714bfd681b0e82019a95174ecdb6a889">GroupType</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1GroupCodec.html">GroupCodec</a> &gt;</td></tr>
<tr class="separator:a9bc95058fb208e9baa08dab77d98c5fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714bfd681b0e82019a95174ecdb6a889"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a714bfd681b0e82019a95174ecdb6a889">GroupType</a> = uint8_t</td></tr>
<tr class="separator:a714bfd681b0e82019a95174ecdb6a889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8954944cf980f1f874a6510497568338"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a8954944cf980f1f874a6510497568338">ActiveFilter</a> = <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a>&lt; true &gt;</td></tr>
<tr class="separator:a8954944cf980f1f874a6510497568338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8273cc7bb48dded419013b35a6491bc0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a8273cc7bb48dded419013b35a6491bc0">InactiveFilter</a> = <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a>&lt; false &gt;</td></tr>
<tr class="separator:a8273cc7bb48dded419013b35a6491bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fec47b2a3d864d85c53f69c3655fdbf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a7fec47b2a3d864d85c53f69c3655fdbf">PointDataTree</a> = <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html">tree::Tree</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">tree::RootNode</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">tree::InternalNode</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">tree::InternalNode</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1PointDataLeafNode.html">PointDataLeafNode</a>&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#afcdd46e3c391ea8febd5fa6017b9f19b">PointDataIndex32</a>, 3 &gt;, 4 &gt;, 5 &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a7fec47b2a3d864d85c53f69c3655fdbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point index tree configured to match the default VDB configurations.  <a href="#a7fec47b2a3d864d85c53f69c3655fdbf">More...</a><br /></td></tr>
<tr class="separator:a7fec47b2a3d864d85c53f69c3655fdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf438a63a8a41ec38b6d7ceae6467678"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#acf438a63a8a41ec38b6d7ceae6467678">PointDataGrid</a> = <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html">Grid</a>&lt; <a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a7fec47b2a3d864d85c53f69c3655fdbf">PointDataTree</a> &gt;</td></tr>
<tr class="memdesc:acf438a63a8a41ec38b6d7ceae6467678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Point data grid.  <a href="#acf438a63a8a41ec38b6d7ceae6467678">More...</a><br /></td></tr>
<tr class="separator:acf438a63a8a41ec38b6d7ceae6467678"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a080e28eb43adab30c573deecea1f1f51"><td class="memTemplParams" colspan="2">template&lt;typename IntegerT , typename FloatT &gt; </td></tr>
<tr class="memitem:a080e28eb43adab30c573deecea1f1f51"><td class="memTemplItemLeft" align="right" valign="top">IntegerT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a080e28eb43adab30c573deecea1f1f51">floatingPointToFixedPoint</a> (const FloatT s)</td></tr>
<tr class="separator:a080e28eb43adab30c573deecea1f1f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4189b7d55ec4e7ccc6445e205174a979"><td class="memTemplParams" colspan="2">template&lt;typename FloatT , typename IntegerT &gt; </td></tr>
<tr class="memitem:a4189b7d55ec4e7ccc6445e205174a979"><td class="memTemplItemLeft" align="right" valign="top">FloatT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a4189b7d55ec4e7ccc6445e205174a979">fixedPointToFloatingPoint</a> (const IntegerT s)</td></tr>
<tr class="separator:a4189b7d55ec4e7ccc6445e205174a979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fec300721a981a1fcff3e765d86c10d"><td class="memTemplParams" colspan="2">template&lt;typename IntegerVectorT , typename FloatT &gt; </td></tr>
<tr class="memitem:a1fec300721a981a1fcff3e765d86c10d"><td class="memTemplItemLeft" align="right" valign="top">IntegerVectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a1fec300721a981a1fcff3e765d86c10d">floatingPointToFixedPoint</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">math::Vec3</a>&lt; FloatT &gt; &amp;v)</td></tr>
<tr class="separator:a1fec300721a981a1fcff3e765d86c10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab860367c1015286c5e8c695dc88f099e"><td class="memTemplParams" colspan="2">template&lt;typename FloatVectorT , typename IntegerT &gt; </td></tr>
<tr class="memitem:ab860367c1015286c5e8c695dc88f099e"><td class="memTemplItemLeft" align="right" valign="top">FloatVectorT&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#ab860367c1015286c5e8c695dc88f099e">fixedPointToFloatingPoint</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">math::Vec3</a>&lt; IntegerT &gt; &amp;v)</td></tr>
<tr class="separator:ab860367c1015286c5e8c695dc88f099e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a0eeaeec10ea9846c72f9dcd9764c80"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a0a0eeaeec10ea9846c72f9dcd9764c80">isString</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeArray.html">AttributeArray</a> &amp;array)</td></tr>
<tr class="separator:a0a0eeaeec10ea9846c72f9dcd9764c80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1386ebd3d0e91d83094afc4b4cb89ff4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a1386ebd3d0e91d83094afc4b4cb89ff4">isGroup</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeArray.html">AttributeArray</a> &amp;array)</td></tr>
<tr class="separator:a1386ebd3d0e91d83094afc4b4cb89ff4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb5e64392fdf29bc3462e5a60713158"><td class="memTemplParams" colspan="2">template&lt;typename IterT &gt; </td></tr>
<tr class="memitem:adfb5e64392fdf29bc3462e5a60713158"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#adfb5e64392fdf29bc3462e5a60713158">iterCount</a> (const IterT &amp;iter)</td></tr>
<tr class="memdesc:adfb5e64392fdf29bc3462e5a60713158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count up the number of times the iterator can iterate.  <a href="#adfb5e64392fdf29bc3462e5a60713158">More...</a><br /></td></tr>
<tr class="separator:adfb5e64392fdf29bc3462e5a60713158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab79ffb24dc5aee12a75d1507966164bc"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename VelGridT , typename AdvectFilterT  = NullFilter, typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:ab79ffb24dc5aee12a75d1507966164bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#ab79ffb24dc5aee12a75d1507966164bc">advectPoints</a> (PointDataGridT &amp;points, const VelGridT &amp;velocity, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> integrationOrder, const double dt, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> timeSteps, const AdvectFilterT &amp;advectFilter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool cached=true)</td></tr>
<tr class="memdesc:ab79ffb24dc5aee12a75d1507966164bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advect points in a PointDataGrid through a velocity grid.  <a href="#ab79ffb24dc5aee12a75d1507966164bc">More...</a><br /></td></tr>
<tr class="separator:ab79ffb24dc5aee12a75d1507966164bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8216e14812f6a9c9aaf1af5b2ad36b"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a9f8216e14812f6a9c9aaf1af5b2ad36b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a9f8216e14812f6a9c9aaf1af5b2ad36b">appendAttribute</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;name, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a3907786c2430dbab9f198bfd5b31ff7c">NamePair</a> &amp;type, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> strideOrTotalSize=1, const bool constantStride=true, const <a class="el" href="classopenvdb_1_1v8__1_1_1Metadata.html">Metadata</a> *defaultValue=nullptr, const bool hidden=false, const bool transient=false)</td></tr>
<tr class="memdesc:a9f8216e14812f6a9c9aaf1af5b2ad36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new attribute to the VDB tree (this method does not require a templated AttributeType)  <a href="#a9f8216e14812f6a9c9aaf1af5b2ad36b">More...</a><br /></td></tr>
<tr class="separator:a9f8216e14812f6a9c9aaf1af5b2ad36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12af91f538ab5256ce2db4afe3b9dd31"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename CodecType  = NullCodec, typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a12af91f538ab5256ce2db4afe3b9dd31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a12af91f538ab5256ce2db4afe3b9dd31">appendAttribute</a> (PointDataTreeT &amp;tree, const std::string &amp;name, const ValueType &amp;uniformValue=<a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1point__attribute__internal_1_1Default.html">point_attribute_internal::Default</a>&lt; ValueType &gt;::value(), const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> strideOrTotalSize=1, const bool constantStride=true, const <a class="el" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html">TypedMetadata</a>&lt; ValueType &gt; *defaultValue=nullptr, const bool hidden=false, const bool transient=false)</td></tr>
<tr class="memdesc:a12af91f538ab5256ce2db4afe3b9dd31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new attribute to the VDB tree.  <a href="#a12af91f538ab5256ce2db4afe3b9dd31">More...</a><br /></td></tr>
<tr class="separator:a12af91f538ab5256ce2db4afe3b9dd31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b46b75155cc394f4ad4b540f167523a"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a6b46b75155cc394f4ad4b540f167523a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a6b46b75155cc394f4ad4b540f167523a">collapseAttribute</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;name, const ValueType &amp;uniformValue=<a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1point__attribute__internal_1_1Default.html">point_attribute_internal::Default</a>&lt; ValueType &gt;::value())</td></tr>
<tr class="memdesc:a6b46b75155cc394f4ad4b540f167523a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collapse the attribute into a uniform value.  <a href="#a6b46b75155cc394f4ad4b540f167523a">More...</a><br /></td></tr>
<tr class="separator:a6b46b75155cc394f4ad4b540f167523a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaa22577ec29a353a700c9a3fa03906f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:aaaa22577ec29a353a700c9a3fa03906f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#aaaa22577ec29a353a700c9a3fa03906f">dropAttributes</a> (PointDataTreeT &amp;tree, const std::vector&lt; size_t &gt; &amp;indices)</td></tr>
<tr class="memdesc:aaaa22577ec29a353a700c9a3fa03906f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops attributes from the VDB tree.  <a href="#aaaa22577ec29a353a700c9a3fa03906f">More...</a><br /></td></tr>
<tr class="separator:aaaa22577ec29a353a700c9a3fa03906f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8ee0b505384ce90253b77516cedce4"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:aaa8ee0b505384ce90253b77516cedce4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#aaa8ee0b505384ce90253b77516cedce4">dropAttributes</a> (PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;names)</td></tr>
<tr class="memdesc:aaa8ee0b505384ce90253b77516cedce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops attributes from the VDB tree.  <a href="#aaa8ee0b505384ce90253b77516cedce4">More...</a><br /></td></tr>
<tr class="separator:aaa8ee0b505384ce90253b77516cedce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630071eb13957e9c9683fafb845ec9ce"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a630071eb13957e9c9683fafb845ec9ce"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a630071eb13957e9c9683fafb845ec9ce">dropAttribute</a> (PointDataTreeT &amp;tree, const size_t &amp;index)</td></tr>
<tr class="memdesc:a630071eb13957e9c9683fafb845ec9ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop one attribute from the VDB tree (convenience method).  <a href="#a630071eb13957e9c9683fafb845ec9ce">More...</a><br /></td></tr>
<tr class="separator:a630071eb13957e9c9683fafb845ec9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd25e23091c52fb8da4fcb50369ad45b"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:acd25e23091c52fb8da4fcb50369ad45b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#acd25e23091c52fb8da4fcb50369ad45b">dropAttribute</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;name)</td></tr>
<tr class="memdesc:acd25e23091c52fb8da4fcb50369ad45b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drop one attribute from the VDB tree (convenience method).  <a href="#acd25e23091c52fb8da4fcb50369ad45b">More...</a><br /></td></tr>
<tr class="separator:acd25e23091c52fb8da4fcb50369ad45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceb82e6282deeaa12012efbe386ce564"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:aceb82e6282deeaa12012efbe386ce564"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#aceb82e6282deeaa12012efbe386ce564">renameAttributes</a> (PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;oldNames, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;newNames)</td></tr>
<tr class="memdesc:aceb82e6282deeaa12012efbe386ce564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename attributes in a VDB tree.  <a href="#aceb82e6282deeaa12012efbe386ce564">More...</a><br /></td></tr>
<tr class="separator:aceb82e6282deeaa12012efbe386ce564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb60e92fdbb25ad5822945cc30b3e8b2"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:aeb60e92fdbb25ad5822945cc30b3e8b2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#aeb60e92fdbb25ad5822945cc30b3e8b2">renameAttribute</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;oldName, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;newName)</td></tr>
<tr class="memdesc:aeb60e92fdbb25ad5822945cc30b3e8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename an attribute in a VDB tree.  <a href="#aeb60e92fdbb25ad5822945cc30b3e8b2">More...</a><br /></td></tr>
<tr class="separator:aeb60e92fdbb25ad5822945cc30b3e8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467b8eefb87ca02fa0f017c40c08d674"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a467b8eefb87ca02fa0f017c40c08d674"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a467b8eefb87ca02fa0f017c40c08d674">compactAttributes</a> (PointDataTreeT &amp;tree)</td></tr>
<tr class="memdesc:a467b8eefb87ca02fa0f017c40c08d674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compact attributes in a VDB tree (if possible).  <a href="#a467b8eefb87ca02fa0f017c40c08d674">More...</a><br /></td></tr>
<tr class="separator:a467b8eefb87ca02fa0f017c40c08d674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15a1ee82d506999536458071ba44299"><td class="memTemplParams" colspan="2">template&lt;typename CompressionT , typename PointDataGridT , typename PositionArrayT , typename PointIndexGridT &gt; </td></tr>
<tr class="memitem:ab15a1ee82d506999536458071ba44299"><td class="memTemplItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#ab15a1ee82d506999536458071ba44299">createPointDataGrid</a> (const PointIndexGridT &amp;pointIndexGrid, const PositionArrayT &amp;positions, const <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html">math::Transform</a> &amp;xform, const <a class="el" href="classopenvdb_1_1v8__1_1_1Metadata.html">Metadata</a> *positionDefaultValue=nullptr)</td></tr>
<tr class="memdesc:ab15a1ee82d506999536458071ba44299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Localises points with position into a <code>PointDataGrid</code> into two stages: allocation of the leaf attribute data and population of the positions.  <a href="#ab15a1ee82d506999536458071ba44299">More...</a><br /></td></tr>
<tr class="separator:ab15a1ee82d506999536458071ba44299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c2da02df6fb329b2684f56617c39b9"><td class="memTemplParams" colspan="2">template&lt;typename CompressionT , typename PointDataGridT , typename ValueT &gt; </td></tr>
<tr class="memitem:a07c2da02df6fb329b2684f56617c39b9"><td class="memTemplItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a07c2da02df6fb329b2684f56617c39b9">createPointDataGrid</a> (const std::vector&lt; ValueT &gt; &amp;positions, const <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html">math::Transform</a> &amp;xform, const <a class="el" href="classopenvdb_1_1v8__1_1_1Metadata.html">Metadata</a> *positionDefaultValue=nullptr)</td></tr>
<tr class="memdesc:a07c2da02df6fb329b2684f56617c39b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience method to create a <code>PointDataGrid</code> from a std::vector of point positions.  <a href="#a07c2da02df6fb329b2684f56617c39b9">More...</a><br /></td></tr>
<tr class="separator:a07c2da02df6fb329b2684f56617c39b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7557b731e5392e4448f933a84139950"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT , typename PointIndexTreeT , typename PointArrayT &gt; </td></tr>
<tr class="memitem:ad7557b731e5392e4448f933a84139950"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#ad7557b731e5392e4448f933a84139950">populateAttribute</a> (PointDataTreeT &amp;tree, const PointIndexTreeT &amp;pointIndexTree, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">openvdb::Name</a> &amp;attributeName, const PointArrayT &amp;data, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> stride=1, const bool insertMetadata=true)</td></tr>
<tr class="memdesc:ad7557b731e5392e4448f933a84139950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores point attribute data in an existing <code>PointDataGrid</code> attribute.  <a href="#ad7557b731e5392e4448f933a84139950">More...</a><br /></td></tr>
<tr class="separator:ad7557b731e5392e4448f933a84139950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf905ca86b725954bf900e3caf6b431a"><td class="memTemplParams" colspan="2">template&lt;typename PositionAttribute , typename PointDataGridT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:acf905ca86b725954bf900e3caf6b431a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#acf905ca86b725954bf900e3caf6b431a">convertPointDataGridPosition</a> (PositionAttribute &amp;positionAttribute, const PointDataGridT &amp;grid, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;<a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a639be5922b4acf36c519e88f9ea8ff7d">pointOffsets</a>, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> startOffset, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false)</td></tr>
<tr class="memdesc:acf905ca86b725954bf900e3caf6b431a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the position attribute from a Point Data <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a>.  <a href="#acf905ca86b725954bf900e3caf6b431a">More...</a><br /></td></tr>
<tr class="separator:acf905ca86b725954bf900e3caf6b431a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91e520838e75f17a4e0a3505c128931"><td class="memTemplParams" colspan="2">template&lt;typename TypedAttribute , typename PointDataTreeT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:ac91e520838e75f17a4e0a3505c128931"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#ac91e520838e75f17a4e0a3505c128931">convertPointDataGridAttribute</a> (TypedAttribute &amp;attribute, const PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;<a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a639be5922b4acf36c519e88f9ea8ff7d">pointOffsets</a>, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> startOffset, const unsigned arrayIndex, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> stride=1, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false)</td></tr>
<tr class="memdesc:ac91e520838e75f17a4e0a3505c128931"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the attribute from a PointDataGrid.  <a href="#ac91e520838e75f17a4e0a3505c128931">More...</a><br /></td></tr>
<tr class="separator:ac91e520838e75f17a4e0a3505c128931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4875034852344d7f676c955bb764d9c1"><td class="memTemplParams" colspan="2">template&lt;typename Group , typename PointDataTreeT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a4875034852344d7f676c955bb764d9c1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a4875034852344d7f676c955bb764d9c1">convertPointDataGridGroup</a> (Group &amp;group, const PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;<a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a639be5922b4acf36c519e88f9ea8ff7d">pointOffsets</a>, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> startOffset, const AttributeSet::Descriptor::GroupIndex index, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false)</td></tr>
<tr class="memdesc:a4875034852344d7f676c955bb764d9c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the group from a PointDataGrid.  <a href="#a4875034852344d7f676c955bb764d9c1">More...</a><br /></td></tr>
<tr class="separator:a4875034852344d7f676c955bb764d9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ec3ffe5c7a9e7745c3a55de49ea125"><td class="memTemplParams" colspan="2">template&lt;typename PositionWrapper , typename InterrupterT  = openvdb::util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ab9ec3ffe5c7a9e7745c3a55de49ea125"><td class="memTemplItemLeft" align="right" valign="top">float&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#ab9ec3ffe5c7a9e7745c3a55de49ea125">computeVoxelSize</a> (const PositionWrapper &amp;positions, const uint32_t pointsPerVoxel, const <a class="el" href="namespaceopenvdb_1_1v8__1_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">math::Mat4d</a> transform=<a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Mat4.html#a71890348d53084982694f39988f4b286">math::Mat4d::identity</a>(), const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> decimalPlaces=5, InterrupterT *const interrupter=nullptr)</td></tr>
<tr class="separator:ab9ec3ffe5c7a9e7745c3a55de49ea125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dbfd50108bbe665a6e1a0607335a5df"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a8dbfd50108bbe665a6e1a0607335a5df"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a8dbfd50108bbe665a6e1a0607335a5df">pointCount</a> (const PointDataTreeT &amp;tree, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false, const bool threaded=true)</td></tr>
<tr class="memdesc:a8dbfd50108bbe665a6e1a0607335a5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the total number of points in a PointDataTree.  <a href="#a8dbfd50108bbe665a6e1a0607335a5df">More...</a><br /></td></tr>
<tr class="separator:a8dbfd50108bbe665a6e1a0607335a5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a639be5922b4acf36c519e88f9ea8ff7d"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a639be5922b4acf36c519e88f9ea8ff7d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a639be5922b4acf36c519e88f9ea8ff7d">pointOffsets</a> (std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;pointOffsets, const PointDataTreeT &amp;tree, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), const bool inCoreOnly=false, const bool threaded=true)</td></tr>
<tr class="memdesc:a639be5922b4acf36c519e88f9ea8ff7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate an array of cumulative point offsets per leaf node.  <a href="#a639be5922b4acf36c519e88f9ea8ff7d">More...</a><br /></td></tr>
<tr class="separator:a639be5922b4acf36c519e88f9ea8ff7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90464075cf4382ab74a75288eebfce02"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename GridT  = typename PointDataGridT::template ValueConverter&lt;Int32&gt;::Type, typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a90464075cf4382ab74a75288eebfce02"><td class="memTemplItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a90464075cf4382ab74a75288eebfce02">pointCountGrid</a> (const PointDataGridT &amp;grid, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:a90464075cf4382ab74a75288eebfce02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new grid with voxel values to store the number of points per voxel.  <a href="#a90464075cf4382ab74a75288eebfce02">More...</a><br /></td></tr>
<tr class="separator:a90464075cf4382ab74a75288eebfce02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2159bcf1fea38531ec493459f3b37857"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename GridT  = typename PointDataGridT::template ValueConverter&lt;Int32&gt;::Type, typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a2159bcf1fea38531ec493459f3b37857"><td class="memTemplItemLeft" align="right" valign="top">GridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a2159bcf1fea38531ec493459f3b37857">pointCountGrid</a> (const PointDataGridT &amp;grid, const openvdb::math::Transform &amp;transform, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>())</td></tr>
<tr class="memdesc:a2159bcf1fea38531ec493459f3b37857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new grid that uses the supplied transform with voxel values to store the number of points per voxel.  <a href="#a2159bcf1fea38531ec493459f3b37857">More...</a><br /></td></tr>
<tr class="separator:a2159bcf1fea38531ec493459f3b37857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af351ce8e812595d5fede2fd73ce96420"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:af351ce8e812595d5fede2fd73ce96420"><td class="memTemplItemLeft" align="right" valign="top">AttributeSet::Descriptor::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#af351ce8e812595d5fede2fd73ce96420">makeDescriptorUnique</a> (PointDataTreeT &amp;tree)</td></tr>
<tr class="memdesc:af351ce8e812595d5fede2fd73ce96420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy the descriptor across all leaf nodes.  <a href="#af351ce8e812595d5fede2fd73ce96420">More...</a><br /></td></tr>
<tr class="separator:af351ce8e812595d5fede2fd73ce96420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d85a4b1b93c26f69ecf71e75017275b"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a0d85a4b1b93c26f69ecf71e75017275b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a0d85a4b1b93c26f69ecf71e75017275b">setStreamingMode</a> (PointDataTreeT &amp;tree, bool on=true)</td></tr>
<tr class="memdesc:a0d85a4b1b93c26f69ecf71e75017275b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Toggle the streaming mode on all attributes in the tree to collapse the attributes after deconstructing a bound <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeHandle.html">AttributeHandle</a> to each array. This results in better memory efficiency when the data is streamed into another data structure (typically for rendering).  <a href="#a0d85a4b1b93c26f69ecf71e75017275b">More...</a><br /></td></tr>
<tr class="separator:a0d85a4b1b93c26f69ecf71e75017275b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2205d8c5a7c5fd2e24145a9df5ad6485"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a2205d8c5a7c5fd2e24145a9df5ad6485"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a2205d8c5a7c5fd2e24145a9df5ad6485">prefetch</a> (PointDataTreeT &amp;tree, bool position=true, bool otherAttributes=true)</td></tr>
<tr class="memdesc:a2205d8c5a7c5fd2e24145a9df5ad6485"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequentially pre-fetch all delayed-load voxel and attribute data from disk in order to accelerate subsequent random access.  <a href="#a2205d8c5a7c5fd2e24145a9df5ad6485">More...</a><br /></td></tr>
<tr class="separator:a2205d8c5a7c5fd2e24145a9df5ad6485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b9d921b422e929c3786e77c8d4c811f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a6b9d921b422e929c3786e77c8d4c811f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a6b9d921b422e929c3786e77c8d4c811f">deleteFromGroups</a> (PointDataTreeT &amp;pointTree, const std::vector&lt; std::string &gt; &amp;groups, bool invert=false, bool drop=true)</td></tr>
<tr class="memdesc:a6b9d921b422e929c3786e77c8d4c811f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete points that are members of specific groups.  <a href="#a6b9d921b422e929c3786e77c8d4c811f">More...</a><br /></td></tr>
<tr class="separator:a6b9d921b422e929c3786e77c8d4c811f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdbd30a3741affcd2b2434124a34149d"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:afdbd30a3741affcd2b2434124a34149d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#afdbd30a3741affcd2b2434124a34149d">deleteFromGroup</a> (PointDataTreeT &amp;pointTree, const std::string &amp;group, bool invert=false, bool drop=true)</td></tr>
<tr class="memdesc:afdbd30a3741affcd2b2434124a34149d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete points that are members of a group.  <a href="#afdbd30a3741affcd2b2434124a34149d">More...</a><br /></td></tr>
<tr class="separator:afdbd30a3741affcd2b2434124a34149d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e318d6bae7846125e0ac39c66024fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a5e318d6bae7846125e0ac39c66024fc2">deleteMissingPointGroups</a> (std::vector&lt; std::string &gt; &amp;groups, const <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeSet.html#abf4c4c63e6ef3b54e88cd0cab0be66c8">AttributeSet::Descriptor</a> &amp;descriptor)</td></tr>
<tr class="memdesc:a5e318d6bae7846125e0ac39c66024fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete any group that is not present in the Descriptor.  <a href="#a5e318d6bae7846125e0ac39c66024fc2">More...</a><br /></td></tr>
<tr class="separator:a5e318d6bae7846125e0ac39c66024fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df5f0462ae9d328e4987971cda4c7ee"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a6df5f0462ae9d328e4987971cda4c7ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a6df5f0462ae9d328e4987971cda4c7ee">appendGroup</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group)</td></tr>
<tr class="memdesc:a6df5f0462ae9d328e4987971cda4c7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a new empty group to the VDB tree.  <a href="#a6df5f0462ae9d328e4987971cda4c7ee">More...</a><br /></td></tr>
<tr class="separator:a6df5f0462ae9d328e4987971cda4c7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2483abeddd3034b01b946caf10f84f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:aad2483abeddd3034b01b946caf10f84f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#aad2483abeddd3034b01b946caf10f84f">appendGroups</a> (PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;groups)</td></tr>
<tr class="memdesc:aad2483abeddd3034b01b946caf10f84f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends new empty groups to the VDB tree.  <a href="#aad2483abeddd3034b01b946caf10f84f">More...</a><br /></td></tr>
<tr class="separator:aad2483abeddd3034b01b946caf10f84f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f0afec32f566e10a0a25fde4466dba"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:ac1f0afec32f566e10a0a25fde4466dba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#ac1f0afec32f566e10a0a25fde4466dba">dropGroup</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const bool compact=true)</td></tr>
<tr class="memdesc:ac1f0afec32f566e10a0a25fde4466dba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops an existing group from the VDB tree.  <a href="#ac1f0afec32f566e10a0a25fde4466dba">More...</a><br /></td></tr>
<tr class="separator:ac1f0afec32f566e10a0a25fde4466dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c87fccd745143ae4e42c5b1f4998508"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a0c87fccd745143ae4e42c5b1f4998508"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a0c87fccd745143ae4e42c5b1f4998508">dropGroups</a> (PointDataTreeT &amp;tree, const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;groups)</td></tr>
<tr class="memdesc:a0c87fccd745143ae4e42c5b1f4998508"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops existing groups from the VDB tree, the tree is compacted after dropping.  <a href="#a0c87fccd745143ae4e42c5b1f4998508">More...</a><br /></td></tr>
<tr class="separator:a0c87fccd745143ae4e42c5b1f4998508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7814ccafca96a095c60c6c6438b7eb2"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:ad7814ccafca96a095c60c6c6438b7eb2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#ad7814ccafca96a095c60c6c6438b7eb2">dropGroups</a> (PointDataTreeT &amp;tree)</td></tr>
<tr class="memdesc:ad7814ccafca96a095c60c6c6438b7eb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops all existing groups from the VDB tree, the tree is compacted after dropping.  <a href="#ad7814ccafca96a095c60c6c6438b7eb2">More...</a><br /></td></tr>
<tr class="separator:ad7814ccafca96a095c60c6c6438b7eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6057529f97b428787a3e993ad12d3cf2"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a6057529f97b428787a3e993ad12d3cf2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a6057529f97b428787a3e993ad12d3cf2">compactGroups</a> (PointDataTreeT &amp;tree)</td></tr>
<tr class="memdesc:a6057529f97b428787a3e993ad12d3cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compacts existing groups of a VDB Tree to use less memory if possible.  <a href="#a6057529f97b428787a3e993ad12d3cf2">More...</a><br /></td></tr>
<tr class="separator:a6057529f97b428787a3e993ad12d3cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1866ee320dd051901bb7f4f49e155cee"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT , typename PointIndexTreeT &gt; </td></tr>
<tr class="memitem:a1866ee320dd051901bb7f4f49e155cee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a1866ee320dd051901bb7f4f49e155cee">setGroup</a> (PointDataTreeT &amp;tree, const PointIndexTreeT &amp;indexTree, const std::vector&lt; short &gt; &amp;membership, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const bool remove=false)</td></tr>
<tr class="memdesc:a1866ee320dd051901bb7f4f49e155cee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets group membership from a PointIndexTree-ordered vector.  <a href="#a1866ee320dd051901bb7f4f49e155cee">More...</a><br /></td></tr>
<tr class="separator:a1866ee320dd051901bb7f4f49e155cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522af44dcf8da3f9e6c7b747e075f155"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a522af44dcf8da3f9e6c7b747e075f155"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a522af44dcf8da3f9e6c7b747e075f155">setGroup</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const bool member=true)</td></tr>
<tr class="memdesc:a522af44dcf8da3f9e6c7b747e075f155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets membership for the specified group for all points (on/off).  <a href="#a522af44dcf8da3f9e6c7b747e075f155">More...</a><br /></td></tr>
<tr class="separator:a522af44dcf8da3f9e6c7b747e075f155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ce5ef333b529b92e4acb1bddeec93c"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT , typename FilterT &gt; </td></tr>
<tr class="memitem:ab5ce5ef333b529b92e4acb1bddeec93c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#ab5ce5ef333b529b92e4acb1bddeec93c">setGroupByFilter</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const FilterT &amp;filter)</td></tr>
<tr class="memdesc:ab5ce5ef333b529b92e4acb1bddeec93c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets group membership based on a provided filter.  <a href="#ab5ce5ef333b529b92e4acb1bddeec93c">More...</a><br /></td></tr>
<tr class="separator:ab5ce5ef333b529b92e4acb1bddeec93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062b9d6d7c3b63cea0c627f115b664cd"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a062b9d6d7c3b63cea0c627f115b664cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a062b9d6d7c3b63cea0c627f115b664cd">setGroupByRandomTarget</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> targetPoints, const unsigned int seed=0)</td></tr>
<tr class="separator:a062b9d6d7c3b63cea0c627f115b664cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754f74acc44ca144b4de729baa22ba9f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataTreeT &gt; </td></tr>
<tr class="memitem:a754f74acc44ca144b4de729baa22ba9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a754f74acc44ca144b4de729baa22ba9f">setGroupByRandomPercentage</a> (PointDataTreeT &amp;tree, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;group, const float percentage=10.0f, const unsigned int seed=0)</td></tr>
<tr class="separator:a754f74acc44ca144b4de729baa22ba9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0203fc05b3068cb3d0cb5b3140225254"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename MaskT  = typename PointDataGridT::template ValueConverter&lt;bool&gt;::Type, typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a0203fc05b3068cb3d0cb5b3140225254"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename MaskT::ValueType, bool &gt;::value, typename MaskT::Ptr &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a0203fc05b3068cb3d0cb5b3140225254">convertPointsToMask</a> (const PointDataGridT &amp;grid, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), bool threaded=true)</td></tr>
<tr class="memdesc:a0203fc05b3068cb3d0cb5b3140225254"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Mask <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> from a Point Data <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a>.  <a href="#a0203fc05b3068cb3d0cb5b3140225254">More...</a><br /></td></tr>
<tr class="separator:a0203fc05b3068cb3d0cb5b3140225254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfdf43efd3cbc67e8d781bd3d06fb85f"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename MaskT  = typename PointDataGridT::template ValueConverter&lt;bool&gt;::Type, typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:adfdf43efd3cbc67e8d781bd3d06fb85f"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_same&lt; typename MaskT::ValueType, bool &gt;::value, typename MaskT::Ptr &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#adfdf43efd3cbc67e8d781bd3d06fb85f">convertPointsToMask</a> (const PointDataGridT &amp;grid, const openvdb::math::Transform &amp;transform, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), bool threaded=true)</td></tr>
<tr class="memdesc:adfdf43efd3cbc67e8d781bd3d06fb85f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a Mask <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> from a Point Data <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> using a new transform.  <a href="#adfdf43efd3cbc67e8d781bd3d06fb85f">More...</a><br /></td></tr>
<tr class="separator:adfdf43efd3cbc67e8d781bd3d06fb85f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0082c20c402a864700014eae174838"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename DeformerT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:a2d0082c20c402a864700014eae174838"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a2d0082c20c402a864700014eae174838">movePoints</a> (PointDataGridT &amp;points, DeformerT &amp;deformer, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), <a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1future_1_1Advect.html">future::Advect</a> *objectNotInUse=nullptr, bool threaded=true)</td></tr>
<tr class="memdesc:a2d0082c20c402a864700014eae174838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move points in a PointDataGrid using a custom deformer.  <a href="#a2d0082c20c402a864700014eae174838">More...</a><br /></td></tr>
<tr class="separator:a2d0082c20c402a864700014eae174838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0d785b238fdbdf02b903fd9ddd453f3"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename DeformerT , typename FilterT  = NullFilter&gt; </td></tr>
<tr class="memitem:ad0d785b238fdbdf02b903fd9ddd453f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#ad0d785b238fdbdf02b903fd9ddd453f3">movePoints</a> (PointDataGridT &amp;points, const <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html">math::Transform</a> &amp;transform, DeformerT &amp;deformer, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), <a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1future_1_1Advect.html">future::Advect</a> *objectNotInUse=nullptr, bool threaded=true)</td></tr>
<tr class="memdesc:ad0d785b238fdbdf02b903fd9ddd453f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move points in a PointDataGrid using a custom deformer and a new transform.  <a href="#ad0d785b238fdbdf02b903fd9ddd453f3">More...</a><br /></td></tr>
<tr class="separator:ad0d785b238fdbdf02b903fd9ddd453f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b556e743b5d3b8b336c75252264d96"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename SourceGridT , typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ae7b556e743b5d3b8b336c75252264d96"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#ae7b556e743b5d3b8b336c75252264d96">pointSample</a> (PointDataGridT &amp;points, const SourceGridT &amp;sourceGrid, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;targetAttribute=&quot;&quot;, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *const interrupter=nullptr)</td></tr>
<tr class="memdesc:ae7b556e743b5d3b8b336c75252264d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs closest point sampling from a VDB grid onto a VDB Points attribute.  <a href="#ae7b556e743b5d3b8b336c75252264d96">More...</a><br /></td></tr>
<tr class="separator:ae7b556e743b5d3b8b336c75252264d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41bddc5c1099d146cee05b0dc3eb6ff"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename SourceGridT , typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:aa41bddc5c1099d146cee05b0dc3eb6ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#aa41bddc5c1099d146cee05b0dc3eb6ff">boxSample</a> (PointDataGridT &amp;points, const SourceGridT &amp;sourceGrid, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;targetAttribute=&quot;&quot;, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *const interrupter=nullptr)</td></tr>
<tr class="memdesc:aa41bddc5c1099d146cee05b0dc3eb6ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tri-linear sampling from a VDB grid onto a VDB Points attribute.  <a href="#aa41bddc5c1099d146cee05b0dc3eb6ff">More...</a><br /></td></tr>
<tr class="separator:aa41bddc5c1099d146cee05b0dc3eb6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad694b6c2cdbcd760f327fe3fb36ae936"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename SourceGridT , typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:ad694b6c2cdbcd760f327fe3fb36ae936"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#ad694b6c2cdbcd760f327fe3fb36ae936">quadraticSample</a> (PointDataGridT &amp;points, const SourceGridT &amp;sourceGrid, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;targetAttribute=&quot;&quot;, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), InterrupterT *const interrupter=nullptr)</td></tr>
<tr class="memdesc:ad694b6c2cdbcd760f327fe3fb36ae936"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs tri-quadratic sampling from a VDB grid onto a VDB Points attribute.  <a href="#ad694b6c2cdbcd760f327fe3fb36ae936">More...</a><br /></td></tr>
<tr class="separator:ad694b6c2cdbcd760f327fe3fb36ae936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ff8951f375ddac4b685e72f486489d3"><td class="memTemplParams" colspan="2">template&lt;typename PointDataGridT , typename SourceGridT , typename TargetValueT  = DummySampleType, typename SamplerT  = SampleWithRounding, typename FilterT  = NullFilter, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a5ff8951f375ddac4b685e72f486489d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a5ff8951f375ddac4b685e72f486489d3">sampleGrid</a> (size_t order, PointDataGridT &amp;points, const SourceGridT &amp;sourceGrid, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;targetAttribute, const FilterT &amp;filter=<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>(), const SamplerT &amp;sampler=<a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1SampleWithRounding.html">SampleWithRounding</a>(), InterrupterT *const interrupter=nullptr, const bool threaded=true)</td></tr>
<tr class="memdesc:a5ff8951f375ddac4b685e72f486489d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs sampling and conversion from a VDB grid onto a VDB Points attribute.  <a href="#a5ff8951f375ddac4b685e72f486489d3">More...</a><br /></td></tr>
<tr class="separator:a5ff8951f375ddac4b685e72f486489d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc4c70eaf37048c67356fd7189b15d95"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename RandGenT  = std::mt19937, typename PositionArrayT  = TypedAttributeArray&lt;Vec3f, NullCodec&gt;, typename PointDataGridT  = Grid&lt;        typename points::TreeConverter&lt;typename GridT::TreeType&gt;::Type&gt;, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:abc4c70eaf37048c67356fd7189b15d95"><td class="memTemplItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#abc4c70eaf37048c67356fd7189b15d95">uniformPointScatter</a> (const GridT &amp;grid, const <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> count, const unsigned int seed=0, const float spread=1.0f, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:abc4c70eaf37048c67356fd7189b15d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">The free functions depend on the following class:  <a href="#abc4c70eaf37048c67356fd7189b15d95">More...</a><br /></td></tr>
<tr class="separator:abc4c70eaf37048c67356fd7189b15d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a35fc7cff4396e3c0fed48af7150c30"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename RandGenT  = std::mt19937, typename PositionArrayT  = TypedAttributeArray&lt;Vec3f, NullCodec&gt;, typename PointDataGridT  = Grid&lt;        typename points::TreeConverter&lt;typename GridT::TreeType&gt;::Type&gt;, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:a2a35fc7cff4396e3c0fed48af7150c30"><td class="memTemplItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a2a35fc7cff4396e3c0fed48af7150c30">denseUniformPointScatter</a> (const GridT &amp;grid, const float pointsPerVoxel, const unsigned int seed=0, const float spread=1.0f, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:a2a35fc7cff4396e3c0fed48af7150c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uniformly scatter a fixed number of points per active voxel. If the pointsPerVoxel value provided is a fractional value, each voxel calculates a delta value of how likely it is to contain an extra point.  <a href="#a2a35fc7cff4396e3c0fed48af7150c30">More...</a><br /></td></tr>
<tr class="separator:a2a35fc7cff4396e3c0fed48af7150c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea55ad121ac7274e8a5bb844253c695d"><td class="memTemplParams" colspan="2">template&lt;typename GridT , typename RandGenT  = std::mt19937, typename PositionArrayT  = TypedAttributeArray&lt;Vec3f, NullCodec&gt;, typename PointDataGridT  = Grid&lt;        typename points::TreeConverter&lt;typename GridT::TreeType&gt;::Type&gt;, typename InterrupterT  = util::NullInterrupter&gt; </td></tr>
<tr class="memitem:aea55ad121ac7274e8a5bb844253c695d"><td class="memTemplItemLeft" align="right" valign="top">PointDataGridT::Ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#aea55ad121ac7274e8a5bb844253c695d">nonUniformPointScatter</a> (const GridT &amp;grid, const float pointsPerVoxel, const unsigned int seed=0, const float spread=1.0f, InterrupterT *interrupter=nullptr)</td></tr>
<tr class="memdesc:aea55ad121ac7274e8a5bb844253c695d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Non uniformly scatter points per active voxel. The pointsPerVoxel value is used to weight each grids cell value to compute a fixed number of points for every active voxel. If the computed result is a fractional value, each voxel calculates a delta value of how likely it is to contain an extra point.  <a href="#aea55ad121ac7274e8a5bb844253c695d">More...</a><br /></td></tr>
<tr class="separator:aea55ad121ac7274e8a5bb844253c695d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a8954944cf980f1f874a6510497568338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a8954944cf980f1f874a6510497568338">ActiveFilter</a> =  <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9bc95058fb208e9baa08dab77d98c5fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a9bc95058fb208e9baa08dab77d98c5fa">GroupAttributeArray</a> =  <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a>&lt;<a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a714bfd681b0e82019a95174ecdb6a889">GroupType</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1GroupCodec.html">GroupCodec</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a714bfd681b0e82019a95174ecdb6a889"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a714bfd681b0e82019a95174ecdb6a889">GroupType</a> =  uint8_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8273cc7bb48dded419013b35a6491bc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a8273cc7bb48dded419013b35a6491bc0">InactiveFilter</a> =  <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1ValueMaskFilter.html">ValueMaskFilter</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf438a63a8a41ec38b6d7ceae6467678"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#acf438a63a8a41ec38b6d7ceae6467678">PointDataGrid</a> =  <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html">Grid</a>&lt;<a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a7fec47b2a3d864d85c53f69c3655fdbf">PointDataTree</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point data grid. </p>

</div>
</div>
<a class="anchor" id="a7fec47b2a3d864d85c53f69c3655fdbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#a7fec47b2a3d864d85c53f69c3655fdbf">PointDataTree</a> =  <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html">tree::Tree</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">tree::RootNode</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">tree::InternalNode</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">tree::InternalNode</a> &lt;<a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1PointDataLeafNode.html">PointDataLeafNode</a>&lt;<a class="el" href="namespaceopenvdb_1_1v8__1.html#afcdd46e3c391ea8febd5fa6017b9f19b">PointDataIndex32</a>, 3&gt;, 4&gt;, 5&gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Point index tree configured to match the default VDB configurations. </p>

</div>
</div>
<a class="anchor" id="af44fac5036c56999ca811116b73eca72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespaceopenvdb_1_1v8__1_1_1points.html#af44fac5036c56999ca811116b73eca72">StringAttributeArray</a> =  <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1TypedAttributeArray.html">TypedAttributeArray</a>&lt;<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1StringCodec.html">StringCodec</a>&lt;false&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab79ffb24dc5aee12a75d1507966164bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void advectPoints </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const VelGridT &amp;&#160;</td>
          <td class="paramname"><em>velocity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>integrationOrder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>dt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>timeSteps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AdvectFilterT &amp;&#160;</td>
          <td class="paramname"><em>advectFilter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>cached</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Advect points in a PointDataGrid through a velocity grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the PointDataGrid containing the points to be advected. </td></tr>
    <tr><td class="paramname">velocity</td><td>a velocity grid to be sampled. </td></tr>
    <tr><td class="paramname">integrationOrder</td><td>the integration scheme to use (1 is forward euler, 4 is runge-kutta 4th) </td></tr>
    <tr><td class="paramname">dt</td><td>delta time. </td></tr>
    <tr><td class="paramname">timeSteps</td><td>number of advection steps to perform. </td></tr>
    <tr><td class="paramname">advectFilter</td><td>an optional advection index filter (moves a subset of the points) </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter (deletes a subset of the points) </td></tr>
    <tr><td class="paramname">cached</td><td>caches velocity interpolation for faster performance, disable to use less memory (default is on). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9f8216e14812f6a9c9aaf1af5b2ad36b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void appendAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a3907786c2430dbab9f198bfd5b31ff7c">NamePair</a> &amp;&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>strideOrTotalSize</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constantStride</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1Metadata.html">Metadata</a> *&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hidden</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new attribute to the VDB tree (this method does not require a templated AttributeType) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be appended to. </td></tr>
    <tr><td class="paramname">name</td><td>name for the new attribute. </td></tr>
    <tr><td class="paramname">type</td><td>the type of the attibute. </td></tr>
    <tr><td class="paramname">strideOrTotalSize</td><td>the stride of the attribute </td></tr>
    <tr><td class="paramname">constantStride</td><td>if <code>false</code>, stride is interpreted as total size of the array </td></tr>
    <tr><td class="paramname">defaultValue</td><td>metadata default attribute value </td></tr>
    <tr><td class="paramname">hidden</td><td>mark attribute as hidden </td></tr>
    <tr><td class="paramname">transient</td><td>mark attribute as transient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a12af91f538ab5256ce2db4afe3b9dd31"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void appendAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>uniformValue</em> = <code><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1point__attribute__internal_1_1Default.html">point_attribute_internal::Default</a>&lt;ValueType&gt;::value()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>strideOrTotalSize</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>constantStride</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html">TypedMetadata</a>&lt; ValueType &gt; *&#160;</td>
          <td class="paramname"><em>defaultValue</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>hidden</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>transient</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new attribute to the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be appended to. </td></tr>
    <tr><td class="paramname">name</td><td>name for the new attribute </td></tr>
    <tr><td class="paramname">uniformValue</td><td>the initial value of the attribute </td></tr>
    <tr><td class="paramname">strideOrTotalSize</td><td>the stride of the attribute </td></tr>
    <tr><td class="paramname">constantStride</td><td>if <code>false</code>, stride is interpreted as total size of the array </td></tr>
    <tr><td class="paramname">defaultValue</td><td>metadata default attribute value </td></tr>
    <tr><td class="paramname">hidden</td><td>mark attribute as hidden </td></tr>
    <tr><td class="paramname">transient</td><td>mark attribute as transient </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6df5f0462ae9d328e4987971cda4c7ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void appendGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends a new empty group to the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be appended to. </td></tr>
    <tr><td class="paramname">group</td><td>name of the new group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aad2483abeddd3034b01b946caf10f84f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void appendGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Appends new empty groups to the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be appended to. </td></tr>
    <tr><td class="paramname">groups</td><td>names of the new groups. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa41bddc5c1099d146cee05b0dc3eb6ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void boxSample </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceGridT &amp;&#160;</td>
          <td class="paramname"><em>sourceGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>targetAttribute</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs tri-linear sampling from a VDB grid onto a VDB Points attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the PointDataGrid whose points will be sampled on to </td></tr>
    <tr><td class="paramname">sourceGrid</td><td>VDB grid which will be sampled </td></tr>
    <tr><td class="paramname">targetAttribute</td><td>a target attribute on the points which will hold samples. This attribute will be created with the source grid type if it does not exist, and with the source grid name if the name is empty </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The target attribute may exist provided it can be cast to the SourceGridT ValueType </dd></dl>

</div>
</div>
<a class="anchor" id="a6b46b75155cc394f4ad4b540f167523a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void collapseAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ValueType &amp;&#160;</td>
          <td class="paramname"><em>uniformValue</em> = <code><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1point__attribute__internal_1_1Default.html">point_attribute_internal::Default</a>&lt;ValueType&gt;::value()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Collapse the attribute into a uniform value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree in which to collapse the attribute. </td></tr>
    <tr><td class="paramname">name</td><td>name for the attribute. </td></tr>
    <tr><td class="paramname">uniformValue</td><td>value of the attribute </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a467b8eefb87ca02fa0f017c40c08d674"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compactAttributes </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compact attributes in a VDB tree (if possible). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6057529f97b428787a3e993ad12d3cf2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void compactGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compacts existing groups of a VDB Tree to use less memory if possible. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be compacted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab9ec3ffe5c7a9e7745c3a55de49ea125"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float computeVoxelSize </td>
          <td>(</td>
          <td class="paramtype">const PositionWrapper &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>pointsPerVoxel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">math::Mat4d</a>&#160;</td>
          <td class="paramname"><em>transform</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Mat4.html#a71890348d53084982694f39988f4b286">math::Mat4d::identity</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>decimalPlaces</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>@ brief Given a container of world space positions and a target points per voxel, compute a uniform voxel size that would best represent the storage of the points in a grid. This voxel size is typically used for conversion of the points into a PointDataGrid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positions</td><td>array of world space positions </td></tr>
    <tr><td class="paramname">pointsPerVoxel</td><td>the target number of points per voxel, must be positive and non-zero </td></tr>
    <tr><td class="paramname">transform</td><td>voxel size will be computed using this optional transform if provided </td></tr>
    <tr><td class="paramname">decimalPlaces</td><td>for readability, truncate voxel size to this number of decimals </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>if none or one point provided in positions, the default voxel size of 0.1 will be returned </dd></dl>

</div>
</div>
<a class="anchor" id="ac91e520838e75f17a4e0a3505c128931"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void convertPointDataGridAttribute </td>
          <td>(</td>
          <td class="paramtype">TypedAttribute &amp;&#160;</td>
          <td class="paramname"><em>attribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td>
          <td class="paramname"><em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>arrayIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>stride</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>inCoreOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the attribute from a PointDataGrid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">attribute</td><td>the attribute to be populated. </td></tr>
    <tr><td class="paramname">tree</td><td>the PointDataTree to be converted. </td></tr>
    <tr><td class="paramname">pointOffsets</td><td>a vector of cumulative point offsets for each leaf. </td></tr>
    <tr><td class="paramname">startOffset</td><td>a value to shift all the point offsets by </td></tr>
    <tr><td class="paramname">arrayIndex</td><td>the index in the Descriptor of the array to be converted. </td></tr>
    <tr><td class="paramname">stride</td><td>the stride of the attribute </td></tr>
    <tr><td class="paramname">filter</td><td>an index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>true if out-of-core leaf nodes are to be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4875034852344d7f676c955bb764d9c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void convertPointDataGridGroup </td>
          <td>(</td>
          <td class="paramtype">Group &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td>
          <td class="paramname"><em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AttributeSet::Descriptor::GroupIndex&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>inCoreOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the group from a PointDataGrid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>the group to be populated. </td></tr>
    <tr><td class="paramname">tree</td><td>the PointDataTree to be converted. </td></tr>
    <tr><td class="paramname">pointOffsets</td><td>a vector of cumulative point offsets for each leaf </td></tr>
    <tr><td class="paramname">startOffset</td><td>a value to shift all the point offsets by </td></tr>
    <tr><td class="paramname">index</td><td>the group index to be converted. </td></tr>
    <tr><td class="paramname">filter</td><td>an index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>true if out-of-core leaf nodes are to be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acf905ca86b725954bf900e3caf6b431a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void convertPointDataGridPosition </td>
          <td>(</td>
          <td class="paramtype">PositionAttribute &amp;&#160;</td>
          <td class="paramname"><em>positionAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td>
          <td class="paramname"><em>startOffset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>inCoreOnly</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert the position attribute from a Point Data <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positionAttribute</td><td>the position attribute to be populated. </td></tr>
    <tr><td class="paramname">grid</td><td>the PointDataGrid to be converted. </td></tr>
    <tr><td class="paramname">pointOffsets</td><td>a vector of cumulative point offsets for each leaf </td></tr>
    <tr><td class="paramname">startOffset</td><td>a value to shift all the point offsets by </td></tr>
    <tr><td class="paramname">filter</td><td>an index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>true if out-of-core leaf nodes are to be ignored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0203fc05b3068cb3d0cb5b3140225254"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; typename MaskT::ValueType, bool &gt;::value, typename MaskT::Ptr &gt;::type convertPointsToMask </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a Mask <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> from a Point Data <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the PointDataGrid to extract the mask from. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method is only available for Bool Grids and Mask Grids </dd></dl>

</div>
</div>
<a class="anchor" id="adfdf43efd3cbc67e8d781bd3d06fb85f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_same&lt; typename MaskT::ValueType, bool &gt;::value, typename MaskT::Ptr &gt;::type convertPointsToMask </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract a Mask <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> from a Point Data <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html" title="Container class that associates a tree with a transform and metadata. ">Grid</a> using a new transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the PointDataGrid to extract the mask from. </td></tr>
    <tr><td class="paramname">transform</td><td>target transform for the mask. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>this method is only available for Bool Grids and Mask Grids </dd></dl>

</div>
</div>
<a class="anchor" id="ab15a1ee82d506999536458071ba44299"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr createPointDataGrid </td>
          <td>(</td>
          <td class="paramtype">const PointIndexGridT &amp;&#160;</td>
          <td class="paramname"><em>pointIndexGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PositionArrayT &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1Metadata.html">Metadata</a> *&#160;</td>
          <td class="paramname"><em>positionDefaultValue</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Localises points with position into a <code>PointDataGrid</code> into two stages: allocation of the leaf attribute data and population of the positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointIndexGrid</td><td>a PointIndexGrid into the points. </td></tr>
    <tr><td class="paramname">positions</td><td>list of world space point positions. </td></tr>
    <tr><td class="paramname">xform</td><td>world to index space transform. </td></tr>
    <tr><td class="paramname">positionDefaultValue</td><td>metadata default position value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The position data must be supplied in a Point-Partitioner compatible data structure. A convenience <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1PointAttributeVector.html" title="Point-partitioner compatible STL vector attribute wrapper for convenience. ">PointAttributeVector</a> class is offered.</dd>
<dd>
The position data is populated separately to perform world space to voxel space conversion and apply quantisation.</dd>
<dd>
A <code>PointIndexGrid</code> to the points must be supplied to perform this operation. Typically this is built implicitly by the PointDataGrid constructor. </dd></dl>

</div>
</div>
<a class="anchor" id="a07c2da02df6fb329b2684f56617c39b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr createPointDataGrid </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>xform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1Metadata.html">Metadata</a> *&#160;</td>
          <td class="paramname"><em>positionDefaultValue</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenience method to create a <code>PointDataGrid</code> from a std::vector of point positions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">positions</td><td>list of world space point positions. </td></tr>
    <tr><td class="paramname">xform</td><td>world to index space transform. </td></tr>
    <tr><td class="paramname">positionDefaultValue</td><td>metadata default position value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method implicitly wraps the std::vector for a Point-Partitioner compatible data structure and creates the required <code>PointIndexGrid</code> to the points. </dd></dl>

</div>
</div>
<a class="anchor" id="afdbd30a3741affcd2b2434124a34149d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deleteFromGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>pointTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drop</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete points that are members of a group. </p>
<p>This method will delete points which are members of the supplied group and will optionally drop the group from the tree. An invert flag can be used to delete points that belong to none of the groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointTree</td><td>the point tree with the group to delete </td></tr>
    <tr><td class="paramname">group</td><td>the name of the group to delete </td></tr>
    <tr><td class="paramname">invert</td><td>if enabled, points not belonging to any of the groups will be deleted </td></tr>
    <tr><td class="paramname">drop</td><td>if enabled and invert is disabled, the group will be dropped from the tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the invert flag is true, the group will not be dropped after deleting points regardless of the value of the drop parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b9d921b422e929c3786e77c8d4c811f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deleteFromGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>pointTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>drop</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete points that are members of specific groups. </p>
<p>This method will delete points which are members of any of the supplied groups and will optionally drop the groups from the tree. An invert flag can be used to delete points that belong to none of the groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointTree</td><td>the point tree </td></tr>
    <tr><td class="paramname">groups</td><td>the groups from which to delete points </td></tr>
    <tr><td class="paramname">invert</td><td>if enabled, points not belonging to any of the groups will be deleted </td></tr>
    <tr><td class="paramname">drop</td><td>if enabled and invert is disabled, the groups will be dropped from the tree</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the invert flag is true, none of the groups will be dropped after deleting points regardless of the value of the drop parameter. </dd></dl>

</div>
</div>
<a class="anchor" id="a5e318d6bae7846125e0ac39c66024fc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deleteMissingPointGroups </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeSet.html#abf4c4c63e6ef3b54e88cd0cab0be66c8">AttributeSet::Descriptor</a> &amp;&#160;</td>
          <td class="paramname"><em>descriptor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete any group that is not present in the Descriptor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">groups</td><td>the vector of group names. </td></tr>
    <tr><td class="paramname">descriptor</td><td>the descriptor that holds the group map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2a35fc7cff4396e3c0fed48af7150c30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr denseUniformPointScatter </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>pointsPerVoxel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>spread</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uniformly scatter a fixed number of points per active voxel. If the pointsPerVoxel value provided is a fractional value, each voxel calculates a delta value of how likely it is to contain an extra point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>A source grid. The resulting PointDataGrid will copy this grids transform and scatter in its active voxelized topology. </td></tr>
    <tr><td class="paramname">pointsPerVoxel</td><td>The number of points to scatter per voxel </td></tr>
    <tr><td class="paramname">seed</td><td>A seed for the RandGenT </td></tr>
    <tr><td class="paramname">spread</td><td>The spread of points as a scale from each voxels center. A value of 1.0f indicates points can be placed anywhere within the voxel, where as a value of 0.0f will force all points to be created exactly at the centers of each voxel. </td></tr>
    <tr><td class="paramname">interrupter</td><td>An optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns the scattered PointDataGrid </dd></dl>

</div>
</div>
<a class="anchor" id="a630071eb13957e9c9683fafb845ec9ce"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop one attribute from the VDB tree (convenience method). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
    <tr><td class="paramname">index</td><td>index of the attribute to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acd25e23091c52fb8da4fcb50369ad45b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drop one attribute from the VDB tree (convenience method). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
    <tr><td class="paramname">name</td><td>name of the attribute to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaaa22577ec29a353a700c9a3fa03906f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropAttributes </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops attributes from the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
    <tr><td class="paramname">indices</td><td>indices of the attributes to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaa8ee0b505384ce90253b77516cedce4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropAttributes </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops attributes from the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
    <tr><td class="paramname">names</td><td>names of the attributes to drop. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1f0afec32f566e10a0a25fde4466dba"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>compact</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops an existing group from the VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
    <tr><td class="paramname">group</td><td>name of the group. </td></tr>
    <tr><td class="paramname">compact</td><td>compact attributes if possible to reduce memory - if dropping more than one group, compacting once at the end will be faster </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0c87fccd745143ae4e42c5b1f4998508"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>groups</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops existing groups from the VDB tree, the tree is compacted after dropping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
    <tr><td class="paramname">groups</td><td>names of the groups. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad7814ccafca96a095c60c6c6438b7eb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dropGroups </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Drops all existing groups from the VDB tree, the tree is compacted after dropping. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree to be dropped from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4189b7d55ec4e7ccc6445e205174a979"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatT openvdb::v8_1::points::fixedPointToFloatingPoint </td>
          <td>(</td>
          <td class="paramtype">const IntegerT&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab860367c1015286c5e8c695dc88f099e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FloatVectorT openvdb::v8_1::points::fixedPointToFloatingPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">math::Vec3</a>&lt; IntegerT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a080e28eb43adab30c573deecea1f1f51"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerT openvdb::v8_1::points::floatingPointToFixedPoint </td>
          <td>(</td>
          <td class="paramtype">const FloatT&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1fec300721a981a1fcff3e765d86c10d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IntegerVectorT openvdb::v8_1::points::floatingPointToFixedPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">math::Vec3</a>&lt; FloatT &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1386ebd3d0e91d83094afc4b4cb89ff4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openvdb::v8_1::points::isGroup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeArray.html">AttributeArray</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a0eeaeec10ea9846c72f9dcd9764c80"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool openvdb::v8_1::points::isString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeArray.html">AttributeArray</a> &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adfb5e64392fdf29bc3462e5a60713158"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> iterCount </td>
          <td>(</td>
          <td class="paramtype">const IterT &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count up the number of times the iterator can iterate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">iter</td><td>the iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>counting by iteration only performed where a dynamic filter is in use, </dd></dl>

</div>
</div>
<a class="anchor" id="af351ce8e812595d5fede2fd73ce96420"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AttributeSet::Descriptor::Ptr makeDescriptorUnique </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy the descriptor across all leaf nodes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new descriptor.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method will fail if the Descriptors in the tree are not all identical. </dd></dl>

</div>
</div>
<a class="anchor" id="a2d0082c20c402a864700014eae174838"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void movePoints </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeformerT &amp;&#160;</td>
          <td class="paramname"><em>deformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1future_1_1Advect.html">future::Advect</a> *&#160;</td>
          <td class="paramname"><em>objectNotInUse</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move points in a PointDataGrid using a custom deformer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the PointDataGrid containing the points to be moved. </td></tr>
    <tr><td class="paramname">deformer</td><td>a custom deformer that defines how to move the points. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">objectNotInUse</td><td>for future use, this object is currently ignored </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad0d785b238fdbdf02b903fd9ddd453f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void movePoints </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html">math::Transform</a> &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DeformerT &amp;&#160;</td>
          <td class="paramname"><em>deformer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1future_1_1Advect.html">future::Advect</a> *&#160;</td>
          <td class="paramname"><em>objectNotInUse</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move points in a PointDataGrid using a custom deformer and a new transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the PointDataGrid containing the points to be moved. </td></tr>
    <tr><td class="paramname">transform</td><td>target transform to use for the resulting points. </td></tr>
    <tr><td class="paramname">deformer</td><td>a custom deformer that defines how to move the points. </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">objectNotInUse</td><td>for future use, this object is currently ignored </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea55ad121ac7274e8a5bb844253c695d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr nonUniformPointScatter </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>pointsPerVoxel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>spread</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Non uniformly scatter points per active voxel. The pointsPerVoxel value is used to weight each grids cell value to compute a fixed number of points for every active voxel. If the computed result is a fractional value, each voxel calculates a delta value of how likely it is to contain an extra point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>A source grid. The resulting PointDataGrid will copy this grids transform, voxelized topology and use its values to compute a target points per voxel. The grids ValueType must be convertible to a scalar value. Only active and larger than zero values will contain points. </td></tr>
    <tr><td class="paramname">pointsPerVoxel</td><td>The number of points to scatter per voxel </td></tr>
    <tr><td class="paramname">seed</td><td>A seed for the RandGenT </td></tr>
    <tr><td class="paramname">spread</td><td>The spread of points as a scale from each voxels center. A value of 1.0f indicates points can be placed anywhere within the voxel, where as a value of 0.0f will force all points to be created exactly at the centers of each voxel. </td></tr>
    <tr><td class="paramname">interrupter</td><td>An optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns the scattered PointDataGrid </dd></dl>

</div>
</div>
<a class="anchor" id="a8dbfd50108bbe665a6e1a0607335a5df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> pointCount </td>
          <td>(</td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>inCoreOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Count the total number of points in a PointDataTree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree in which to count the points </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>if true, points in out-of-core leaf nodes are not counted </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a90464075cf4382ab74a75288eebfce02"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr pointCountGrid </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a new grid with voxel values to store the number of points per voxel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the PointDataGrid to use to compute the count grid </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The return type of the grid must be an integer or floating-point scalar grid. </dd></dl>

</div>
</div>
<a class="anchor" id="a2159bcf1fea38531ec493459f3b37857"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">GridT::Ptr pointCountGrid </td>
          <td>(</td>
          <td class="paramtype">const PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const openvdb::math::Transform &amp;&#160;</td>
          <td class="paramname"><em>transform</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generate a new grid that uses the supplied transform with voxel values to store the number of points per voxel. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>the PointDataGrid to use to compute the count grid </td></tr>
    <tr><td class="paramname">transform</td><td>the transform to use to compute the count grid </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The return type of the grid must be an integer or floating-point scalar grid. </dd></dl>

</div>
</div>
<a class="anchor" id="a639be5922b4acf36c519e88f9ea8ff7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> pointOffsets </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>pointOffsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>inCoreOnly</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populate an array of cumulative point offsets per leaf node. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointOffsets</td><td>array of offsets to be populated </td></tr>
    <tr><td class="paramname">tree</td><td>the PointDataTree from which to populate the offsets </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">inCoreOnly</td><td>if true, points in out-of-core leaf nodes are ignored </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The final cumulative point offset. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7b556e743b5d3b8b336c75252264d96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pointSample </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceGridT &amp;&#160;</td>
          <td class="paramname"><em>sourceGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>targetAttribute</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs closest point sampling from a VDB grid onto a VDB Points attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the PointDataGrid whose points will be sampled on to </td></tr>
    <tr><td class="paramname">sourceGrid</td><td>VDB grid which will be sampled </td></tr>
    <tr><td class="paramname">targetAttribute</td><td>a target attribute on the points which will hold samples. This attribute will be created with the source grid type if it does not exist, and with the source grid name if the name is empty </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The target attribute may exist provided it can be cast to the SourceGridT ValueType </dd></dl>

</div>
</div>
<a class="anchor" id="ad7557b731e5392e4448f933a84139950"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void populateAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointIndexTreeT &amp;&#160;</td>
          <td class="paramname"><em>pointIndexTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">openvdb::Name</a> &amp;&#160;</td>
          <td class="paramname"><em>attributeName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointArrayT &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>stride</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>insertMetadata</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stores point attribute data in an existing <code>PointDataGrid</code> attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataGrid to be populated. </td></tr>
    <tr><td class="paramname">pointIndexTree</td><td>a PointIndexTree into the points. </td></tr>
    <tr><td class="paramname">attributeName</td><td>the name of the VDB Points attribute to be populated. </td></tr>
    <tr><td class="paramname">data</td><td>a wrapper to the attribute data. </td></tr>
    <tr><td class="paramname">stride</td><td>the stride of the attribute </td></tr>
    <tr><td class="paramname">insertMetadata</td><td>true if strings are to be automatically inserted as metadata.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>A <code>PointIndexGrid</code> to the points must be supplied to perform this operation. This is required to ensure the same point index ordering. </dd></dl>

</div>
</div>
<a class="anchor" id="a2205d8c5a7c5fd2e24145a9df5ad6485"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prefetch </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>position</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>otherAttributes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sequentially pre-fetch all delayed-load voxel and attribute data from disk in order to accelerate subsequent random access. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">position</td><td>if enabled, prefetch the position attribute (default is on) </td></tr>
    <tr><td class="paramname">otherAttributes</td><td>if enabled, prefetch all other attributes (default is on) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad694b6c2cdbcd760f327fe3fb36ae936"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void quadraticSample </td>
          <td>(</td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceGridT &amp;&#160;</td>
          <td class="paramname"><em>sourceGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>targetAttribute</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs tri-quadratic sampling from a VDB grid onto a VDB Points attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>the PointDataGrid whose points will be sampled on to </td></tr>
    <tr><td class="paramname">sourceGrid</td><td>VDB grid which will be sampled </td></tr>
    <tr><td class="paramname">targetAttribute</td><td>a target attribute on the points which will hold samples. This attribute will be created with the source grid type if it does not exist, and with the source grid name if the name is empty </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The target attribute may exist provided it can be cast to the SourceGridT ValueType </dd></dl>

</div>
</div>
<a class="anchor" id="aeb60e92fdbb25ad5822945cc30b3e8b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void renameAttribute </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>oldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename an attribute in a VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">oldName</td><td>the old attribute name to rename from. </td></tr>
    <tr><td class="paramname">newName</td><td>the new attribute name to rename to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>newName must not already exist and must not be a group attribute. </dd></dl>

</div>
</div>
<a class="anchor" id="aceb82e6282deeaa12012efbe386ce564"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void renameAttributes </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>oldNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>newNames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rename attributes in a VDB tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">oldNames</td><td>a list of old attribute names to rename from. </td></tr>
    <tr><td class="paramname">newNames</td><td>a list of new attribute names to rename to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Number of oldNames must match the number of newNames.</dd>
<dd>
Duplicate names and renaming group attributes are not allowed. </dd></dl>

</div>
</div>
<a class="anchor" id="a5ff8951f375ddac4b685e72f486489d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sampleGrid </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PointDataGridT &amp;&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SourceGridT &amp;&#160;</td>
          <td class="paramname"><em>sourceGrid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>targetAttribute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em> = <code><a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1NullFilter.html">NullFilter</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SamplerT &amp;&#160;</td>
          <td class="paramname"><em>sampler</em> = <code><a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1SampleWithRounding.html">SampleWithRounding</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *const&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Performs sampling and conversion from a VDB grid onto a VDB Points attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>the sampling order - 0 = closest-point, 1 = trilinear, 2 = triquadratic </td></tr>
    <tr><td class="paramname">points</td><td>the PointDataGrid whose points will be sampled on to </td></tr>
    <tr><td class="paramname">sourceGrid</td><td>VDB grid which will be sampled </td></tr>
    <tr><td class="paramname">targetAttribute</td><td>a target attribute on the points which will hold samples. This attribute will be created with the source grid type if it does not exist, and with the source grid name if the name is empty </td></tr>
    <tr><td class="paramname">filter</td><td>an optional index filter </td></tr>
    <tr><td class="paramname">sampler</td><td>handles sampling and conversion into the target attribute type, which by default this uses the <a class="el" href="structopenvdb_1_1v8__1_1_1points_1_1SampleWithRounding.html">SampleWithRounding</a> struct. </td></tr>
    <tr><td class="paramname">interrupter</td><td>an optional interrupter </td></tr>
    <tr><td class="paramname">threaded</td><td>enable or disable threading (threading is enabled by default) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The target attribute may exist provided it can be cast to the SourceGridT ValueType </dd></dl>

</div>
</div>
<a class="anchor" id="a1866ee320dd051901bb7f4f49e155cee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PointIndexTreeT &amp;&#160;</td>
          <td class="paramname"><em>indexTree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; short &gt; &amp;&#160;</td>
          <td class="paramname"><em>membership</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>remove</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets group membership from a PointIndexTree-ordered vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">indexTree</td><td>the PointIndexTree. </td></tr>
    <tr><td class="paramname">membership</td><td><code>1</code> if the point is in the group, 0 otherwise. </td></tr>
    <tr><td class="paramname">group</td><td>the name of the group. </td></tr>
    <tr><td class="paramname">remove</td><td>if <code>true</code> also perform removal of points from the group.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>vector&lt;bool&gt; is not thread-safe on concurrent write, so use vector&lt;short&gt; instead </dd></dl>

</div>
</div>
<a class="anchor" id="a522af44dcf8da3f9e6c7b747e075f155"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGroup </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>member</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets membership for the specified group for all points (on/off). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">group</td><td>the name of the group. </td></tr>
    <tr><td class="paramname">member</td><td>true / false for membership of the group. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab5ce5ef333b529b92e4acb1bddeec93c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setGroupByFilter </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FilterT &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets group membership based on a provided filter. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">group</td><td>the name of the group. </td></tr>
    <tr><td class="paramname">filter</td><td>filter data that is used to create a per-leaf filter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a754f74acc44ca144b4de729baa22ba9f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_1::points::setGroupByRandomPercentage </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>percentage</em> = <code>10.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a062b9d6d7c3b63cea0c627f115b664cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_1::points::setGroupByRandomTarget </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a019c188253c90cf2d0b1d6bf710190f4">Name</a> &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td>
          <td class="paramname"><em>targetPoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0d85a4b1b93c26f69ecf71e75017275b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setStreamingMode </td>
          <td>(</td>
          <td class="paramtype">PointDataTreeT &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Toggle the streaming mode on all attributes in the tree to collapse the attributes after deconstructing a bound <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeHandle.html">AttributeHandle</a> to each array. This results in better memory efficiency when the data is streamed into another data structure (typically for rendering). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>the PointDataTree. </td></tr>
    <tr><td class="paramname">on</td><td><code>true</code> to enable streaming</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Multiple threads cannot safely access the same <a class="el" href="classopenvdb_1_1v8__1_1_1points_1_1AttributeArray.html" title="Base class for storing attribute data. ">AttributeArray</a> when using streaming. </dd></dl>

</div>
</div>
<a class="anchor" id="abc4c70eaf37048c67356fd7189b15d95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PointDataGridT::Ptr uniformPointScatter </td>
          <td>(</td>
          <td class="paramtype">const GridT &amp;&#160;</td>
          <td class="paramname"><em>grid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const float&#160;</td>
          <td class="paramname"><em>spread</em> = <code>1.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InterrupterT *&#160;</td>
          <td class="paramname"><em>interrupter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The free functions depend on the following class: </p>
<p>The <code>InterrupterT</code> template argument below refers to any class with the following interface: </p><div class="fragment"><div class="line"> <span class="keyword">class </span>Interrupter {</div><div class="line">   ...</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">   <span class="keywordtype">void</span> start(<span class="keyword">const</span> <span class="keywordtype">char</span>* name = <span class="keyword">nullptr</span>) <span class="comment">// called when computations begin</span></div><div class="line">   void end()                             <span class="comment">// called when computations end</span></div><div class="line">   <span class="keywordtype">bool</span> <a class="code" href="namespaceopenvdb_1_1v8__1_1_1util.html#a7c8f20077ad9b7090a5544984138a61a">wasInterrupted</a>(<span class="keywordtype">int</span> percent=-1)    <span class="comment">// return true to break computation</span></div><div class="line">};</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>If no template argument is provided for this InterrupterT the <a class="el" href="structopenvdb_1_1v8__1_1_1util_1_1NullInterrupter.html" title="Dummy NOOP interrupter class defining interface. ">util::NullInterrupter</a> is used which implies that all interrupter calls are no-ops (i.e. incurs no computational overhead). Uniformly scatter a total amount of points in active regions</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>A source grid. The resulting PointDataGrid will copy this grids transform and scatter in its active voxelized topology. </td></tr>
    <tr><td class="paramname">count</td><td>The total number of points to scatter </td></tr>
    <tr><td class="paramname">seed</td><td>A seed for the RandGenT </td></tr>
    <tr><td class="paramname">spread</td><td>The spread of points as a scale from each voxels center. A value of 1.0f indicates points can be placed anywhere within the voxel, where as a value of 0.0f will force all points to be created exactly at the centers of each voxel. </td></tr>
    <tr><td class="paramname">interrupter</td><td>An optional interrupter </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>returns the scattered PointDataGrid </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
