import typing
from typing import Any, ClassVar, List, Tuple, overload

import numpy as np
import torch

Vec3d = List[float] | List[int] | Tuple[float, float, float] | Tuple[int, int, int] | torch.Tensor | np.ndarray
Vec3dOrScalar = Vec3d | float | int
Vec3dBatch = (
    Vec3d
    | List[List[float]]
    | List[List[int]]
    | List[Tuple[float, float, float]]
    | List[Tuple[int, int, int]]
    | Tuple[Tuple[float, float, float], ...]
    | Tuple[Tuple[int, int, int], ...]
    | torch.Tensor
    | np.ndarray
)
Vec3dBatchOrScalar = Vec3dBatch | float | int

Vec3i = List[int] | Tuple[int, int, int] | torch.Tensor | np.ndarray
Vec3iOrScalar = Vec3i | int
Vec3iBatch = (
    Vec3i | List[List[int]] | List[Tuple[int, int, int]] | Tuple[Tuple[int, int, int], ...] | torch.Tensor | np.ndarray
)
Vec3iBatchOrScalar = Vec3iBatch | float | int

Vec4i = List[int] | Tuple[int, int, int, int] | torch.Tensor | np.ndarray

CUTLASS: ConvPackBackend
GATHER_SCATTER: ConvPackBackend
IGEMM: ConvPackBackend
LGGS: ConvPackBackend

class ConvPackBackend:
    __members__: ClassVar[dict] = ...  # read-only
    CUTLASS: ClassVar[ConvPackBackend] = ...
    GATHER_SCATTER: ClassVar[ConvPackBackend] = ...
    IGEMM: ClassVar[ConvPackBackend] = ...
    LGGS: ClassVar[ConvPackBackend] = ...
    __entries: ClassVar[dict] = ...
    def __init__(self, value: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class GaussianSplat3d:
    log_scales: torch.Tensor
    logit_opacities: torch.Tensor
    means: torch.Tensor
    quats: torch.Tensor
    requires_grad: bool
    sh0: torch.Tensor
    shN: torch.Tensor
    track_max_2d_radii_for_grad: bool
    def __init__(
        self,
        means: torch.Tensor,
        quats: torch.Tensor,
        log_scales: torch.Tensor,
        logit_opacities: torch.Tensor,
        sh0: torch.Tensor,
        shN: torch.Tensor,
        requires_grad: bool = ...,
    ) -> None: ...
    @staticmethod
    def from_state_dict(state_dict: dict[str, torch.Tensor]) -> GaussianSplat3d: ...
    def load_state_dict(self, state_dict: dict[str, torch.Tensor]) -> None: ...
    def project_gaussians_for_depths(
        self,
        world_to_camera_matrices: torch.Tensor,
        projection_matrices: torch.Tensor,
        image_width: int,
        image_height: int,
        near: float,
        far: float,
        projection_type=...,
        min_radius_2d: float = ...,
        eps_2d: float = ...,
        antialias: bool = ...,
    ) -> ProjectedGaussianSplats: ...
    def project_gaussians_for_images(
        self,
        world_to_camera_matrices: torch.Tensor,
        projection_matrices: torch.Tensor,
        image_width: int,
        image_height: int,
        near: float,
        far: float,
        projection_type=...,
        sh_degree_to_use: int = ...,
        min_radius_2d: float = ...,
        eps_2d: float = ...,
        antialias: bool = ...,
    ) -> ProjectedGaussianSplats: ...
    def project_gaussians_for_images_and_depths(
        self,
        world_to_camera_matrices: torch.Tensor,
        projection_matrices: torch.Tensor,
        image_width: int,
        image_height: int,
        near: float,
        far: float,
        projection_type=...,
        sh_degree_to_use: int = ...,
        min_radius_2d: float = ...,
        eps_2d: float = ...,
        antialias: bool = ...,
    ) -> ProjectedGaussianSplats: ...
    def render_depths(
        self,
        world_to_camera_matrices: torch.Tensor,
        projection_matrices: torch.Tensor,
        image_width: int,
        image_height: int,
        near: float,
        far: float,
        projection_type=...,
        tile_size: int = ...,
        min_radius_2d: float = ...,
        eps_2d: float = ...,
        antialias: bool = ...,
    ) -> tuple[torch.Tensor, torch.Tensor]: ...
    def render_from_projected_gaussians(
        self,
        projected_gaussians: ProjectedGaussianSplats,
        crop_width: int = ...,
        crop_height: int = ...,
        crop_origin_w: int = ...,
        crop_origin_h: int = ...,
        tile_size: int = ...,
    ) -> tuple[torch.Tensor, torch.Tensor]: ...
    def render_images(
        self,
        world_to_camera_matrices: torch.Tensor,
        projection_matrices: torch.Tensor,
        image_width: int,
        image_height: int,
        near: float,
        far: float,
        projection_type=...,
        sh_degree_to_use: int = ...,
        tile_size: int = ...,
        min_radius_2d: float = ...,
        eps_2d: float = ...,
        antialias: bool = ...,
    ) -> tuple[torch.Tensor, torch.Tensor]: ...
    def render_images_and_depths(
        self,
        world_to_camera_matrices: torch.Tensor,
        projection_matrices: torch.Tensor,
        image_width: int,
        image_height: int,
        near: float,
        far: float,
        projection_type=...,
        sh_degree_to_use: int = ...,
        tile_size: int = ...,
        min_radius_2d: float = ...,
        eps_2d: float = ...,
        antialias: bool = ...,
    ) -> tuple[torch.Tensor, torch.Tensor]: ...
    def reset_grad_state(self) -> None: ...
    def save_ply(self, filename: str) -> None: ...
    def set_state(
        self,
        means: torch.Tensor,
        quats: torch.Tensor,
        log_scales: torch.Tensor,
        logit_opacities: torch.Tensor,
        sh0: torch.Tensor,
        shN: torch.Tensor,
        requires_grad: bool = ...,
    ) -> None: ...
    def state_dict(self) -> dict[str, torch.Tensor]: ...
    @property
    def accumulated_gradient_step_counts_for_grad(self) -> torch.Tensor: ...
    @property
    def accumulated_max_2d_radii_for_grad(self) -> torch.Tensor: ...
    @property
    def accumulated_mean_2d_gradient_norms_for_grad(self) -> torch.Tensor: ...
    @property
    def num_channels(self) -> int: ...
    @property
    def num_gaussians(self) -> int: ...
    @property
    def num_sh_bases(self) -> int: ...
    @property
    def opacities(self) -> torch.Tensor: ...
    @property
    def scales(self) -> torch.Tensor: ...

class GridBatch:
    max_grids_per_batch: ClassVar[int] = ...  # read-only
    @overload
    def __init__(self, device: torch.device = ..., mutable: bool = ...) -> None: ...
    @overload
    def __init__(self, device: str = ..., mutable: bool = ...) -> None: ...
    def avg_pool(self, *args, **kwargs): ...
    def bbox_at(self, bi: int) -> torch.Tensor: ...
    def clip(self, *args, **kwargs): ...
    @overload
    def clipped_grid(self, ijk_min: Vec3iBatch, ijk_max: Vec3iBatch) -> GridBatch: ...
    @overload
    def clipped_grid(self, GridBatch) -> Any: ...
    @overload
    def coarsened_grid(self, coarsening_factor: Vec3iOrScalar) -> GridBatch: ...
    @overload
    def coarsened_grid(self, GridBatch) -> Any: ...
    def contiguous(self) -> GridBatch: ...
    @overload
    def conv_grid(self, kernel_size: Vec3iOrScalar, stride: Vec3iOrScalar) -> GridBatch: ...
    @overload
    def conv_grid(self, GridBatch) -> Any: ...
    def coords_in_active_voxel(self, JaggedTensor) -> Any: ...
    def cpu(self) -> GridBatch: ...
    def cubes_in_grid(self, *args, **kwargs): ...
    def cubes_intersect_grid(self, JaggedTensor) -> Any: ...
    def cuda(self) -> GridBatch: ...
    def cum_enabled_voxels_at(self, arg0: int) -> int: ...
    def cum_voxels_at(self, arg0: int) -> int: ...
    def disable_ijk(self, ijk) -> None: ...
    def dual_bbox_at(self, arg0: int) -> torch.Tensor: ...
    @overload
    def dual_grid(self, exclude_border: bool = ...) -> GridBatch: ...
    @overload
    def dual_grid(self, GridBatch) -> Any: ...
    def enable_ijk(self, ijk) -> None: ...
    def fill_from_grid(self, *args, **kwargs): ...
    def grid_to_world(self, *args, **kwargs): ...
    def ijk_to_index(self, *args, **kwargs): ...
    def ijk_to_inv_index(self, *args, **kwargs): ...
    def is_contiguous(self) -> bool: ...
    @overload
    def is_same(self, other: GridBatch) -> bool: ...
    @overload
    def is_same(self, bool) -> Any: ...
    def jagged_like(self, *args, **kwargs): ...
    def marching_cubes(self, *args, **kwargs): ...
    def max_pool(self, *args, **kwargs): ...
    def neighbor_indexes(self, *args, **kwargs): ...
    def num_enabled_voxels_at(self, arg0: int) -> int: ...
    def num_voxels_at(self, arg0: int) -> int: ...
    def origin_at(self, arg0: int) -> torch.Tensor: ...
    def points_in_active_voxel(self, JaggedTensor) -> Any: ...
    def ray_implicit_intersection(self, *args, **kwargs): ...
    def read_from_dense(self, *args, **kwargs): ...
    def sample_bezier(self, *args, **kwargs): ...
    def sample_bezier_with_grad(self, *args, **kwargs): ...
    def sample_trilinear(self, *args, **kwargs): ...
    def sample_trilinear_with_grad(self, *args, **kwargs): ...
    def segments_along_rays(self, *args, **kwargs): ...
    def set_from_dense_grid(
        self,
        num_grids: int,
        dense_dims: Vec3i,
        ijk_min: Vec3i = ...,
        voxel_sizes: Vec3dBatchOrScalar = ...,
        origins: Vec3dBatch = ...,
        mask: torch.Tensor | None = ...,
    ) -> None: ...
    def set_from_ijk(
        self,
        ijk,
        pad_min: Vec3i = ...,
        pad_max: Vec3i = ...,
        voxel_sizes: Vec3dBatchOrScalar = ...,
        origins: Vec3dBatch = ...,
    ) -> None: ...
    def dilated_grid(self, dilation: int) -> GridBatch: ...
    def set_from_mesh(
        self, mesh_vertices, mesh_faces, voxel_sizes: Vec3dBatchOrScalar = ..., origins: Vec3dBatch = ...
    ) -> None: ...
    def set_from_nearest_voxels_to_points(
        self, points, voxel_sizes: Vec3dBatchOrScalar = ..., origins: Vec3dBatch = ...
    ) -> None: ...
    def set_from_points(
        self,
        points,
        pad_min: Vec3i = ...,
        pad_max: Vec3i = ...,
        voxel_sizes: Vec3dBatchOrScalar = ...,
        origins: Vec3dBatch = ...,
    ) -> None: ...
    def set_global_origin(self, origin: Vec3d) -> None: ...
    def set_global_voxel_size(self, voxel_size: Vec3dOrScalar) -> None: ...
    def sparse_conv_halo(self, *args, **kwargs): ...
    def sparse_conv_kernel_map(self, *args, **kwargs): ...
    def splat_bezier(self, *args, **kwargs): ...
    def splat_trilinear(self, *args, **kwargs): ...
    def subdivide(self, *args, **kwargs): ...
    @overload
    def subdivided_grid(self, subdiv_factor: Vec3iOrScalar, mask=...) -> GridBatch: ...
    @overload
    def subdivided_grid(self, GridBatch) -> Any: ...
    @overload
    def to(self, to_device: torch.device) -> GridBatch: ...
    @overload
    def to(self, to_device: str) -> GridBatch: ...
    @overload
    def to(self, to_tensor: torch.Tensor) -> GridBatch: ...
    @overload
    def to(self, to_jtensor) -> GridBatch: ...
    @overload
    def to(self, to_grid: GridBatch) -> GridBatch: ...
    def uniform_ray_samples(self, *args, **kwargs): ...
    def voxel_size_at(self, arg0: int) -> torch.Tensor: ...
    def voxels_along_rays(self, *args, **kwargs): ...
    def world_to_grid(self, *args, **kwargs): ...
    def write_to_dense(
        self, sparse_data, min_coord: Vec3iBatch | None = ..., grid_size: Vec3i | None = ...
    ) -> torch.Tensor: ...
    @overload
    def __getitem__(self, arg0: int) -> GridBatch: ...
    @overload
    def __getitem__(self, arg0: slice) -> GridBatch: ...
    @overload
    def __getitem__(self, arg0: list[bool]) -> GridBatch: ...
    @overload
    def __getitem__(self, arg0: list[int]) -> GridBatch: ...
    @overload
    def __getitem__(self, arg0: torch.Tensor) -> GridBatch: ...
    def __iter__(self) -> typing.Iterator[GridBatch]: ...
    def __len__(self) -> int: ...
    @property
    def address(self) -> int: ...
    @property
    def bbox(self) -> torch.Tensor: ...
    @property
    def cum_enabled_voxels(self) -> torch.Tensor: ...
    @property
    def cum_voxels(self) -> torch.Tensor: ...
    @property
    def device(self) -> torch.device: ...
    @property
    def disabled_mask(self): ...
    @property
    def dual_bbox(self) -> torch.Tensor: ...
    @property
    def enabled_mask(self): ...
    @property
    def grid_count(self) -> int: ...
    @property
    def grid_to_world_matrices(self) -> torch.Tensor: ...
    @property
    def ijk(self): ...
    @property
    def ijk_enabled(self): ...
    @property
    def jidx(self) -> torch.Tensor: ...
    @property
    def joffsets(self) -> torch.Tensor: ...
    @property
    def mutable(self) -> bool: ...
    @property
    def num_bytes(self) -> torch.Tensor: ...
    @property
    def num_enabled_voxels(self) -> torch.Tensor: ...
    @property
    def num_leaf_nodes(self) -> torch.Tensor: ...
    @property
    def num_voxels(self) -> torch.Tensor: ...
    @property
    def origins(self) -> torch.Tensor: ...
    @property
    def total_bbox(self) -> torch.Tensor: ...
    @property
    def total_bytes(self) -> int: ...
    @property
    def total_enabled_voxels(self) -> int: ...
    @property
    def total_leaf_nodes(self) -> int: ...
    @property
    def total_voxels(self) -> int: ...
    @property
    def viz_edge_network(self): ...
    @property
    def voxel_sizes(self) -> torch.Tensor: ...
    @property
    def world_to_grid_matrices(self) -> torch.Tensor: ...

class JaggedTensor:
    jdata: torch.Tensor
    requires_grad: bool
    @overload
    def __init__(self, tensor_list: list[list[torch.Tensor]]) -> None: ...
    @overload
    def __init__(self, tensor_list: list[torch.Tensor]) -> None: ...
    @overload
    def __init__(self, tensor: torch.Tensor) -> None: ...
    def abs(self) -> JaggedTensor: ...
    def abs_(self) -> JaggedTensor: ...
    def ceil(self) -> JaggedTensor: ...
    def ceil_(self) -> JaggedTensor: ...
    def clone(self) -> JaggedTensor: ...
    def cpu(self) -> JaggedTensor: ...
    def cuda(self) -> JaggedTensor: ...
    def detach(self) -> JaggedTensor: ...
    def double(self) -> JaggedTensor: ...
    def float(self) -> JaggedTensor: ...
    def floor(self) -> JaggedTensor: ...
    def floor_(self) -> JaggedTensor: ...
    @staticmethod
    def from_data_and_indices(arg0: torch.Tensor, arg1: torch.Tensor, arg2: int) -> JaggedTensor: ...
    @staticmethod
    def from_data_and_offsets(arg0: torch.Tensor, arg1: torch.Tensor) -> JaggedTensor: ...
    @staticmethod
    def from_data_indices_and_list_ids(
        data: torch.Tensor, indices: torch.Tensor, list_ids: torch.Tensor, num_tensors: int
    ) -> JaggedTensor: ...
    @staticmethod
    def from_data_offsets_and_list_ids(
        data: torch.Tensor, offsets: torch.Tensor, list_ids: torch.Tensor
    ) -> JaggedTensor: ...
    def int(self) -> JaggedTensor: ...
    def jagged_like(self, data: torch.Tensor) -> JaggedTensor: ...
    def jflatten(self, dim: int = ...) -> JaggedTensor: ...
    def jmax(self, dim: int = ..., keepdim: bool = ...) -> list[JaggedTensor]: ...
    def jmin(self, dim: int = ..., keepdim: bool = ...) -> list[JaggedTensor]: ...
    @overload
    def jreshape(self, lshape: list[int]) -> JaggedTensor: ...
    @overload
    def jreshape(self, lshape: list[list[int]]) -> JaggedTensor: ...
    def jreshape_as(self, other: JaggedTensor | torch.Tensor) -> JaggedTensor: ...
    def jsqueeze(self, dim: int | None = None) -> JaggedTensor: ...
    def jsum(self, dim: int = ..., keepdim: bool = ...) -> JaggedTensor: ...
    def long(self) -> JaggedTensor: ...
    def requires_grad_(self, arg0: bool) -> JaggedTensor: ...
    def rmask(self, mask: torch.Tensor) -> JaggedTensor: ...
    def round(self, decimals: int = ...) -> JaggedTensor: ...
    def round_(self, decimals: int = ...) -> JaggedTensor: ...
    def sqrt(self) -> JaggedTensor: ...
    def sqrt_(self) -> JaggedTensor: ...
    @overload
    def to(self, arg0: torch.device) -> JaggedTensor: ...
    @overload
    def to(self, arg0: str) -> JaggedTensor: ...
    @overload
    def to(self, arg0: torch.dtype) -> JaggedTensor: ...
    @overload
    def to(self, device: torch.device) -> JaggedTensor: ...
    @overload
    def to(self, device: str) -> JaggedTensor: ...
    def type(self, arg0: torch.dtype) -> JaggedTensor: ...
    def type_as(self, arg0: JaggedTensor | torch.Tensor) -> JaggedTensor: ...
    def unbind(self) -> object: ...
    @overload
    def __add__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __add__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __add__(self, other: int) -> JaggedTensor: ...
    @overload
    def __add__(self, other: float) -> JaggedTensor: ...
    @overload
    def __eq__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __eq__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __eq__(self, other: int) -> JaggedTensor: ...
    @overload
    def __eq__(self, other: float) -> JaggedTensor: ...
    @overload
    def __floordiv__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __floordiv__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __floordiv__(self, other: int) -> JaggedTensor: ...
    @overload
    def __floordiv__(self, other: float) -> JaggedTensor: ...
    @overload
    def __ge__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __ge__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __ge__(self, other: int) -> JaggedTensor: ...
    @overload
    def __ge__(self, other: float) -> JaggedTensor: ...
    def __getitem__(self, arg0) -> JaggedTensor: ...
    @overload
    def __gt__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __gt__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __gt__(self, other: int) -> JaggedTensor: ...
    @overload
    def __gt__(self, other: float) -> JaggedTensor: ...
    @overload
    def __iadd__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __iadd__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __iadd__(self, other: int) -> JaggedTensor: ...
    @overload
    def __iadd__(self, other: float) -> JaggedTensor: ...
    @overload
    def __ifloordiv__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __ifloordiv__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __ifloordiv__(self, other: int) -> JaggedTensor: ...
    @overload
    def __ifloordiv__(self, other: float) -> JaggedTensor: ...
    @overload
    def __imod__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __imod__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __imod__(self, other: int) -> JaggedTensor: ...
    @overload
    def __imod__(self, other: float) -> JaggedTensor: ...
    @overload
    def __imul__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __imul__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __imul__(self, other: int) -> JaggedTensor: ...
    @overload
    def __imul__(self, other: float) -> JaggedTensor: ...
    @overload
    def __ipow__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __ipow__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __ipow__(self, other: int) -> JaggedTensor: ...
    @overload
    def __ipow__(self, other: float) -> JaggedTensor: ...
    @overload
    def __isub__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __isub__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __isub__(self, other: int) -> JaggedTensor: ...
    @overload
    def __isub__(self, other: float) -> JaggedTensor: ...
    @overload
    def __itruediv__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __itruediv__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __itruediv__(self, other: int) -> JaggedTensor: ...
    @overload
    def __itruediv__(self, other: float) -> JaggedTensor: ...
    @overload
    def __le__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __le__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __le__(self, other: int) -> JaggedTensor: ...
    @overload
    def __le__(self, other: float) -> JaggedTensor: ...
    def __len__(self) -> int: ...
    @overload
    def __lt__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __lt__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __lt__(self, other: int) -> JaggedTensor: ...
    @overload
    def __lt__(self, other: float) -> JaggedTensor: ...
    @overload
    def __mod__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __mod__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __mod__(self, other: int) -> JaggedTensor: ...
    @overload
    def __mod__(self, other: float) -> JaggedTensor: ...
    @overload
    def __mul__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __mul__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __mul__(self, other: int) -> JaggedTensor: ...
    @overload
    def __mul__(self, other: float) -> JaggedTensor: ...
    @overload
    def __ne__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __ne__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __ne__(self, other: int) -> JaggedTensor: ...
    @overload
    def __ne__(self, other: float) -> JaggedTensor: ...
    @overload
    def __neg__(self) -> JaggedTensor: ...
    @overload
    def __neg__(self) -> JaggedTensor: ...
    @overload
    def __pow__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __pow__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __pow__(self, other: int) -> JaggedTensor: ...
    @overload
    def __pow__(self, other: float) -> JaggedTensor: ...
    @overload
    def __sub__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __sub__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __sub__(self, other: int) -> JaggedTensor: ...
    @overload
    def __sub__(self, other: float) -> JaggedTensor: ...
    @overload
    def __truediv__(self, other: torch.Tensor) -> JaggedTensor: ...
    @overload
    def __truediv__(self, other: JaggedTensor) -> JaggedTensor: ...
    @overload
    def __truediv__(self, other: int) -> JaggedTensor: ...
    @overload
    def __truediv__(self, other: float) -> JaggedTensor: ...
    @property
    def device(self) -> torch.device: ...
    @property
    def dtype(self) -> torch.dtype: ...
    @property
    def edim(self) -> int: ...
    @property
    def eshape(self) -> list[int]: ...
    @property
    def is_cpu(self) -> bool: ...
    @property
    def is_cuda(self) -> bool: ...
    @property
    def jidx(self) -> torch.Tensor: ...
    @property
    def jlidx(self) -> torch.Tensor: ...
    @property
    def joffsets(self) -> torch.Tensor: ...
    @property
    def ldim(self) -> int: ...
    @property
    def lshape(self) -> list[int] | list[list[int]]: ...
    @property
    def num_tensors(self) -> int: ...
    @property
    def rshape(self) -> tuple[int, ...]: ...

class NanoVDBFileGridIdentifier:
    def __init__(self, *args, **kwargs) -> None: ...

class ProjectedGaussianSplats:
    def __init__(self, *args, **kwargs) -> None: ...
    @property
    def antialias(self) -> bool: ...
    @property
    def conics(self) -> torch.Tensor: ...
    @property
    def depths(self) -> torch.Tensor: ...
    @property
    def eps_2d(self) -> float: ...
    @property
    def far_plane(self) -> float: ...
    @property
    def image_height(self) -> int: ...
    @property
    def image_width(self) -> int: ...
    @property
    def means2d(self) -> torch.Tensor: ...
    @property
    def min_radius_2d(self) -> float: ...
    @property
    def near_plane(self) -> float: ...
    @property
    def opacities(self) -> torch.Tensor: ...
    @property
    def projection_type(self): ...
    @property
    def radii(self) -> torch.Tensor: ...
    @property
    def render_quantities(self) -> torch.Tensor: ...
    @property
    def sh_degree_to_use(self) -> int: ...
    @property
    def tile_gaussian_ids(self) -> torch.Tensor: ...
    @property
    def tile_offsets(self) -> torch.Tensor: ...

class SparseConvPackInfo:
    def __init__(
        self, kernel_size: Vec3iOrScalar, stride: Vec3iOrScalar, source_grid: GridBatch, target_grid: GridBatch | None
    ) -> None: ...
    def build_cutlass(self, benchmark: bool = ...) -> None: ...
    def build_gather_scatter(self, use_me: bool = ...) -> None: ...
    def build_implicit_gemm(
        self,
        sorted: bool = ...,
        split_mask_num: int = ...,
        training: bool = ...,
        split_mask_num_bwd: int = ...,
        use_tf32: bool = ...,
    ) -> None: ...
    def build_lggs(self) -> None: ...
    def cpu(self) -> SparseConvPackInfo: ...
    def cuda(self) -> SparseConvPackInfo: ...
    def sparse_conv_3d(
        self, input: JaggedTensor | torch.Tensor, weights: torch.Tensor, backend: ConvPackBackend = ...
    ) -> JaggedTensor: ...
    def sparse_transpose_conv_3d(
        self, input: JaggedTensor | torch.Tensor, weights: torch.Tensor, backend: ConvPackBackend = ...
    ) -> JaggedTensor: ...
    @overload
    def to(self, to_device: torch.device) -> SparseConvPackInfo: ...
    @overload
    def to(self, to_device: str) -> SparseConvPackInfo: ...
    @property
    def block_kernel_in_idx(self) -> torch.Tensor | None: ...
    @property
    def block_kernel_ranges(self) -> torch.Tensor | None: ...
    @property
    def block_kernel_rel_out_idx(self) -> torch.Tensor | None: ...
    @property
    def halo_index_buffer(self) -> torch.Tensor | None: ...
    @property
    def kernel_size(self) -> tuple: ...
    @property
    def neighborhood_map(self) -> torch.Tensor | None: ...
    @property
    def neighborhood_sizes(self) -> torch.Tensor | None: ...
    @property
    def out_in_map(self) -> torch.Tensor | None: ...
    @property
    def out_in_map_bwd(self) -> torch.Tensor | None: ...
    @property
    def output_index_buffer(self) -> torch.Tensor | None: ...
    @property
    def reduced_sorted_mask(self) -> torch.Tensor | None: ...
    @property
    def reorder_loc(self) -> torch.Tensor | None: ...
    @property
    def reorder_loc_bwd(self) -> torch.Tensor | None: ...
    @property
    def reorder_out_in_map(self) -> torch.Tensor | None: ...
    @property
    def reorder_out_in_map_bwd(self) -> torch.Tensor | None: ...
    @property
    def sorted_mask(self) -> torch.Tensor | None: ...
    @property
    def sorted_mask_bwd_d(self) -> torch.Tensor | None: ...
    @property
    def sorted_mask_bwd_w(self) -> torch.Tensor | None: ...
    @property
    def source_grid(self) -> GridBatch: ...
    @property
    def stride(self) -> tuple: ...
    @property
    def target_grid(self) -> GridBatch: ...
    @property
    def use_me(self) -> bool: ...
    @property
    def use_tf32(self) -> bool: ...

class config:
    enable_ultra_sparse_acceleration: ClassVar[bool] = ...
    pedantic_error_checking: ClassVar[bool] = ...
    def __init__(self, *args, **kwargs) -> None: ...

def gaussian_render_jagged(*args, **kwargs): ...
@overload
def gridbatch_from_dense(
    num_grids: int,
    dense_dims: Vec3i,
    ijk_min: Vec3i = ...,
    voxel_sizes: Vec3dBatchOrScalar = ...,
    origins: Vec3dBatch = ...,
    mask: torch.Tensor | None = ...,
    device: torch.device = ...,
    mutable: bool = ...,
) -> GridBatch: ...
@overload
def gridbatch_from_dense(
    num_grids: int,
    dense_dims: Vec3i,
    ijk_min: Vec3i = ...,
    voxel_sizes: Vec3dBatchOrScalar = ...,
    origins: Vec3dBatch = ...,
    mask: torch.Tensor | None = ...,
    device: str = ...,
    mutable: bool = ...,
) -> GridBatch: ...
def gridbatch_from_ijk(
    ijk: JaggedTensor | torch.Tensor,
    pad_min: Vec3i = ...,
    pad_max: Vec3i = ...,
    voxel_sizes: Vec3dBatchOrScalar = ...,
    origins: Vec3dBatch = ...,
    mutable: bool = ...,
) -> GridBatch: ...
def gridbatch_from_mesh(
    vertices: JaggedTensor | torch.Tensor,
    faces: JaggedTensor | torch.Tensor,
    voxel_sizes: Vec3dBatchOrScalar = ...,
    origins: Vec3dBatch = ...,
    mutable: bool = ...,
) -> GridBatch: ...
def gridbatch_from_nearest_voxels_to_points(
    points: JaggedTensor | torch.Tensor,
    voxel_sizes: Vec3dBatchOrScalar = ...,
    origins: Vec3dBatch = ...,
    mutable: bool = ...,
) -> GridBatch: ...
def gridbatch_from_points(
    points: JaggedTensor | torch.Tensor,
    pad_min: Vec3i = ...,
    pad_max: Vec3i = ...,
    voxel_sizes: Vec3dBatchOrScalar = ...,
    origins: Vec3dBatch = ...,
    mutable: bool = ...,
) -> GridBatch: ...
@overload
def jcat(grid_batches: list[GridBatch]) -> GridBatch: ...
@overload
def jcat(jagged_tensors: list[JaggedTensor | torch.Tensor], dim: int | None = ...) -> JaggedTensor: ...
@overload
def jempty(
    lshape: list[int],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jempty(
    lshape: list[int],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: str | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jempty(
    lshape: list[list[int]],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jempty(
    lshape: list[list[int]],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: str | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jones(
    lshape: list[int],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jones(
    lshape: list[int],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: str | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jones(
    lshape: list[list[int]],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jones(
    lshape: list[list[int]],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: str | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jrand(
    lshape: list[int],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jrand(
    lshape: list[int],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: str | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jrand(
    lshape: list[list[int]],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jrand(
    lshape: list[list[int]],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: str | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jrandn(
    lshape: list[int],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jrandn(
    lshape: list[int],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: str | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jrandn(
    lshape: list[list[int]],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jrandn(
    lshape: list[list[int]],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: str | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jzeros(
    lshape: list[int],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jzeros(
    lshape: list[int],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: str | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jzeros(
    lshape: list[list[int]],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: torch.device | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def jzeros(
    lshape: list[list[int]],
    rshape: list[int] | None = ...,
    dtype: torch.dtype | None = ...,
    device: str | None = ...,
    requires_grad: bool = ...,
    pin_memory: bool = ...,
) -> JaggedTensor: ...
@overload
def load(
    path: str, grid_id: NanoVDBFileGridIdentifier = ..., device: torch.device = ..., verbose: bool = ...
) -> tuple[GridBatch, JaggedTensor, list[str]]: ...
@overload
def load(
    path: str, grid_id: NanoVDBFileGridIdentifier = ..., device: str = ..., verbose: bool = ...
) -> tuple[GridBatch, JaggedTensor, list[str]]: ...
@overload
def save(
    path: str,
    grid_batch: GridBatch,
    data: JaggedTensor | None = ...,
    names: list[str] = ...,
    compressed: bool = ...,
    verbose: bool = ...,
) -> None: ...
@overload
def save(
    path: str,
    grid_batch: GridBatch,
    data: JaggedTensor | None = ...,
    name: str = ...,
    compressed: bool = ...,
    verbose: bool = ...,
) -> None: ...
def scaled_dot_product_attention(
    query: JaggedTensor | torch.Tensor,
    key: JaggedTensor | torch.Tensor,
    value: JaggedTensor | torch.Tensor,
    scale: float,
) -> JaggedTensor: ...
def volume_render(
    sigmas: torch.Tensor,
    rgbs: torch.Tensor,
    deltaTs: torch.Tensor,
    ts: torch.Tensor,
    packInfo: torch.Tensor,
    transmittanceThresh: float,
) -> list[torch.Tensor]: ...
