<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: openvdb::v8_1::ax::ast Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__1.html">v8_1</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax.html">ax</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html">ast</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">openvdb::v8_1::ax::ast Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html">tokens</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ArrayPack.html">ArrayPack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ArrayPacks represent temporary container creations of arbitrary sizes, typically generated through the use of curly braces {}.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ArrayPack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ArrayUnpack.html">ArrayUnpack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ArrayUnpack.html" title="ArrayUnpack represent indexing operations into AX container types, primarily vectors and matrices ind...">ArrayUnpack</a> represent indexing operations into AX container types, primarily vectors and matrices indexed by the square brackets [] syntax. Multiple levels of indirection (multiple components) can be specified but current construction is limited to either a single or double component lookup. Providing two components infers a matrix indexing operation.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ArrayUnpack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1AssignExpression.html">AssignExpression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">AssignExpressions represents a similar object construction to a <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1BinaryOperator.html" title="A BinaryOperator represents a single binary operation between a left hand side (LHS) and right hand s...">BinaryOperator</a>. AssignExpressions can be chained together and are thus derived as Expressions rather than Statements.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1AssignExpression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Attribute.html">Attribute</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attributes represent any access to a primitive value, typically associated with the '@' symbol syntax. Note that the AST does not store any additional information on the given attribute other than its name and type, which together form a unique <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> identifier known as the <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> 'token'. A 'primitive value' in this instance refers to a value on an OpenVDB Volume or OpenVDB Points tree.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Attribute.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1BinaryOperator.html">BinaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1BinaryOperator.html" title="A BinaryOperator represents a single binary operation between a left hand side (LHS) and right hand s...">BinaryOperator</a> represents a single binary operation between a left hand side (LHS) and right hand side (RHS) expression. The operation type is stored as a <a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">tokens::OperatorToken</a> enumerated type on the node. AX grammar guarantees that this token will only ever be a valid binary operator token type when initialized by the parser.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1BinaryOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Block.html">Block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Block.html" title="A Block node represents a scoped list of statements. It may comprise of 0 or more statements...">Block</a> node represents a scoped list of statements. It may comprise of 0 or more statements, and specifically indicates that a new scope is activated, typically represented by curly braces. Note that a block does not alway have to be encapsulated by curly braces, but always represents a new scope.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Cast.html">Cast</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Cast.html" title="Cast nodes represent the conversion of an underlying expression to a target type. Cast nodes are typi...">Cast</a> nodes represent the conversion of an underlying expression to a target type. <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Cast.html" title="Cast nodes represent the conversion of an underlying expression to a target type. Cast nodes are typi...">Cast</a> nodes are typically constructed from functional notation and do not represent construction of the target type, rather a type-casted conversion.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Cast.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1CommaOperator.html">CommaOperator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ConditionalStatement.html">ConditionalStatement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ConditionalStatements represents all combinations of 'if', 'else' and 'else if' syntax and semantics. A single <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ConditionalStatement.html" title="ConditionalStatements represents all combinations of &#39;if&#39;, &#39;else&#39; and &#39;else if&#39; syntax and semantics...">ConditionalStatement</a> only ever represents up to two branches; an 'if' (true) and an optional 'else' (false). ConditionalStatements are nested within the second 'else' branch to support 'else if' logic. As well as both 'if' and 'else' branches, a <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ConditionalStatement.html" title="ConditionalStatements represents all combinations of &#39;if&#39;, &#39;else&#39; and &#39;else if&#39; syntax and semantics...">ConditionalStatement</a> also holds an <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Expression.html" title="Expressions are comprised of full or potentially partial parts of a full statement that may not neces...">Expression</a> related to its primary condition.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ConditionalStatement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Crement.html">Crement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Crement.html" title="A Crement node represents a single increment &#39;++&#39; and decrement &#39;â€“&#39; operation. As well as it&#39;s creme...">Crement</a> node represents a single increment '++' and decrement '&ndash;' operation. As well as it's crement type, it also stores whether the semantics constructed a post or pre-crement i.e. ++a or a++.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Crement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1DeclareLocal.html">DeclareLocal</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1DeclareLocal.html" title="DeclareLocal AST nodes symbolize a single type declaration of a local variable. These store the local...">DeclareLocal</a> AST nodes symbolize a single type declaration of a local variable. These store the local variables that They also however store its specified type. These have the important distinction of representing the initial creation and allocation of a variable, in comparison to a <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Local.html" title="Local AST nodes represent a single accesses to a local variable. The only store the name of the varia...">Local</a> node which only represents access.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1DeclareLocal.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Expression.html">Expression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expressions are comprised of full or potentially partial parts of a full statement that may not necessary make up an entire valid statement on their own. For example, while a Binary Operator such as "3 + 5;"" is a valid statement on its own, the full statement
       "3 + 5 + 6;" must be broken down into two expressions which together form the statement as well as determining precedence.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Expression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ExternalVariable.html">ExternalVariable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> represent any access to external (custom) data, typically associated with the '$' symbol syntax. Note that the AST does not store any additional information on the given external other than its name and type, which together form a unique external identifier known as the <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ExternalVariable.html" title="ExternalVariable represent any access to external (custom) data, typically associated with the &#39;$&#39; sy...">ExternalVariable</a> 'token'. This token is used by the compiler to map user provided values to these external values.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ExternalVariable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1FunctionCall.html">FunctionCall</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">FunctionCalls represent a single call to a function and any provided arguments. The argument list can be empty. The function name is expected to exist in the AX function registry.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1FunctionCall.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Keyword.html">Keyword</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keywords represent keyword statements defining changes in execution. These include those that define changes in loop execution such as break and continue, as well as return statements.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Keyword.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Local.html">Local</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Local.html" title="Local AST nodes represent a single accesses to a local variable. The only store the name of the varia...">Local</a> AST nodes represent a single accesses to a local variable. The only store the name of the variable being accessed.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Local.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Loop.html">Loop</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loops represent for, while and do-while loop constructs. These all consist of a condition - evaluated to determine if loop iteration should continue, and a body which is the logic to be repeated. For loops also have initial statements which are evaluated prior to loop execution (at loop scope) and commonly used to set up iterators, and iteration expressions which are evaluated between iterations after the body and before the condition. Both conditions and initial statements can be declarations or expressions, so are Statements, and iteration expressions can consist of multiple expressions. The loop body is a <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Block.html" title="A Block node represents a scoped list of statements. It may comprise of 0 or more statements...">Block</a> defining its own scope (encapsulated by initial statement scope for for-loops).  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Loop.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The base abstract node which determines the interface and required methods for all derived concrete nodes which comprise a valid AST.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Statement.html">Statement</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract (pure-virtual) AST nodes.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Statement.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1StatementList.html">StatementList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concrete AST nodes.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1StatementList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1TernaryOperator.html">TernaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1TernaryOperator.html" title="A TernaryOperator represents a ternary (conditional) expression &#39;a ? b : c&#39; which evaluates to &#39;b&#39; if...">TernaryOperator</a> represents a ternary (conditional) expression 'a ? b : c' which evaluates to 'b' if 'a' is true and 'c' if 'a' is false. Requires 'b' and 'c' to be convertibly typed expressions, or both void. The 'true' expression ('b') is optional with the conditional expression 'a' returned if it evaluates to true, otherwise returning 'c'. Note that 'a' will only be evaluated once in this case.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1TernaryOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Tree.html">Tree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy. It represents an entire conversion of a valid AX string. ">Tree</a> is the highest concrete (non-abstract) node in the entire AX AST hierarchy. It represents an entire conversion of a valid AX string.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Tree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1UnaryOperator.html">UnaryOperator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1UnaryOperator.html" title="A UnaryOperator represents a single unary operation on an expression. The operation type is stored as...">UnaryOperator</a> represents a single unary operation on an expression. The operation type is stored as a <a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html#a2917ae141bdf0c0be0d6eb1480f09f8a">tokens::OperatorToken</a> enumerated type on the node. AX grammar guarantees that this token will only every be a valid unary operator token type when initialized by the parser.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1UnaryOperator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Value.html">Value</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Value.html" title="A Value (literal) AST node holds either literal text or absolute value information on all numerical...">Value</a> (literal) AST node holds either literal text or absolute value information on all numerical, string and boolean constants. A single instance of a <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Value.html" title="A Value (literal) AST node holds either literal text or absolute value information on all numerical...">Value</a> is templated on the requested scalar, boolean or string type. If scalar or boolean value is constructed from a string (as typically is the case in the parser), the value is automatically converted to its numerical representation. If this fails, the original text is stored instead.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Value.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html">Value&lt; std::string &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of Values for strings.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Value_3_01std_1_1string_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ValueBase.html">ValueBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">ValueBases are a base class for anything that holds a value (literal). Derived classes store the actual typed values.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1ValueBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html">Variable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Variables are a base type for Locals, Attributes and ExternalVariables. Unlike other abstract types, they also consolidate data for the derived types.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1VisitNodeType.html">VisitNodeType</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Visitor.html">Visitor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Visitor.html" title="The Visitor class uses the Curiously Recursive Template Pattern (CRTP) to provide a customizable inte...">Visitor</a> class uses the Curiously Recursive Template Pattern (CRTP) to provide a customizable interface intended to be used by clients wishing to perform custom operations over an AX Abstract Syntax <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Tree.html" title="A Tree is the highest concrete (non-abstract) node in the entire AX AST hierarchy. It represents an entire conversion of a valid AX string. ">Tree</a> (AST). By default the <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Visitor.html" title="The Visitor class uses the Curiously Recursive Template Pattern (CRTP) to provide a customizable inte...">Visitor</a> implements simple traversal of all nodes, ensuring that each node on a well formed AST is visited at least once. By deriving from the <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Visitor.html" title="The Visitor class uses the Curiously Recursive Template Pattern (CRTP) to provide a customizable inte...">Visitor</a>, users are able to customize this default behavior and further manually override specific node behavior to their needs. The function options at the top of visitor can be overridden using CRTP to control the prior default behavior, with the ability to override the <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Visitor.html#abf72acb00ab34838ffcfed86693b7ba3" title="Default traversals for a given concrete AST node type. ">traverse()</a> and <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Visitor.html#a1bc78d9f4efd54a75f8c6266040b447b" title="Visits for abstract (pure-virtual) Node types. ">visit()</a> methods for the latter more granular control.  <a href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Visitor.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2491bde6ba71abbbf4dfa96e2bf98a76"><td class="memItemLeft" align="right" valign="top">openvdb::ax::ast::Tree::Ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a2491bde6ba71abbbf4dfa96e2bf98a76">parse</a> (const char *code)</td></tr>
<tr class="memdesc:a2491bde6ba71abbbf4dfa96e2bf98a76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an abstract syntax tree from a code snippet. A runtime exception will be thrown with the first syntax error.  <a href="#a2491bde6ba71abbbf4dfa96e2bf98a76">More...</a><br /></td></tr>
<tr class="separator:a2491bde6ba71abbbf4dfa96e2bf98a76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6877e7f64c16f6c0ca882f390f73b4cb"><td class="memItemLeft" align="right" valign="top">openvdb::ax::ast::Tree::ConstPtr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a6877e7f64c16f6c0ca882f390f73b4cb">parse</a> (const char *code, <a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Logger.html">ax::Logger</a> &amp;logger)</td></tr>
<tr class="memdesc:a6877e7f64c16f6c0ca882f390f73b4cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an abstract syntax tree from a code snippet. If the code is not well formed, as defined by the AX grammar, this will simply return nullptr, with the logger collecting the errors.  <a href="#a6877e7f64c16f6c0ca882f390f73b4cb">More...</a><br /></td></tr>
<tr class="separator:a6877e7f64c16f6c0ca882f390f73b4cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776b0b1a1fe663a634b62f53a91766f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a776b0b1a1fe663a634b62f53a91766f2">print</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const bool numberStatements=true, std::ostream &amp;os=std::cout, const char *indent=&quot;    &quot;)</td></tr>
<tr class="memdesc:a776b0b1a1fe663a634b62f53a91766f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a descriptive printout of a <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a> hierarchy into a target stream.  <a href="#a776b0b1a1fe663a634b62f53a91766f2">More...</a><br /></td></tr>
<tr class="separator:a776b0b1a1fe663a634b62f53a91766f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69a3568ba75da96af6535faf109ebd3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#aa69a3568ba75da96af6535faf109ebd3">reprint</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, std::ostream &amp;os=std::cout, const char *indent=&quot;    &quot;)</td></tr>
<tr class="memdesc:aa69a3568ba75da96af6535faf109ebd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Using the provided AST, print corresponding AX code which may have been used to create it.  <a href="#aa69a3568ba75da96af6535faf109ebd3">More...</a><br /></td></tr>
<tr class="separator:aa69a3568ba75da96af6535faf109ebd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128aa4e72eec8d8799386d401b47df3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a128aa4e72eec8d8799386d401b47df3c">usesAttribute</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const std::string &amp;name, const <a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a> type=<a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7a6ce26a62afab55d7606ad4e92428b30c">tokens::UNKNOWN</a>)</td></tr>
<tr class="memdesc:a128aa4e72eec8d8799386d401b47df3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not a given branch of an AST reads from or writes to a given attribute.  <a href="#a128aa4e72eec8d8799386d401b47df3c">More...</a><br /></td></tr>
<tr class="separator:a128aa4e72eec8d8799386d401b47df3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7d215b506bde4d714b93e8569ba922f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#af7d215b506bde4d714b93e8569ba922f">writesToAttribute</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const std::string &amp;name, const <a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a> type=<a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7a6ce26a62afab55d7606ad4e92428b30c">tokens::UNKNOWN</a>)</td></tr>
<tr class="memdesc:af7d215b506bde4d714b93e8569ba922f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not a given branch of an AST writes to a given attribute.  <a href="#af7d215b506bde4d714b93e8569ba922f">More...</a><br /></td></tr>
<tr class="separator:af7d215b506bde4d714b93e8569ba922f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d0c3274f88def6ab65a85d933a6691e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a3d0c3274f88def6ab65a85d933a6691e">callsFunction</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const std::string &amp;name)</td></tr>
<tr class="memdesc:a3d0c3274f88def6ab65a85d933a6691e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns whether or not a given branch of an AST calls a function.  <a href="#a3d0c3274f88def6ab65a85d933a6691e">More...</a><br /></td></tr>
<tr class="separator:a3d0c3274f88def6ab65a85d933a6691e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6425986c3d4839cee263bb92049cf859"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a6425986c3d4839cee263bb92049cf859">catalogueVariables</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, std::vector&lt; const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * &gt; *readOnly, std::vector&lt; const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * &gt; *writeOnly, std::vector&lt; const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * &gt; *readWrite, const bool locals=true, const bool attributes=true)</td></tr>
<tr class="memdesc:a6425986c3d4839cee263bb92049cf859"><td class="mdescLeft">&#160;</td><td class="mdescRight">todo  <a href="#a6425986c3d4839cee263bb92049cf859">More...</a><br /></td></tr>
<tr class="separator:a6425986c3d4839cee263bb92049cf859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee3a19b18c2f35bbcb3804b144add645"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#aee3a19b18c2f35bbcb3804b144add645">catalogueAttributeTokens</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, std::vector&lt; std::string &gt; *readOnly, std::vector&lt; std::string &gt; *writeOnly, std::vector&lt; std::string &gt; *readWrite)</td></tr>
<tr class="memdesc:aee3a19b18c2f35bbcb3804b144add645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse all attributes into three unique vectors which represent how they are accessed within the syntax tree. Read only attributes are stored within the 'readOnly' container (for example.  <a href="#aee3a19b18c2f35bbcb3804b144add645">More...</a><br /></td></tr>
<tr class="separator:aee3a19b18c2f35bbcb3804b144add645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab021a6561f0414c71960db971dd1a911"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#ab021a6561f0414c71960db971dd1a911">attributeDependencyTokens</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Tree.html">ast::Tree</a> &amp;tree, const std::string &amp;name, const <a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a> type, std::vector&lt; std::string &gt; &amp;dependencies)</td></tr>
<tr class="memdesc:ab021a6561f0414c71960db971dd1a911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a list of attribute names which the given attribute depends on.  <a href="#ab021a6561f0414c71960db971dd1a911">More...</a><br /></td></tr>
<tr class="separator:ab021a6561f0414c71960db971dd1a911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc7a0b3fe55c85fa98c9dd7ae46d9daa"><td class="memTemplParams" colspan="2">template&lt;typename NodeT , typename OpT &gt; </td></tr>
<tr class="memitem:adc7a0b3fe55c85fa98c9dd7ae46d9daa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#adc7a0b3fe55c85fa98c9dd7ae46d9daa">visitNodeType</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const OpT &amp;op)</td></tr>
<tr class="memdesc:adc7a0b3fe55c85fa98c9dd7ae46d9daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">For an AST node of a given type, search for and call a custom const operator() which takes a const reference to every occurrence of the specified node type.  <a href="#adc7a0b3fe55c85fa98c9dd7ae46d9daa">More...</a><br /></td></tr>
<tr class="separator:adc7a0b3fe55c85fa98c9dd7ae46d9daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d739eaf1e71ce7a3a309e383ffb50e"><td class="memTemplParams" colspan="2">template&lt;typename NodeT , typename ContainerType  = std::vector&lt;const NodeT*&gt;&gt; </td></tr>
<tr class="memitem:a81d739eaf1e71ce7a3a309e383ffb50e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a81d739eaf1e71ce7a3a309e383ffb50e">collectNodeType</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, ContainerType &amp;array)</td></tr>
<tr class="memdesc:a81d739eaf1e71ce7a3a309e383ffb50e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit all nodes of a given type and store pointers to them in a provided compatible container.  <a href="#a81d739eaf1e71ce7a3a309e383ffb50e">More...</a><br /></td></tr>
<tr class="separator:a81d739eaf1e71ce7a3a309e383ffb50e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96254b78dcaaa4a219a450144bd64fe3"><td class="memTemplParams" colspan="2">template&lt;typename NodeTypeList , typename ContainerType  = std::vector&lt;const Node*&gt;&gt; </td></tr>
<tr class="memitem:a96254b78dcaaa4a219a450144bd64fe3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a96254b78dcaaa4a219a450144bd64fe3">collectNodeTypes</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, ContainerType &amp;array)</td></tr>
<tr class="memdesc:a96254b78dcaaa4a219a450144bd64fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Visit all nodes of the given types and store pointers to them in a container of base <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">ast::Node</a> pointers.  <a href="#a96254b78dcaaa4a219a450144bd64fe3">More...</a><br /></td></tr>
<tr class="separator:a96254b78dcaaa4a219a450144bd64fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc6899364be1e443aab9869bf59fc4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a4bc6899364be1e443aab9869bf59fc4c">linearize</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, std::vector&lt; const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> * &gt; &amp;list)</td></tr>
<tr class="memdesc:a4bc6899364be1e443aab9869bf59fc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flatten the provided AST branch into a linear list using post order traversal.  <a href="#a4bc6899364be1e443aab9869bf59fc4c">More...</a><br /></td></tr>
<tr class="separator:a4bc6899364be1e443aab9869bf59fc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae790e499d837ff7a386165db4a3696ff"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#ae790e499d837ff7a386165db4a3696ff">firstUse</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const std::string &amp;token)</td></tr>
<tr class="separator:ae790e499d837ff7a386165db4a3696ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67813ef42960349734b89decdc2b61f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#ab67813ef42960349734b89decdc2b61f">lastUse</a> (const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;node, const std::string &amp;token)</td></tr>
<tr class="separator:ab67813ef42960349734b89decdc2b61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ab021a6561f0414c71960db971dd1a911"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_1::ax::ast::attributeDependencyTokens </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Tree.html">ast::Tree</a> &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>dependencies</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate a list of attribute names which the given attribute depends on. </p>

</div>
</div>
<a class="anchor" id="a3d0c3274f88def6ab65a85d933a6691e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openvdb::v8_1::ax::ast::callsFunction </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not a given branch of an AST calls a function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The AST to analyze </td></tr>
    <tr><td class="paramname">name</td><td>the name of the function to search for </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee3a19b18c2f35bbcb3804b144add645"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_1::ax::ast::catalogueAttributeTokens </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>readOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>writeOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>readWrite</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse all attributes into three unique vectors which represent how they are accessed within the syntax tree. Read only attributes are stored within the 'readOnly' container (for example. </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> a=@a; </div></div><!-- fragment --><p>), write only attributes in the 'writeOnly' container</p><div class="fragment"><div class="line">@a=1; </div></div><!-- fragment --><p> and readWrite attributes in the 'readWrite' container</p><div class="fragment"><div class="line">@a+=1; </div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>Note that the code generator is able to do this far more efficiently, however this provides simple front-end support for detecting these types of operations</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The AST to analyze </td></tr>
    <tr><td class="paramname">readOnly</td><td>The unique list of attributes which are only read from </td></tr>
    <tr><td class="paramname">writeOnly</td><td>The unique list of attributes which are only written too </td></tr>
    <tr><td class="paramname">readWrite</td><td>The unique list of attributes which both read from and written too </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6425986c3d4839cee263bb92049cf859"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_1::ax::ast::catalogueVariables </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>readOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>writeOnly</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>readWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>locals</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>attributes</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>todo </p>

</div>
</div>
<a class="anchor" id="a81d739eaf1e71ce7a3a309e383ffb50e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void collectNodeType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Visit all nodes of a given type and store pointers to them in a provided compatible container. </p>

</div>
</div>
<a class="anchor" id="a96254b78dcaaa4a219a450144bd64fe3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void collectNodeTypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ContainerType &amp;&#160;</td>
          <td class="paramname"><em>array</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Visit all nodes of the given types and store pointers to them in a container of base <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">ast::Node</a> pointers. </p>
<dl class="section note"><dt>Note</dt><dd>NodeTypeList is expected to be a an openvdb::TypeList object with a list of node types. For example, to collect all <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Attribute.html" title="Attributes represent any access to a primitive value, typically associated with the &#39;@&#39; symbol syntax...">Attribute</a> and External <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html" title="Variables are a base type for Locals, Attributes and ExternalVariables. Unlike other abstract types...">Variable</a> ast Nodes:</dd></dl>
<p>using ListT = openvdb::TypeList&lt;ast::Attribute, ast::ExternalVariable&gt;; std::vector&lt;const ast::Node*&gt; nodes; ast::collectNodeTypes&lt;ListT&gt;(tree, nodes); </p>

</div>
</div>
<a class="anchor" id="ae790e499d837ff7a386165db4a3696ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a>* openvdb::v8_1::ax::ast::firstUse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab67813ef42960349734b89decdc2b61f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Variable.html">ast::Variable</a>* openvdb::v8_1::ax::ast::lastUse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>token</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4bc6899364be1e443aab9869bf59fc4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_1::ax::ast::linearize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flatten the provided AST branch into a linear list using post order traversal. </p>

</div>
</div>
<a class="anchor" id="a6877e7f64c16f6c0ca882f390f73b4cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">openvdb::ax::ast::Tree::ConstPtr openvdb::v8_1::ax::ast::parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>code</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1ax_1_1Logger.html">ax::Logger</a> &amp;&#160;</td>
          <td class="paramname"><em>logger</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an abstract syntax tree from a code snippet. If the code is not well formed, as defined by the AX grammar, this will simply return nullptr, with the logger collecting the errors. </p>
<dl class="section note"><dt>Note</dt><dd>The returned AST is const as the logger uses this to determine line and column numbers of errors/warnings in later stages. If you need to modify the tree, take a copy.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a valid const AST, or nullptr if errored.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The code to parse </td></tr>
    <tr><td class="paramname">logger</td><td>The logger to collect syntax errors </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2491bde6ba71abbbf4dfa96e2bf98a76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">openvdb::ax::ast::Tree::Ptr parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an abstract syntax tree from a code snippet. A runtime exception will be thrown with the first syntax error. </p>
<dl class="section return"><dt>Returns</dt><dd>A shared pointer to a valid AST.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The code to parse </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a776b0b1a1fe663a634b62f53a91766f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_1::ax::ast::print </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>numberStatements</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>indent</em> = <code>&quot;&#160;&#160;&#160;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a descriptive printout of a <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a> hierarchy into a target stream. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a> to print </td></tr>
    <tr><td class="paramname">numberStatements</td><td>Whether to number the line statements </td></tr>
    <tr><td class="paramname">os</td><td>Stream to write into </td></tr>
    <tr><td class="paramname">indent</td><td>The indent to print on each child traversal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa69a3568ba75da96af6535faf109ebd3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void openvdb::v8_1::ax::ast::reprint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>indent</em> = <code>&quot;&#160;&#160;&#160;&#160;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Using the provided AST, print corresponding AX code which may have been used to create it. </p>
<dl class="section note"><dt>Note</dt><dd>The result is not guaranteed to be exactly equal to the code that was original parsed. A few potential key differences worth mentioning include whitespace matching, component indexing and inferred attribute types. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td><a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html" title="The base abstract node which determines the interface and required methods for all derived concrete n...">Node</a> to print </td></tr>
    <tr><td class="paramname">os</td><td>Stream to write into </td></tr>
    <tr><td class="paramname">indent</td><td>The indent to print on each child traversal </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a128aa4e72eec8d8799386d401b47df3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openvdb::v8_1::ax::ast::usesAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7a6ce26a62afab55d7606ad4e92428b30c">tokens::UNKNOWN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not a given branch of an AST reads from or writes to a given attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The AST to analyze </td></tr>
    <tr><td class="paramname">name</td><td>the name of the attribute to search for </td></tr>
    <tr><td class="paramname">type</td><td>the type of the attribute to search for. If UNKNOWN, any attribute with the given name is checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adc7a0b3fe55c85fa98c9dd7ae46d9daa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visitNodeType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OpT &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>For an AST node of a given type, search for and call a custom const operator() which takes a const reference to every occurrence of the specified node type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The AST to run over </td></tr>
    <tr><td class="paramname">op</td><td>The operator to call on every found AST node of type NodeT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7d215b506bde4d714b93e8569ba922f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool openvdb::v8_1::ax::ast::writesToAttribute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structopenvdb_1_1v8__1_1_1ax_1_1ast_1_1Node.html">ast::Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7">tokens::CoreType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast_1_1tokens.html#ae857f6f64ff599622ca80279d28242b7a6ce26a62afab55d7606ad4e92428b30c">tokens::UNKNOWN</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns whether or not a given branch of an AST writes to a given attribute. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The AST to analyze </td></tr>
    <tr><td class="paramname">name</td><td>the name of the attribute to search for </td></tr>
    <tr><td class="paramname">type</td><td>the type of the attribute to search for. If UNKNOWN, the first attribute encountered with the given name is checked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
