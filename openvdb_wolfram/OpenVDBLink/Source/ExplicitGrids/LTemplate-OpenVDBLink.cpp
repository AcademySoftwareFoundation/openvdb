/*  This file was automatically generated by LTemplate. DO NOT EDIT.  */
/*  https://github.com/szhorvat/LTemplate  */

#define LTEMPLATE_MMA_VERSION  1310

#include "LTemplate.h"
#include "LTemplateHelpers.h"
#include "OpenVDBDoubleGrid.h"
#include "OpenVDBFloatGrid.h"
#include "OpenVDBByteGrid.h"
#include "OpenVDBInt32Grid.h"
#include "OpenVDBInt64Grid.h"
#include "OpenVDBUInt32Grid.h"
#include "OpenVDBVec2DGrid.h"
#include "OpenVDBVec2IGrid.h"
#include "OpenVDBVec2SGrid.h"
#include "OpenVDBVec3DGrid.h"
#include "OpenVDBVec3IGrid.h"
#include "OpenVDBVec3SGrid.h"
#include "OpenVDBBoolGrid.h"
#include "OpenVDBMaskGrid.h"


#define LTEMPLATE_MESSAGE_SYMBOL  "OpenVDBLink`OpenVDBLink"

#include "LTemplate.inc"


std::map<mint, OpenVDBDoubleGrid *> OpenVDBDoubleGrid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBDoubleGrid *> & getCollection<OpenVDBDoubleGrid>()
    {
        return OpenVDBDoubleGrid_collection;
    }
}

void OpenVDBDoubleGrid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBDoubleGrid_collection[id] = new OpenVDBDoubleGrid();
    } else {  // destroy
        if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBDoubleGrid_collection[id];
        OpenVDBDoubleGrid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBDoubleGrid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBDoubleGrid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBFloatGrid *> OpenVDBFloatGrid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBFloatGrid *> & getCollection<OpenVDBFloatGrid>()
    {
        return OpenVDBFloatGrid_collection;
    }
}

void OpenVDBFloatGrid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBFloatGrid_collection[id] = new OpenVDBFloatGrid();
    } else {  // destroy
        if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBFloatGrid_collection[id];
        OpenVDBFloatGrid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBFloatGrid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBFloatGrid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBByteGrid *> OpenVDBByteGrid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBByteGrid *> & getCollection<OpenVDBByteGrid>()
    {
        return OpenVDBByteGrid_collection;
    }
}

void OpenVDBByteGrid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBByteGrid_collection[id] = new OpenVDBByteGrid();
    } else {  // destroy
        if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBByteGrid_collection[id];
        OpenVDBByteGrid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBByteGrid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBByteGrid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBInt32Grid *> OpenVDBInt32Grid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBInt32Grid *> & getCollection<OpenVDBInt32Grid>()
    {
        return OpenVDBInt32Grid_collection;
    }
}

void OpenVDBInt32Grid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBInt32Grid_collection[id] = new OpenVDBInt32Grid();
    } else {  // destroy
        if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBInt32Grid_collection[id];
        OpenVDBInt32Grid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBInt32Grid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBInt32Grid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBInt64Grid *> OpenVDBInt64Grid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBInt64Grid *> & getCollection<OpenVDBInt64Grid>()
    {
        return OpenVDBInt64Grid_collection;
    }
}

void OpenVDBInt64Grid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBInt64Grid_collection[id] = new OpenVDBInt64Grid();
    } else {  // destroy
        if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBInt64Grid_collection[id];
        OpenVDBInt64Grid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBInt64Grid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBInt64Grid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBUInt32Grid *> OpenVDBUInt32Grid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBUInt32Grid *> & getCollection<OpenVDBUInt32Grid>()
    {
        return OpenVDBUInt32Grid_collection;
    }
}

void OpenVDBUInt32Grid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBUInt32Grid_collection[id] = new OpenVDBUInt32Grid();
    } else {  // destroy
        if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBUInt32Grid_collection[id];
        OpenVDBUInt32Grid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBUInt32Grid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBUInt32Grid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBVec2DGrid *> OpenVDBVec2DGrid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBVec2DGrid *> & getCollection<OpenVDBVec2DGrid>()
    {
        return OpenVDBVec2DGrid_collection;
    }
}

void OpenVDBVec2DGrid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBVec2DGrid_collection[id] = new OpenVDBVec2DGrid();
    } else {  // destroy
        if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBVec2DGrid_collection[id];
        OpenVDBVec2DGrid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBVec2DGrid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBVec2DGrid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBVec2IGrid *> OpenVDBVec2IGrid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBVec2IGrid *> & getCollection<OpenVDBVec2IGrid>()
    {
        return OpenVDBVec2IGrid_collection;
    }
}

void OpenVDBVec2IGrid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBVec2IGrid_collection[id] = new OpenVDBVec2IGrid();
    } else {  // destroy
        if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBVec2IGrid_collection[id];
        OpenVDBVec2IGrid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBVec2IGrid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBVec2IGrid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBVec2SGrid *> OpenVDBVec2SGrid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBVec2SGrid *> & getCollection<OpenVDBVec2SGrid>()
    {
        return OpenVDBVec2SGrid_collection;
    }
}

void OpenVDBVec2SGrid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBVec2SGrid_collection[id] = new OpenVDBVec2SGrid();
    } else {  // destroy
        if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBVec2SGrid_collection[id];
        OpenVDBVec2SGrid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBVec2SGrid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBVec2SGrid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBVec3DGrid *> OpenVDBVec3DGrid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBVec3DGrid *> & getCollection<OpenVDBVec3DGrid>()
    {
        return OpenVDBVec3DGrid_collection;
    }
}

void OpenVDBVec3DGrid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBVec3DGrid_collection[id] = new OpenVDBVec3DGrid();
    } else {  // destroy
        if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBVec3DGrid_collection[id];
        OpenVDBVec3DGrid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBVec3DGrid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBVec3DGrid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBVec3IGrid *> OpenVDBVec3IGrid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBVec3IGrid *> & getCollection<OpenVDBVec3IGrid>()
    {
        return OpenVDBVec3IGrid_collection;
    }
}

void OpenVDBVec3IGrid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBVec3IGrid_collection[id] = new OpenVDBVec3IGrid();
    } else {  // destroy
        if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBVec3IGrid_collection[id];
        OpenVDBVec3IGrid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBVec3IGrid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBVec3IGrid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBVec3SGrid *> OpenVDBVec3SGrid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBVec3SGrid *> & getCollection<OpenVDBVec3SGrid>()
    {
        return OpenVDBVec3SGrid_collection;
    }
}

void OpenVDBVec3SGrid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBVec3SGrid_collection[id] = new OpenVDBVec3SGrid();
    } else {  // destroy
        if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBVec3SGrid_collection[id];
        OpenVDBVec3SGrid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBVec3SGrid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBVec3SGrid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBBoolGrid *> OpenVDBBoolGrid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBBoolGrid *> & getCollection<OpenVDBBoolGrid>()
    {
        return OpenVDBBoolGrid_collection;
    }
}

void OpenVDBBoolGrid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBBoolGrid_collection[id] = new OpenVDBBoolGrid();
    } else {  // destroy
        if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBBoolGrid_collection[id];
        OpenVDBBoolGrid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBBoolGrid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBBoolGrid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


std::map<mint, OpenVDBMaskGrid *> OpenVDBMaskGrid_collection;

namespace mma
{
    template<> const std::map<mint, OpenVDBMaskGrid *> & getCollection<OpenVDBMaskGrid>()
    {
        return OpenVDBMaskGrid_collection;
    }
}

void OpenVDBMaskGrid_manager_fun(WolframLibraryData libData, mbool mode, mint id)
{
    if (mode == 0) { // create
        OpenVDBMaskGrid_collection[id] = new OpenVDBMaskGrid();
    } else {  // destroy
        if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) {
            libData->Message("noinst");
            return;
        }
        delete OpenVDBMaskGrid_collection[id];
        OpenVDBMaskGrid_collection.erase(id);
    }
}

extern "C" DLLEXPORT int OpenVDBMaskGrid_get_collection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::TensorRef<mint> res = mma::detail::get_collection(OpenVDBMaskGrid_collection);
    mma::detail::setTensor<mint>(Res, res);
    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT mint WolframLibrary_getVersion()
{
    return WolframLibraryVersion;
}

extern "C" DLLEXPORT int WolframLibrary_initialize(WolframLibraryData libData)
{
    mma::libData = libData;
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBDoubleGrid", OpenVDBDoubleGrid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBFloatGrid", OpenVDBFloatGrid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBByteGrid", OpenVDBByteGrid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBInt32Grid", OpenVDBInt32Grid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBInt64Grid", OpenVDBInt64Grid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBUInt32Grid", OpenVDBUInt32Grid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBVec2DGrid", OpenVDBVec2DGrid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBVec2IGrid", OpenVDBVec2IGrid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBVec2SGrid", OpenVDBVec2SGrid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBVec3DGrid", OpenVDBVec3DGrid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBVec3IGrid", OpenVDBVec3IGrid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBVec3SGrid", OpenVDBVec3SGrid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBBoolGrid", OpenVDBBoolGrid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    {
        int err;
        err = (*libData->registerLibraryExpressionManager)("OpenVDBMaskGrid", OpenVDBMaskGrid_manager_fun);
        if (err != LIBRARY_NO_ERROR) return err;
    }
    return LIBRARY_NO_ERROR;
}

extern "C" DLLEXPORT void WolframLibrary_uninitialize(WolframLibraryData libData)
{
    (*libData->unregisterLibraryExpressionManager)("OpenVDBDoubleGrid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBFloatGrid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBByteGrid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBInt32Grid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBInt64Grid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBUInt32Grid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBVec2DGrid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBVec2IGrid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBVec2SGrid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBVec3DGrid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBVec3IGrid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBVec3SGrid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBBoolGrid");
    (*libData->unregisterLibraryExpressionManager)("OpenVDBMaskGrid");
    return;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBDoubleGrid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBDoubleGrid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBDoubleGrid & var1 = mma::detail::getObject<OpenVDBDoubleGrid>(OpenVDBDoubleGrid_collection)(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBDoubleGrid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBDoubleGrid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBDoubleGrid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBDoubleGrid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBDoubleGrid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBDoubleGrid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBDoubleGrid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBDoubleGrid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBDoubleGrid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBDoubleGrid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBDoubleGrid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBDoubleGrid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBDoubleGrid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBDoubleGrid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBDoubleGrid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBDoubleGrid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBDoubleGrid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBDoubleGrid & var1 = mma::detail::getObject<OpenVDBDoubleGrid>(OpenVDBDoubleGrid_collection)(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBDoubleGrid & var1 = mma::detail::getObject<OpenVDBDoubleGrid>(OpenVDBDoubleGrid_collection)(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBDoubleGrid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBDoubleGrid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBDoubleGrid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBDoubleGrid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBDoubleGrid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBDoubleGrid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBDoubleGrid & var1 = mma::detail::getObject<OpenVDBDoubleGrid>(OpenVDBDoubleGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBDoubleGrid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBDoubleGrid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBDoubleGrid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBDoubleGrid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_depthMap(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        double var4 = MArgument_getReal(Args[4]);

        mma::ImageRef<mma::im_real32_t> res = (OpenVDBDoubleGrid_collection[id])->depthMap(var1, var2, var3, var4);
        mma::detail::setImage<mma::im_real32_t>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::depthMap()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::depthMap()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridSliceImage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::GenericImageRef res = (OpenVDBDoubleGrid_collection[id])->gridSliceImage(var1, var2, var3, var4);
        mma::detail::setGenericImage(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridSliceImage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridSliceImage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridImage3D(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::GenericImage3DRef res = (OpenVDBDoubleGrid_collection[id])->gridImage3D(var1);
        mma::detail::setGenericImage3D(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridImage3D()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridImage3D()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);

        (OpenVDBDoubleGrid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBDoubleGrid_collection[id])->getBackgroundValue();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> res = (OpenVDBDoubleGrid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBDoubleGrid_collection[id])->getValues(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_sliceVoxelValueTotals(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<double> res = (OpenVDBDoubleGrid_collection[id])->sliceVoxelValueTotals(var1, var2);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBDoubleGrid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<double> res = (OpenVDBDoubleGrid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBDoubleGrid_collection[id])->gridData(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_getHalfwidth(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBDoubleGrid_collection[id])->getHalfwidth();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::getHalfwidth()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::getHalfwidth()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridUnion(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBDoubleGrid & var1 = mma::detail::getObject<OpenVDBDoubleGrid>(OpenVDBDoubleGrid_collection)(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->gridUnion(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridUnion()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridUnion()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridIntersection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBDoubleGrid & var1 = mma::detail::getObject<OpenVDBDoubleGrid>(OpenVDBDoubleGrid_collection)(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->gridIntersection(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridIntersection()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridIntersection()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridDifference(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBDoubleGrid & var1 = mma::detail::getObject<OpenVDBDoubleGrid>(OpenVDBDoubleGrid_collection)(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->gridDifference(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridDifference()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridDifference()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridUnionCopy(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->gridUnionCopy(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridUnionCopy()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridUnionCopy()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridIntersectionCopy(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->gridIntersectionCopy(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridIntersectionCopy()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridIntersectionCopy()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridDifferenceCopy(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBDoubleGrid & var1 = mma::detail::getObject<OpenVDBDoubleGrid>(OpenVDBDoubleGrid_collection)(Args[1]);
        OpenVDBDoubleGrid & var2 = mma::detail::getObject<OpenVDBDoubleGrid>(OpenVDBDoubleGrid_collection)(Args[2]);

        (OpenVDBDoubleGrid_collection[id])->gridDifferenceCopy(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridDifferenceCopy()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridDifferenceCopy()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_clipGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBDoubleGrid & var1 = mma::detail::getObject<OpenVDBDoubleGrid>(OpenVDBDoubleGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);

        (OpenVDBDoubleGrid_collection[id])->clipGrid(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::clipGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::clipGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_ballLevelSet(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        double var4 = MArgument_getReal(Args[4]);
        bool var5 = MArgument_getBoolean(Args[5]);

        (OpenVDBDoubleGrid_collection[id])->ballLevelSet(var1, var2, var3, var4, var5);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::ballLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::ballLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_cuboidLevelSet(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        (OpenVDBDoubleGrid_collection[id])->cuboidLevelSet(var1, var2, var3, var4);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::cuboidLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::cuboidLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_meshLevelSet(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        double var4 = MArgument_getReal(Args[4]);
        bool var5 = MArgument_getBoolean(Args[5]);

        (OpenVDBDoubleGrid_collection[id])->meshLevelSet(var1, var2, var3, var4, var5);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::meshLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::meshLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_offsetSurfaceLevelSet(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        double var4 = MArgument_getReal(Args[4]);
        double var5 = MArgument_getReal(Args[5]);
        bool var6 = MArgument_getBoolean(Args[6]);

        (OpenVDBDoubleGrid_collection[id])->offsetSurfaceLevelSet(var1, var2, var3, var4, var5, var6);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::offsetSurfaceLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::offsetSurfaceLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_levelSetGridArea(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBDoubleGrid_collection[id])->levelSetGridArea();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::levelSetGridArea()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::levelSetGridArea()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_levelSetGridEulerCharacteristic(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBDoubleGrid_collection[id])->levelSetGridEulerCharacteristic();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::levelSetGridEulerCharacteristic()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::levelSetGridEulerCharacteristic()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_levelSetGridGenus(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBDoubleGrid_collection[id])->levelSetGridGenus();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::levelSetGridGenus()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::levelSetGridGenus()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_levelSetGridVolume(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBDoubleGrid_collection[id])->levelSetGridVolume();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::levelSetGridVolume()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::levelSetGridVolume()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridMember(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBDoubleGrid_collection[id])->gridMember(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridMember()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridMember()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridNearest(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);

        mma::TensorRef<double> res = (OpenVDBDoubleGrid_collection[id])->gridNearest(var1, var2);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridNearest()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridNearest()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridDistance(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);

        mma::TensorRef<double> res = (OpenVDBDoubleGrid_collection[id])->gridDistance(var1, var2);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridDistance()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridDistance()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gridSignedDistance(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);

        mma::TensorRef<double> res = (OpenVDBDoubleGrid_collection[id])->gridSignedDistance(var1, var2);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gridSignedDistance()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gridSignedDistance()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_fillWithBalls(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        double var4 = MArgument_getReal(Args[4]);
        double var5 = MArgument_getReal(Args[5]);
        double var6 = MArgument_getReal(Args[6]);
        mint var7 = MArgument_getInteger(Args[7]);

        mma::TensorRef<double> res = (OpenVDBDoubleGrid_collection[id])->fillWithBalls(var1, var2, var3, var4, var5, var6, var7);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::fillWithBalls()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::fillWithBalls()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_filterGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBDoubleGrid_collection[id])->filterGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::filterGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::filterGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_meshCellCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);

        mma::TensorRef<mint> res = (OpenVDBDoubleGrid_collection[id])->meshCellCount(var1, var2, var3);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::meshCellCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::meshCellCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_meshData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);

        mma::TensorRef<double> res = (OpenVDBDoubleGrid_collection[id])->meshData(var1, var2, var3);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::meshData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::meshData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_levelSetToFogVolume(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->levelSetToFogVolume(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::levelSetToFogVolume()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::levelSetToFogVolume()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_scalarMultiply(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->scalarMultiply(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::scalarMultiply()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::scalarMultiply()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_gammaAdjustment(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->gammaAdjustment(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::gammaAdjustment()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::gammaAdjustment()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_resizeBandwidth(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->resizeBandwidth(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::resizeBandwidth()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::resizeBandwidth()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_offsetLevelSet(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBDoubleGrid_collection[id])->offsetLevelSet(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::offsetLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::offsetLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_renderGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mma::TensorRef<double> var3 = mma::detail::getTensor<double>(Args[3]);
        mma::TensorRef<double> var4 = mma::detail::getTensor<double>(Args[4]);
        mma::TensorRef<double> var5 = mma::detail::getTensor<double>(Args[5]);
        mma::TensorRef<double> var6 = mma::detail::getTensor<double>(Args[6]);
        mma::TensorRef<double> var7 = mma::detail::getTensor<double>(Args[7]);
        mma::TensorRef<double> var8 = mma::detail::getTensor<double>(Args[8]);
        mma::TensorRef<double> var9 = mma::detail::getTensor<double>(Args[9]);
        mma::TensorRef<double> var10 = mma::detail::getTensor<double>(Args[10]);
        mint var11 = MArgument_getInteger(Args[11]);
        mint var12 = MArgument_getInteger(Args[12]);
        mint var13 = MArgument_getInteger(Args[13]);
        mma::TensorRef<mint> var14 = mma::detail::getTensor<mint>(Args[14]);
        double var15 = MArgument_getReal(Args[15]);
        mma::TensorRef<double> var16 = mma::detail::getTensor<double>(Args[16]);
        mma::TensorRef<double> var17 = mma::detail::getTensor<double>(Args[17]);
        mma::TensorRef<double> var18 = mma::detail::getTensor<double>(Args[18]);
        bool var19 = MArgument_getBoolean(Args[19]);

        mma::ImageRef<mma::im_byte_t> res = (OpenVDBDoubleGrid_collection[id])->renderGrid(var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, var11, var12, var13, var14, var15, var16, var17, var18, var19);
        mma::detail::setImage<mma::im_byte_t>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::renderGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::renderGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_renderGridPBR(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mma::TensorRef<double> var3 = mma::detail::getTensor<double>(Args[3]);
        mma::TensorRef<double> var4 = mma::detail::getTensor<double>(Args[4]);
        mma::TensorRef<double> var5 = mma::detail::getTensor<double>(Args[5]);
        mma::TensorRef<double> var6 = mma::detail::getTensor<double>(Args[6]);
        mma::TensorRef<double> var7 = mma::detail::getTensor<double>(Args[7]);
        mint var8 = MArgument_getInteger(Args[8]);
        mint var9 = MArgument_getInteger(Args[9]);
        mma::TensorRef<mint> var10 = mma::detail::getTensor<mint>(Args[10]);
        double var11 = MArgument_getReal(Args[11]);
        bool var12 = MArgument_getBoolean(Args[12]);
        mma::TensorRef<double> var13 = mma::detail::getTensor<double>(Args[13]);
        mma::TensorRef<double> var14 = mma::detail::getTensor<double>(Args[14]);
        mma::TensorRef<double> var15 = mma::detail::getTensor<double>(Args[15]);
        double var16 = MArgument_getReal(Args[16]);
        double var17 = MArgument_getReal(Args[17]);
        double var18 = MArgument_getReal(Args[18]);
        double var19 = MArgument_getReal(Args[19]);
        mma::TensorRef<double> var20 = mma::detail::getTensor<double>(Args[20]);
        double var21 = MArgument_getReal(Args[21]);
        double var22 = MArgument_getReal(Args[22]);
        double var23 = MArgument_getReal(Args[23]);
        double var24 = MArgument_getReal(Args[24]);
        double var25 = MArgument_getReal(Args[25]);
        double var26 = MArgument_getReal(Args[26]);

        mma::ImageRef<mma::im_byte_t> res = (OpenVDBDoubleGrid_collection[id])->renderGridPBR(var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, var11, var12, var13, var14, var15, var16, var17, var18, var19, var20, var21, var22, var23, var24, var25, var26);
        mma::detail::setImage<mma::im_byte_t>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::renderGridPBR()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::renderGridPBR()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBDoubleGrid_activeVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBDoubleGrid_collection.find(id) == OpenVDBDoubleGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::SparseArrayRef<double> res = (OpenVDBDoubleGrid_collection[id])->activeVoxels(var1);
        mma::detail::setSparseArray<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBDoubleGrid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBDoubleGrid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBFloatGrid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBFloatGrid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBFloatGrid & var1 = mma::detail::getObject<OpenVDBFloatGrid>(OpenVDBFloatGrid_collection)(Args[1]);

        (OpenVDBFloatGrid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBFloatGrid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBFloatGrid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBFloatGrid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBFloatGrid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBFloatGrid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBFloatGrid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBFloatGrid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBFloatGrid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBFloatGrid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBFloatGrid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBFloatGrid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBFloatGrid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBFloatGrid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBFloatGrid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBFloatGrid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBFloatGrid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBFloatGrid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBFloatGrid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBFloatGrid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBFloatGrid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBFloatGrid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBFloatGrid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBFloatGrid & var1 = mma::detail::getObject<OpenVDBFloatGrid>(OpenVDBFloatGrid_collection)(Args[1]);

        (OpenVDBFloatGrid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBFloatGrid & var1 = mma::detail::getObject<OpenVDBFloatGrid>(OpenVDBFloatGrid_collection)(Args[1]);

        (OpenVDBFloatGrid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBFloatGrid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBFloatGrid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBFloatGrid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBFloatGrid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBFloatGrid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBFloatGrid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBFloatGrid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBFloatGrid & var1 = mma::detail::getObject<OpenVDBFloatGrid>(OpenVDBFloatGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBFloatGrid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBFloatGrid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBFloatGrid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBFloatGrid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_depthMap(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        double var4 = MArgument_getReal(Args[4]);

        mma::ImageRef<mma::im_real32_t> res = (OpenVDBFloatGrid_collection[id])->depthMap(var1, var2, var3, var4);
        mma::detail::setImage<mma::im_real32_t>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::depthMap()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::depthMap()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridSliceImage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::GenericImageRef res = (OpenVDBFloatGrid_collection[id])->gridSliceImage(var1, var2, var3, var4);
        mma::detail::setGenericImage(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridSliceImage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridSliceImage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridImage3D(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::GenericImage3DRef res = (OpenVDBFloatGrid_collection[id])->gridImage3D(var1);
        mma::detail::setGenericImage3D(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridImage3D()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridImage3D()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBFloatGrid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);

        (OpenVDBFloatGrid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBFloatGrid_collection[id])->getBackgroundValue();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> res = (OpenVDBFloatGrid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBFloatGrid_collection[id])->getValues(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_sliceVoxelValueTotals(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<double> res = (OpenVDBFloatGrid_collection[id])->sliceVoxelValueTotals(var1, var2);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBFloatGrid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<double> res = (OpenVDBFloatGrid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBFloatGrid_collection[id])->gridData(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_getHalfwidth(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBFloatGrid_collection[id])->getHalfwidth();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::getHalfwidth()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::getHalfwidth()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridUnion(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBFloatGrid & var1 = mma::detail::getObject<OpenVDBFloatGrid>(OpenVDBFloatGrid_collection)(Args[1]);

        (OpenVDBFloatGrid_collection[id])->gridUnion(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridUnion()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridUnion()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridIntersection(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBFloatGrid & var1 = mma::detail::getObject<OpenVDBFloatGrid>(OpenVDBFloatGrid_collection)(Args[1]);

        (OpenVDBFloatGrid_collection[id])->gridIntersection(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridIntersection()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridIntersection()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridDifference(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBFloatGrid & var1 = mma::detail::getObject<OpenVDBFloatGrid>(OpenVDBFloatGrid_collection)(Args[1]);

        (OpenVDBFloatGrid_collection[id])->gridDifference(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridDifference()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridDifference()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridUnionCopy(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        (OpenVDBFloatGrid_collection[id])->gridUnionCopy(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridUnionCopy()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridUnionCopy()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridIntersectionCopy(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        (OpenVDBFloatGrid_collection[id])->gridIntersectionCopy(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridIntersectionCopy()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridIntersectionCopy()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridDifferenceCopy(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBFloatGrid & var1 = mma::detail::getObject<OpenVDBFloatGrid>(OpenVDBFloatGrid_collection)(Args[1]);
        OpenVDBFloatGrid & var2 = mma::detail::getObject<OpenVDBFloatGrid>(OpenVDBFloatGrid_collection)(Args[2]);

        (OpenVDBFloatGrid_collection[id])->gridDifferenceCopy(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridDifferenceCopy()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridDifferenceCopy()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_clipGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBFloatGrid & var1 = mma::detail::getObject<OpenVDBFloatGrid>(OpenVDBFloatGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);

        (OpenVDBFloatGrid_collection[id])->clipGrid(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::clipGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::clipGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_ballLevelSet(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        double var4 = MArgument_getReal(Args[4]);
        bool var5 = MArgument_getBoolean(Args[5]);

        (OpenVDBFloatGrid_collection[id])->ballLevelSet(var1, var2, var3, var4, var5);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::ballLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::ballLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_cuboidLevelSet(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        (OpenVDBFloatGrid_collection[id])->cuboidLevelSet(var1, var2, var3, var4);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::cuboidLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::cuboidLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_meshLevelSet(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        double var4 = MArgument_getReal(Args[4]);
        bool var5 = MArgument_getBoolean(Args[5]);

        (OpenVDBFloatGrid_collection[id])->meshLevelSet(var1, var2, var3, var4, var5);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::meshLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::meshLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_offsetSurfaceLevelSet(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        double var4 = MArgument_getReal(Args[4]);
        double var5 = MArgument_getReal(Args[5]);
        bool var6 = MArgument_getBoolean(Args[6]);

        (OpenVDBFloatGrid_collection[id])->offsetSurfaceLevelSet(var1, var2, var3, var4, var5, var6);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::offsetSurfaceLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::offsetSurfaceLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_levelSetGridArea(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBFloatGrid_collection[id])->levelSetGridArea();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::levelSetGridArea()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::levelSetGridArea()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_levelSetGridEulerCharacteristic(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBFloatGrid_collection[id])->levelSetGridEulerCharacteristic();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::levelSetGridEulerCharacteristic()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::levelSetGridEulerCharacteristic()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_levelSetGridGenus(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBFloatGrid_collection[id])->levelSetGridGenus();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::levelSetGridGenus()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::levelSetGridGenus()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_levelSetGridVolume(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBFloatGrid_collection[id])->levelSetGridVolume();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::levelSetGridVolume()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::levelSetGridVolume()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridMember(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBFloatGrid_collection[id])->gridMember(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridMember()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridMember()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridNearest(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);

        mma::TensorRef<double> res = (OpenVDBFloatGrid_collection[id])->gridNearest(var1, var2);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridNearest()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridNearest()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridDistance(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);

        mma::TensorRef<double> res = (OpenVDBFloatGrid_collection[id])->gridDistance(var1, var2);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridDistance()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridDistance()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gridSignedDistance(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);

        mma::TensorRef<double> res = (OpenVDBFloatGrid_collection[id])->gridSignedDistance(var1, var2);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gridSignedDistance()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gridSignedDistance()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_fillWithBalls(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        double var4 = MArgument_getReal(Args[4]);
        double var5 = MArgument_getReal(Args[5]);
        double var6 = MArgument_getReal(Args[6]);
        mint var7 = MArgument_getInteger(Args[7]);

        mma::TensorRef<double> res = (OpenVDBFloatGrid_collection[id])->fillWithBalls(var1, var2, var3, var4, var5, var6, var7);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::fillWithBalls()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::fillWithBalls()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_filterGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBFloatGrid_collection[id])->filterGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::filterGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::filterGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_meshCellCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);

        mma::TensorRef<mint> res = (OpenVDBFloatGrid_collection[id])->meshCellCount(var1, var2, var3);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::meshCellCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::meshCellCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_meshData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);

        mma::TensorRef<double> res = (OpenVDBFloatGrid_collection[id])->meshData(var1, var2, var3);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::meshData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::meshData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_levelSetToFogVolume(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBFloatGrid_collection[id])->levelSetToFogVolume(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::levelSetToFogVolume()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::levelSetToFogVolume()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_scalarMultiply(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBFloatGrid_collection[id])->scalarMultiply(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::scalarMultiply()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::scalarMultiply()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_gammaAdjustment(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBFloatGrid_collection[id])->gammaAdjustment(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::gammaAdjustment()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::gammaAdjustment()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_resizeBandwidth(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBFloatGrid_collection[id])->resizeBandwidth(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::resizeBandwidth()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::resizeBandwidth()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_offsetLevelSet(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBFloatGrid_collection[id])->offsetLevelSet(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::offsetLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::offsetLevelSet()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_renderGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mma::TensorRef<double> var3 = mma::detail::getTensor<double>(Args[3]);
        mma::TensorRef<double> var4 = mma::detail::getTensor<double>(Args[4]);
        mma::TensorRef<double> var5 = mma::detail::getTensor<double>(Args[5]);
        mma::TensorRef<double> var6 = mma::detail::getTensor<double>(Args[6]);
        mma::TensorRef<double> var7 = mma::detail::getTensor<double>(Args[7]);
        mma::TensorRef<double> var8 = mma::detail::getTensor<double>(Args[8]);
        mma::TensorRef<double> var9 = mma::detail::getTensor<double>(Args[9]);
        mma::TensorRef<double> var10 = mma::detail::getTensor<double>(Args[10]);
        mint var11 = MArgument_getInteger(Args[11]);
        mint var12 = MArgument_getInteger(Args[12]);
        mint var13 = MArgument_getInteger(Args[13]);
        mma::TensorRef<mint> var14 = mma::detail::getTensor<mint>(Args[14]);
        double var15 = MArgument_getReal(Args[15]);
        mma::TensorRef<double> var16 = mma::detail::getTensor<double>(Args[16]);
        mma::TensorRef<double> var17 = mma::detail::getTensor<double>(Args[17]);
        mma::TensorRef<double> var18 = mma::detail::getTensor<double>(Args[18]);
        bool var19 = MArgument_getBoolean(Args[19]);

        mma::ImageRef<mma::im_byte_t> res = (OpenVDBFloatGrid_collection[id])->renderGrid(var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, var11, var12, var13, var14, var15, var16, var17, var18, var19);
        mma::detail::setImage<mma::im_byte_t>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::renderGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::renderGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_renderGridPBR(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mma::TensorRef<double> var3 = mma::detail::getTensor<double>(Args[3]);
        mma::TensorRef<double> var4 = mma::detail::getTensor<double>(Args[4]);
        mma::TensorRef<double> var5 = mma::detail::getTensor<double>(Args[5]);
        mma::TensorRef<double> var6 = mma::detail::getTensor<double>(Args[6]);
        mma::TensorRef<double> var7 = mma::detail::getTensor<double>(Args[7]);
        mint var8 = MArgument_getInteger(Args[8]);
        mint var9 = MArgument_getInteger(Args[9]);
        mma::TensorRef<mint> var10 = mma::detail::getTensor<mint>(Args[10]);
        double var11 = MArgument_getReal(Args[11]);
        bool var12 = MArgument_getBoolean(Args[12]);
        mma::TensorRef<double> var13 = mma::detail::getTensor<double>(Args[13]);
        mma::TensorRef<double> var14 = mma::detail::getTensor<double>(Args[14]);
        mma::TensorRef<double> var15 = mma::detail::getTensor<double>(Args[15]);
        double var16 = MArgument_getReal(Args[16]);
        double var17 = MArgument_getReal(Args[17]);
        double var18 = MArgument_getReal(Args[18]);
        double var19 = MArgument_getReal(Args[19]);
        mma::TensorRef<double> var20 = mma::detail::getTensor<double>(Args[20]);
        double var21 = MArgument_getReal(Args[21]);
        double var22 = MArgument_getReal(Args[22]);
        double var23 = MArgument_getReal(Args[23]);
        double var24 = MArgument_getReal(Args[24]);
        double var25 = MArgument_getReal(Args[25]);
        double var26 = MArgument_getReal(Args[26]);

        mma::ImageRef<mma::im_byte_t> res = (OpenVDBFloatGrid_collection[id])->renderGridPBR(var1, var2, var3, var4, var5, var6, var7, var8, var9, var10, var11, var12, var13, var14, var15, var16, var17, var18, var19, var20, var21, var22, var23, var24, var25, var26);
        mma::detail::setImage<mma::im_byte_t>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::renderGridPBR()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::renderGridPBR()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBFloatGrid_activeVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBFloatGrid_collection.find(id) == OpenVDBFloatGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::SparseArrayRef<double> res = (OpenVDBFloatGrid_collection[id])->activeVoxels(var1);
        mma::detail::setSparseArray<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBFloatGrid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBFloatGrid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBByteGrid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBByteGrid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBByteGrid & var1 = mma::detail::getObject<OpenVDBByteGrid>(OpenVDBByteGrid_collection)(Args[1]);

        (OpenVDBByteGrid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBByteGrid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBByteGrid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBByteGrid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBByteGrid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBByteGrid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBByteGrid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBByteGrid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBByteGrid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBByteGrid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBByteGrid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBByteGrid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBByteGrid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBByteGrid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBByteGrid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBByteGrid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBByteGrid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBByteGrid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBByteGrid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBByteGrid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBByteGrid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBByteGrid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBByteGrid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBByteGrid & var1 = mma::detail::getObject<OpenVDBByteGrid>(OpenVDBByteGrid_collection)(Args[1]);

        (OpenVDBByteGrid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBByteGrid & var1 = mma::detail::getObject<OpenVDBByteGrid>(OpenVDBByteGrid_collection)(Args[1]);

        (OpenVDBByteGrid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBByteGrid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBByteGrid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBByteGrid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBByteGrid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBByteGrid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBByteGrid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBByteGrid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBByteGrid & var1 = mma::detail::getObject<OpenVDBByteGrid>(OpenVDBByteGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBByteGrid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBByteGrid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBByteGrid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBByteGrid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_depthMap(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        double var4 = MArgument_getReal(Args[4]);

        mma::ImageRef<mma::im_real32_t> res = (OpenVDBByteGrid_collection[id])->depthMap(var1, var2, var3, var4);
        mma::detail::setImage<mma::im_real32_t>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::depthMap()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::depthMap()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_gridSliceImage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::GenericImageRef res = (OpenVDBByteGrid_collection[id])->gridSliceImage(var1, var2, var3, var4);
        mma::detail::setGenericImage(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::gridSliceImage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::gridSliceImage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_gridImage3D(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::GenericImage3DRef res = (OpenVDBByteGrid_collection[id])->gridImage3D(var1);
        mma::detail::setGenericImage3D(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::gridImage3D()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::gridImage3D()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBByteGrid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBByteGrid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBByteGrid_collection[id])->getBackgroundValue();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBByteGrid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBByteGrid_collection[id])->getValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_sliceVoxelValueTotals(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBByteGrid_collection[id])->sliceVoxelValueTotals(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBByteGrid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<mint> res = (OpenVDBByteGrid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBByteGrid_collection[id])->gridData(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBByteGrid_activeVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBByteGrid_collection.find(id) == OpenVDBByteGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::SparseArrayRef<mint> res = (OpenVDBByteGrid_collection[id])->activeVoxels(var1);
        mma::detail::setSparseArray<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBByteGrid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBByteGrid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBInt32Grid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBInt32Grid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBInt32Grid & var1 = mma::detail::getObject<OpenVDBInt32Grid>(OpenVDBInt32Grid_collection)(Args[1]);

        (OpenVDBInt32Grid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBInt32Grid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBInt32Grid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBInt32Grid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBInt32Grid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBInt32Grid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBInt32Grid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBInt32Grid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBInt32Grid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBInt32Grid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBInt32Grid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBInt32Grid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBInt32Grid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBInt32Grid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBInt32Grid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBInt32Grid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBInt32Grid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBInt32Grid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBInt32Grid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBInt32Grid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBInt32Grid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBInt32Grid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBInt32Grid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBInt32Grid & var1 = mma::detail::getObject<OpenVDBInt32Grid>(OpenVDBInt32Grid_collection)(Args[1]);

        (OpenVDBInt32Grid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBInt32Grid & var1 = mma::detail::getObject<OpenVDBInt32Grid>(OpenVDBInt32Grid_collection)(Args[1]);

        (OpenVDBInt32Grid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBInt32Grid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBInt32Grid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBInt32Grid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBInt32Grid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBInt32Grid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBInt32Grid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBInt32Grid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBInt32Grid & var1 = mma::detail::getObject<OpenVDBInt32Grid>(OpenVDBInt32Grid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBInt32Grid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBInt32Grid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBInt32Grid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBInt32Grid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBInt32Grid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBInt32Grid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBInt32Grid_collection[id])->getBackgroundValue();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBInt32Grid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBInt32Grid_collection[id])->getValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_sliceVoxelValueTotals(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBInt32Grid_collection[id])->sliceVoxelValueTotals(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBInt32Grid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<mint> res = (OpenVDBInt32Grid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBInt32Grid_collection[id])->gridData(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt32Grid_activeVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt32Grid_collection.find(id) == OpenVDBInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::SparseArrayRef<mint> res = (OpenVDBInt32Grid_collection[id])->activeVoxels(var1);
        mma::detail::setSparseArray<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt32Grid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt32Grid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBInt64Grid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBInt64Grid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBInt64Grid & var1 = mma::detail::getObject<OpenVDBInt64Grid>(OpenVDBInt64Grid_collection)(Args[1]);

        (OpenVDBInt64Grid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBInt64Grid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBInt64Grid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBInt64Grid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBInt64Grid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBInt64Grid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBInt64Grid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBInt64Grid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBInt64Grid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBInt64Grid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBInt64Grid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBInt64Grid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBInt64Grid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBInt64Grid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBInt64Grid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBInt64Grid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBInt64Grid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBInt64Grid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBInt64Grid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBInt64Grid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBInt64Grid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBInt64Grid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBInt64Grid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBInt64Grid & var1 = mma::detail::getObject<OpenVDBInt64Grid>(OpenVDBInt64Grid_collection)(Args[1]);

        (OpenVDBInt64Grid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBInt64Grid & var1 = mma::detail::getObject<OpenVDBInt64Grid>(OpenVDBInt64Grid_collection)(Args[1]);

        (OpenVDBInt64Grid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBInt64Grid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBInt64Grid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBInt64Grid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBInt64Grid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBInt64Grid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBInt64Grid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBInt64Grid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBInt64Grid & var1 = mma::detail::getObject<OpenVDBInt64Grid>(OpenVDBInt64Grid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBInt64Grid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBInt64Grid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBInt64Grid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBInt64Grid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBInt64Grid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBInt64Grid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBInt64Grid_collection[id])->getBackgroundValue();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBInt64Grid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBInt64Grid_collection[id])->getValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_sliceVoxelValueTotals(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBInt64Grid_collection[id])->sliceVoxelValueTotals(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBInt64Grid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<mint> res = (OpenVDBInt64Grid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBInt64Grid_collection[id])->gridData(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBInt64Grid_activeVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBInt64Grid_collection.find(id) == OpenVDBInt64Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::SparseArrayRef<mint> res = (OpenVDBInt64Grid_collection[id])->activeVoxels(var1);
        mma::detail::setSparseArray<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBInt64Grid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBInt64Grid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBUInt32Grid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBUInt32Grid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBUInt32Grid & var1 = mma::detail::getObject<OpenVDBUInt32Grid>(OpenVDBUInt32Grid_collection)(Args[1]);

        (OpenVDBUInt32Grid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBUInt32Grid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBUInt32Grid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBUInt32Grid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBUInt32Grid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBUInt32Grid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBUInt32Grid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBUInt32Grid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBUInt32Grid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBUInt32Grid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBUInt32Grid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBUInt32Grid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBUInt32Grid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBUInt32Grid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBUInt32Grid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBUInt32Grid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBUInt32Grid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBUInt32Grid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBUInt32Grid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBUInt32Grid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBUInt32Grid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBUInt32Grid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBUInt32Grid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBUInt32Grid & var1 = mma::detail::getObject<OpenVDBUInt32Grid>(OpenVDBUInt32Grid_collection)(Args[1]);

        (OpenVDBUInt32Grid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBUInt32Grid & var1 = mma::detail::getObject<OpenVDBUInt32Grid>(OpenVDBUInt32Grid_collection)(Args[1]);

        (OpenVDBUInt32Grid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBUInt32Grid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBUInt32Grid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBUInt32Grid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBUInt32Grid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBUInt32Grid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBUInt32Grid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBUInt32Grid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBUInt32Grid & var1 = mma::detail::getObject<OpenVDBUInt32Grid>(OpenVDBUInt32Grid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBUInt32Grid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBUInt32Grid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBUInt32Grid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBUInt32Grid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBUInt32Grid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBUInt32Grid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBUInt32Grid_collection[id])->getBackgroundValue();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBUInt32Grid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBUInt32Grid_collection[id])->getValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_sliceVoxelValueTotals(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBUInt32Grid_collection[id])->sliceVoxelValueTotals(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBUInt32Grid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<mint> res = (OpenVDBUInt32Grid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBUInt32Grid_collection[id])->gridData(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBUInt32Grid_activeVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBUInt32Grid_collection.find(id) == OpenVDBUInt32Grid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::SparseArrayRef<mint> res = (OpenVDBUInt32Grid_collection[id])->activeVoxels(var1);
        mma::detail::setSparseArray<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBUInt32Grid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBUInt32Grid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBVec2DGrid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBVec2DGrid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec2DGrid & var1 = mma::detail::getObject<OpenVDBVec2DGrid>(OpenVDBVec2DGrid_collection)(Args[1]);

        (OpenVDBVec2DGrid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBVec2DGrid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBVec2DGrid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec2DGrid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBVec2DGrid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBVec2DGrid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec2DGrid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec2DGrid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBVec2DGrid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec2DGrid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2DGrid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2DGrid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2DGrid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2DGrid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec2DGrid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec2DGrid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec2DGrid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec2DGrid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBVec2DGrid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBVec2DGrid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2DGrid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec2DGrid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBVec2DGrid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec2DGrid & var1 = mma::detail::getObject<OpenVDBVec2DGrid>(OpenVDBVec2DGrid_collection)(Args[1]);

        (OpenVDBVec2DGrid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec2DGrid & var1 = mma::detail::getObject<OpenVDBVec2DGrid>(OpenVDBVec2DGrid_collection)(Args[1]);

        (OpenVDBVec2DGrid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBVec2DGrid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBVec2DGrid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBVec2DGrid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBVec2DGrid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBVec2DGrid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBVec2DGrid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec2DGrid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec2DGrid & var1 = mma::detail::getObject<OpenVDBVec2DGrid>(OpenVDBVec2DGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBVec2DGrid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec2DGrid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec2DGrid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec2DGrid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);

        (OpenVDBVec2DGrid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);

        (OpenVDBVec2DGrid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> res = (OpenVDBVec2DGrid_collection[id])->getBackgroundValue();
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> res = (OpenVDBVec2DGrid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBVec2DGrid_collection[id])->getValues(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_sliceVoxelValueTotals(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<double> res = (OpenVDBVec2DGrid_collection[id])->sliceVoxelValueTotals(var1, var2);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBVec2DGrid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<double> res = (OpenVDBVec2DGrid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2DGrid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2DGrid_collection.find(id) == OpenVDBVec2DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBVec2DGrid_collection[id])->gridData(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2DGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2DGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBVec2IGrid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBVec2IGrid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec2IGrid & var1 = mma::detail::getObject<OpenVDBVec2IGrid>(OpenVDBVec2IGrid_collection)(Args[1]);

        (OpenVDBVec2IGrid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBVec2IGrid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBVec2IGrid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec2IGrid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBVec2IGrid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBVec2IGrid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec2IGrid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec2IGrid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBVec2IGrid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2IGrid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2IGrid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2IGrid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2IGrid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec2IGrid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec2IGrid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBVec2IGrid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBVec2IGrid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2IGrid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec2IGrid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBVec2IGrid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec2IGrid & var1 = mma::detail::getObject<OpenVDBVec2IGrid>(OpenVDBVec2IGrid_collection)(Args[1]);

        (OpenVDBVec2IGrid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec2IGrid & var1 = mma::detail::getObject<OpenVDBVec2IGrid>(OpenVDBVec2IGrid_collection)(Args[1]);

        (OpenVDBVec2IGrid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBVec2IGrid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBVec2IGrid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBVec2IGrid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBVec2IGrid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBVec2IGrid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBVec2IGrid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec2IGrid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec2IGrid & var1 = mma::detail::getObject<OpenVDBVec2IGrid>(OpenVDBVec2IGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBVec2IGrid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        (OpenVDBVec2IGrid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBVec2IGrid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->getBackgroundValue();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->getValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_sliceVoxelValueTotals(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->sliceVoxelValueTotals(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2IGrid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2IGrid_collection.find(id) == OpenVDBVec2IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec2IGrid_collection[id])->gridData(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2IGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2IGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBVec2SGrid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBVec2SGrid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec2SGrid & var1 = mma::detail::getObject<OpenVDBVec2SGrid>(OpenVDBVec2SGrid_collection)(Args[1]);

        (OpenVDBVec2SGrid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBVec2SGrid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBVec2SGrid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec2SGrid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBVec2SGrid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBVec2SGrid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec2SGrid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec2SGrid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBVec2SGrid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec2SGrid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2SGrid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2SGrid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2SGrid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2SGrid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec2SGrid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec2SGrid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec2SGrid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec2SGrid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBVec2SGrid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBVec2SGrid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec2SGrid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec2SGrid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBVec2SGrid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec2SGrid & var1 = mma::detail::getObject<OpenVDBVec2SGrid>(OpenVDBVec2SGrid_collection)(Args[1]);

        (OpenVDBVec2SGrid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec2SGrid & var1 = mma::detail::getObject<OpenVDBVec2SGrid>(OpenVDBVec2SGrid_collection)(Args[1]);

        (OpenVDBVec2SGrid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBVec2SGrid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBVec2SGrid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBVec2SGrid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBVec2SGrid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBVec2SGrid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBVec2SGrid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec2SGrid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec2SGrid & var1 = mma::detail::getObject<OpenVDBVec2SGrid>(OpenVDBVec2SGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBVec2SGrid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec2SGrid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec2SGrid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec2SGrid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);

        (OpenVDBVec2SGrid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);

        (OpenVDBVec2SGrid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> res = (OpenVDBVec2SGrid_collection[id])->getBackgroundValue();
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> res = (OpenVDBVec2SGrid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBVec2SGrid_collection[id])->getValues(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_sliceVoxelValueTotals(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<double> res = (OpenVDBVec2SGrid_collection[id])->sliceVoxelValueTotals(var1, var2);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBVec2SGrid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<double> res = (OpenVDBVec2SGrid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec2SGrid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec2SGrid_collection.find(id) == OpenVDBVec2SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBVec2SGrid_collection[id])->gridData(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec2SGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec2SGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBVec3DGrid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBVec3DGrid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec3DGrid & var1 = mma::detail::getObject<OpenVDBVec3DGrid>(OpenVDBVec3DGrid_collection)(Args[1]);

        (OpenVDBVec3DGrid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBVec3DGrid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBVec3DGrid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec3DGrid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBVec3DGrid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBVec3DGrid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec3DGrid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec3DGrid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBVec3DGrid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec3DGrid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3DGrid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3DGrid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3DGrid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3DGrid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec3DGrid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec3DGrid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec3DGrid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec3DGrid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBVec3DGrid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBVec3DGrid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3DGrid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec3DGrid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBVec3DGrid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec3DGrid & var1 = mma::detail::getObject<OpenVDBVec3DGrid>(OpenVDBVec3DGrid_collection)(Args[1]);

        (OpenVDBVec3DGrid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec3DGrid & var1 = mma::detail::getObject<OpenVDBVec3DGrid>(OpenVDBVec3DGrid_collection)(Args[1]);

        (OpenVDBVec3DGrid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBVec3DGrid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBVec3DGrid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBVec3DGrid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBVec3DGrid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBVec3DGrid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBVec3DGrid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec3DGrid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec3DGrid & var1 = mma::detail::getObject<OpenVDBVec3DGrid>(OpenVDBVec3DGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBVec3DGrid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec3DGrid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec3DGrid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec3DGrid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);

        (OpenVDBVec3DGrid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);

        (OpenVDBVec3DGrid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> res = (OpenVDBVec3DGrid_collection[id])->getBackgroundValue();
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> res = (OpenVDBVec3DGrid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBVec3DGrid_collection[id])->getValues(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_sliceVoxelValueTotals(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<double> res = (OpenVDBVec3DGrid_collection[id])->sliceVoxelValueTotals(var1, var2);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBVec3DGrid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<double> res = (OpenVDBVec3DGrid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3DGrid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3DGrid_collection.find(id) == OpenVDBVec3DGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBVec3DGrid_collection[id])->gridData(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3DGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3DGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBVec3IGrid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBVec3IGrid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec3IGrid & var1 = mma::detail::getObject<OpenVDBVec3IGrid>(OpenVDBVec3IGrid_collection)(Args[1]);

        (OpenVDBVec3IGrid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBVec3IGrid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBVec3IGrid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec3IGrid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBVec3IGrid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBVec3IGrid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec3IGrid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec3IGrid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBVec3IGrid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3IGrid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3IGrid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3IGrid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3IGrid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec3IGrid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec3IGrid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBVec3IGrid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBVec3IGrid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3IGrid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec3IGrid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBVec3IGrid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec3IGrid & var1 = mma::detail::getObject<OpenVDBVec3IGrid>(OpenVDBVec3IGrid_collection)(Args[1]);

        (OpenVDBVec3IGrid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec3IGrid & var1 = mma::detail::getObject<OpenVDBVec3IGrid>(OpenVDBVec3IGrid_collection)(Args[1]);

        (OpenVDBVec3IGrid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBVec3IGrid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBVec3IGrid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBVec3IGrid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBVec3IGrid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBVec3IGrid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBVec3IGrid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec3IGrid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec3IGrid & var1 = mma::detail::getObject<OpenVDBVec3IGrid>(OpenVDBVec3IGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBVec3IGrid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        (OpenVDBVec3IGrid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBVec3IGrid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->getBackgroundValue();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->getValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_sliceVoxelValueTotals(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->sliceVoxelValueTotals(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3IGrid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3IGrid_collection.find(id) == OpenVDBVec3IGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec3IGrid_collection[id])->gridData(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3IGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3IGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBVec3SGrid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBVec3SGrid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec3SGrid & var1 = mma::detail::getObject<OpenVDBVec3SGrid>(OpenVDBVec3SGrid_collection)(Args[1]);

        (OpenVDBVec3SGrid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBVec3SGrid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBVec3SGrid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec3SGrid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBVec3SGrid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBVec3SGrid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec3SGrid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec3SGrid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBVec3SGrid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec3SGrid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3SGrid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3SGrid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3SGrid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3SGrid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec3SGrid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec3SGrid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBVec3SGrid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec3SGrid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBVec3SGrid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBVec3SGrid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBVec3SGrid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBVec3SGrid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBVec3SGrid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec3SGrid & var1 = mma::detail::getObject<OpenVDBVec3SGrid>(OpenVDBVec3SGrid_collection)(Args[1]);

        (OpenVDBVec3SGrid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec3SGrid & var1 = mma::detail::getObject<OpenVDBVec3SGrid>(OpenVDBVec3SGrid_collection)(Args[1]);

        (OpenVDBVec3SGrid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBVec3SGrid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBVec3SGrid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBVec3SGrid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBVec3SGrid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBVec3SGrid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBVec3SGrid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBVec3SGrid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBVec3SGrid & var1 = mma::detail::getObject<OpenVDBVec3SGrid>(OpenVDBVec3SGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBVec3SGrid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec3SGrid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBVec3SGrid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBVec3SGrid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> var1 = mma::detail::getTensor<double>(Args[1]);

        (OpenVDBVec3SGrid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);

        (OpenVDBVec3SGrid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> res = (OpenVDBVec3SGrid_collection[id])->getBackgroundValue();
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<double> res = (OpenVDBVec3SGrid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBVec3SGrid_collection[id])->getValues(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_sliceVoxelValueTotals(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<double> res = (OpenVDBVec3SGrid_collection[id])->sliceVoxelValueTotals(var1, var2);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::sliceVoxelValueTotals()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBVec3SGrid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<double> res = (OpenVDBVec3SGrid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBVec3SGrid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBVec3SGrid_collection.find(id) == OpenVDBVec3SGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<double> res = (OpenVDBVec3SGrid_collection[id])->gridData(var1);
        mma::detail::setTensor<double>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBVec3SGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBVec3SGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBBoolGrid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBBoolGrid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBBoolGrid & var1 = mma::detail::getObject<OpenVDBBoolGrid>(OpenVDBBoolGrid_collection)(Args[1]);

        (OpenVDBBoolGrid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBBoolGrid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBBoolGrid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBBoolGrid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBBoolGrid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBBoolGrid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBBoolGrid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBBoolGrid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBBoolGrid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBBoolGrid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBBoolGrid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBBoolGrid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBBoolGrid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBBoolGrid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBBoolGrid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBBoolGrid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBBoolGrid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBBoolGrid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBBoolGrid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBBoolGrid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBBoolGrid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBBoolGrid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBBoolGrid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBBoolGrid & var1 = mma::detail::getObject<OpenVDBBoolGrid>(OpenVDBBoolGrid_collection)(Args[1]);

        (OpenVDBBoolGrid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBBoolGrid & var1 = mma::detail::getObject<OpenVDBBoolGrid>(OpenVDBBoolGrid_collection)(Args[1]);

        (OpenVDBBoolGrid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBBoolGrid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBBoolGrid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBBoolGrid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBBoolGrid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBBoolGrid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBBoolGrid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBBoolGrid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBBoolGrid & var1 = mma::detail::getObject<OpenVDBBoolGrid>(OpenVDBBoolGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBBoolGrid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBBoolGrid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBBoolGrid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBBoolGrid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_depthMap(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        double var4 = MArgument_getReal(Args[4]);

        mma::ImageRef<mma::im_real32_t> res = (OpenVDBBoolGrid_collection[id])->depthMap(var1, var2, var3, var4);
        mma::detail::setImage<mma::im_real32_t>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::depthMap()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::depthMap()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_gridSliceImage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::GenericImageRef res = (OpenVDBBoolGrid_collection[id])->gridSliceImage(var1, var2, var3, var4);
        mma::detail::setGenericImage(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::gridSliceImage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::gridSliceImage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_gridImage3D(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::GenericImage3DRef res = (OpenVDBBoolGrid_collection[id])->gridImage3D(var1);
        mma::detail::setGenericImage3D(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::gridImage3D()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::gridImage3D()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_setBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBBoolGrid_collection[id])->setBackgroundValue(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::setBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_setValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBBoolGrid_collection[id])->setValues(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::setValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getBackgroundValue(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBBoolGrid_collection[id])->getBackgroundValue();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getBackgroundValue()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getMinMaxValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBBoolGrid_collection[id])->getMinMaxValues();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getMinMaxValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_getValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBBoolGrid_collection[id])->getValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::getValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_activeVoxelValues(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBBoolGrid_collection[id])->activeVoxelValues(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::activeVoxelValues()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_gridSlice(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::TensorRef<mint> res = (OpenVDBBoolGrid_collection[id])->gridSlice(var1, var2, var3, var4);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::gridSlice()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_gridData(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBBoolGrid_collection[id])->gridData(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::gridData()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBBoolGrid_activeVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBBoolGrid_collection.find(id) == OpenVDBBoolGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::SparseArrayRef<mint> res = (OpenVDBBoolGrid_collection[id])->activeVoxels(var1);
        mma::detail::setSparseArray<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBBoolGrid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBBoolGrid::activeVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_createEmptyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBMaskGrid_collection[id])->createEmptyGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::createEmptyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_deleteGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        (OpenVDBMaskGrid_collection[id])->deleteGrid();
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::deleteGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_copyGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBMaskGrid & var1 = mma::detail::getObject<OpenVDBMaskGrid>(OpenVDBMaskGrid_collection)(Args[1]);

        (OpenVDBMaskGrid_collection[id])->copyGrid(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::copyGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_importVDBType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        const char * res = (OpenVDBMaskGrid_collection[id])->importVDBType(var1, var2);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::importVDBType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_importVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        bool res = (OpenVDBMaskGrid_collection[id])->importVDB(var1, var2);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::importVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_exportVDB(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBMaskGrid_collection[id])->exportVDB(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::exportVDB()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_setActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);

        (OpenVDBMaskGrid_collection[id])->setActiveStates(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::setActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_setGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);

        (OpenVDBMaskGrid_collection[id])->setGridClass(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::setGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_setCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBMaskGrid_collection[id])->setCreator(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::setCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_setName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBMaskGrid_collection[id])->setName(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::setName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_setVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double var1 = MArgument_getReal(Args[1]);

        (OpenVDBMaskGrid_collection[id])->setVoxelSize(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::setVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getActiveStates(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBMaskGrid_collection[id])->getActiveStates(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getActiveStates()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getActiveLeafVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBMaskGrid_collection[id])->getActiveLeafVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getActiveLeafVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getActiveTileCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBMaskGrid_collection[id])->getActiveTileCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getActiveTileCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getActiveVoxelCount(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBMaskGrid_collection[id])->getActiveVoxelCount();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getActiveVoxelCount()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getGridClass(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBMaskGrid_collection[id])->getGridClass();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getGridClass()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getCreator(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBMaskGrid_collection[id])->getCreator();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getCreator()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getGridBoundingBox(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBMaskGrid_collection[id])->getGridBoundingBox();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getGridBoundingBox()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getGridDimensions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> res = (OpenVDBMaskGrid_collection[id])->getGridDimensions();
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getGridDimensions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getGridType(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBMaskGrid_collection[id])->getGridType();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getGridType()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getHasUniformVoxels(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBMaskGrid_collection[id])->getHasUniformVoxels();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getHasUniformVoxels()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getIsEmpty(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        bool res = (OpenVDBMaskGrid_collection[id])->getIsEmpty();
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getIsEmpty()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getMemoryUsage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint res = (OpenVDBMaskGrid_collection[id])->getMemoryUsage();
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getMemoryUsage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getName(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * res = (OpenVDBMaskGrid_collection[id])->getName();
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getName()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getVoxelSize(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        double res = (OpenVDBMaskGrid_collection[id])->getVoxelSize();
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getVoxelSize()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_gridMax(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBMaskGrid & var1 = mma::detail::getObject<OpenVDBMaskGrid>(OpenVDBMaskGrid_collection)(Args[1]);

        (OpenVDBMaskGrid_collection[id])->gridMax(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::gridMax()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_gridMin(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBMaskGrid & var1 = mma::detail::getObject<OpenVDBMaskGrid>(OpenVDBMaskGrid_collection)(Args[1]);

        (OpenVDBMaskGrid_collection[id])->gridMin(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::gridMin()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        bool res = (OpenVDBMaskGrid_collection[id])->getBooleanMetadata(var1);
        MArgument_setBoolean(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getIntegerMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        mint res = (OpenVDBMaskGrid_collection[id])->getIntegerMetadata(var1);
        MArgument_setInteger(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getIntegerMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getRealMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        double res = (OpenVDBMaskGrid_collection[id])->getRealMetadata(var1);
        MArgument_setReal(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getRealMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_getStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        const char * res = (OpenVDBMaskGrid_collection[id])->getStringMetadata(var1);
        mma::detail::setString(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::getStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_setBooleanMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        (OpenVDBMaskGrid_collection[id])->setBooleanMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::setBooleanMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_setStringMetadata(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);
        const char * var2 = mma::detail::getString(Args[2]);

        (OpenVDBMaskGrid_collection[id])->setStringMetadata(var1, var2);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::setStringMetadata()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_setDescription(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        const char * var1 = mma::detail::getString(Args[1]);

        (OpenVDBMaskGrid_collection[id])->setDescription(var1);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::setDescription()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_transformGrid(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        OpenVDBMaskGrid & var1 = mma::detail::getObject<OpenVDBMaskGrid>(OpenVDBMaskGrid_collection)(Args[1]);
        mma::TensorRef<double> var2 = mma::detail::getTensor<double>(Args[2]);
        mint var3 = MArgument_getInteger(Args[3]);

        (OpenVDBMaskGrid_collection[id])->transformGrid(var1, var2, var3);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::transformGrid()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_sliceVoxelCounts(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mint var2 = MArgument_getInteger(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBMaskGrid_collection[id])->sliceVoxelCounts(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::sliceVoxelCounts()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_activeTiles(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        bool var2 = MArgument_getBoolean(Args[2]);

        mma::TensorRef<mint> res = (OpenVDBMaskGrid_collection[id])->activeTiles(var1, var2);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::activeTiles()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_activeVoxelPositions(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::TensorRef<mint> res = (OpenVDBMaskGrid_collection[id])->activeVoxelPositions(var1);
        mma::detail::setTensor<mint>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::activeVoxelPositions()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_depthMap(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);
        double var2 = MArgument_getReal(Args[2]);
        double var3 = MArgument_getReal(Args[3]);
        double var4 = MArgument_getReal(Args[4]);

        mma::ImageRef<mma::im_real32_t> res = (OpenVDBMaskGrid_collection[id])->depthMap(var1, var2, var3, var4);
        mma::detail::setImage<mma::im_real32_t>(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::depthMap()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::depthMap()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_gridSliceImage(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mint var1 = MArgument_getInteger(Args[1]);
        mma::TensorRef<mint> var2 = mma::detail::getTensor<mint>(Args[2]);
        bool var3 = MArgument_getBoolean(Args[3]);
        bool var4 = MArgument_getBoolean(Args[4]);

        mma::GenericImageRef res = (OpenVDBMaskGrid_collection[id])->gridSliceImage(var1, var2, var3, var4);
        mma::detail::setGenericImage(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::gridSliceImage()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::gridSliceImage()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


extern "C" DLLEXPORT int OpenVDBMaskGrid_gridImage3D(WolframLibraryData libData, mint Argc, MArgument * Args, MArgument Res)
{
    mma::detail::MOutFlushGuard flushguard;
    if (setjmp(mma::detail::jmpbuf)) { return LIBRARY_FUNCTION_ERROR; }
    const mint id = MArgument_getInteger(Args[0]);
    if (OpenVDBMaskGrid_collection.find(id) == OpenVDBMaskGrid_collection.end()) { libData->Message("noinst"); return LIBRARY_FUNCTION_ERROR; }

    try
    {
        mma::TensorRef<mint> var1 = mma::detail::getTensor<mint>(Args[1]);

        mma::GenericImage3DRef res = (OpenVDBMaskGrid_collection[id])->gridImage3D(var1);
        mma::detail::setGenericImage3D(Res, res);
    }
    catch (const mma::LibraryError & libErr)
    {
        libErr.report();
        return libErr.error_code();
    }
    catch (const std::exception & exc)
    {
        mma::detail::handleUnknownException(exc.what(), "OpenVDBMaskGrid::gridImage3D()");
        return LIBRARY_FUNCTION_ERROR;
    }
    catch (...)
    {
        mma::detail::handleUnknownException(NULL, "OpenVDBMaskGrid::gridImage3D()");
        return LIBRARY_FUNCTION_ERROR;
    }

    return LIBRARY_NO_ERROR;
}


