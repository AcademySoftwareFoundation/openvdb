<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: AX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenVDB</a></li><li class="navelem"><a class="el" href="openvdbax.html">OpenVDB AX</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">AX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><div style="width:800px;text-align:justify;"></div><div style="width:800px;text-align:justify;"></div><h1><a class="anchor" id="axlanguage"></a>
AX Language Documentation</h1>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Welcome to the AX Language documentation. These docs provide detailed information on the AX language including syntax, data types, available functionality (including OpenVDB specific methods) execution structure and control flow. See the <a class="el" href="axcplusplus.html">OpenVDB AX</a> documentation for the C++ developer documentation. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Some sections of this document are still to be completed. Please get in touch should you have any questions!</dd></dl>
</div><h1><a class="anchor" id="axcontents"></a>
Contents</h1>
<div style="width:800px;text-align:justify;"><ul>
<li><a class="el" href="ax.html#axintro">Introduction</a></li>
<li><a class="el" href="ax.html#axprograms">AX Programs</a><ul>
<li><a class="el" href="ax.html#axprogramexample">A Program Example</a></li>
<li><a class="el" href="ax.html#axexecutionxcontext">OpenVDB Execution Context</a></li>
</ul>
</li>
<li><a class="el" href="ax.html#axdatatypes">Data Types</a><ul>
<li><a class="el" href="ax.html#axscalars">Scalars</a></li>
<li><a class="el" href="ax.html#axvecmats">Vectors / Matrices</a></li>
<li><a class="el" href="ax.html#axstrings">Strings</a></li>
<li><a class="el" href="ax.html#axtypeprecedence">Implicit conversion / type precedence</a></li>
</ul>
</li>
<li><a class="el" href="ax.html#axoperators">Operators</a><ul>
<li><a class="el" href="ax.html#axopbinary">Binary Operators</a><ul>
<li><a class="el" href="ax.html#axopassignment">Assignments</a></li>
<li><a class="el" href="ax.html#axopbinarithmetic">Arithmetic</a></li>
<li><a class="el" href="ax.html#axopcomparison">Comparisons / Relational</a></li>
<li><a class="el" href="ax.html#axopbinlogical">Logical</a></li>
</ul>
</li>
<li><a class="el" href="ax.html#axopunary">Unary Operators</a><ul>
<li><a class="el" href="ax.html#axopunarithmetic">Arithmetic</a></li>
<li><a class="el" href="ax.html#axopunlogical">Logical</a></li>
<li><a class="el" href="ax.html#axopunincdec">Increment / Decrement</a></li>
</ul>
</li>
<li><a class="el" href="ax.html#axopaccess">Container Access</a></li>
<li><a class="el" href="ax.html#axopother">Other</a></li>
<li><a class="el" href="ax.html#axopprecedence">Operator Precedence</a></li>
</ul>
</li>
<li><a class="el" href="ax.html#axtokens">Tokens</a><ul>
<li><a class="el" href="ax.html#axvaridentifiers">Variable Identifiers</a></li>
<li><a class="el" href="ax.html#axliterals">Literals</a></li>
<li><a class="el" href="ax.html#axcomments">Comments</a></li>
<li><a class="el" href="ax.html#axkeywords">Keywords</a><ul>
<li><a class="el" href="ax.html#axreserved">Reserved Keywords</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="el" href="ax.html#axsyntax">Syntax</a><ul>
<li><a class="el" href="ax.html#axattribaccess">Attribute Access</a></li>
<li><a class="el" href="ax.html#axexternalaccess">External Parameter Access</a></li>
<li><a class="el" href="ax.html#axdecls">Declarations</a></li>
<li><a class="el" href="ax.html#axscopes">Scopes</a></li>
<li><a class="el" href="ax.html#axbranching">Branching (if / else)</a></li>
<li><a class="el" href="ax.html#axloops">Loops</a></li>
</ul>
</li>
<li><a class="el" href="ax.html#axfunctions">Functions</a><ul>
<li><a class="el" href="ax.html#axuserfunctions">User Functions</a></li>
</ul>
</li>
<li><a class="el" href="ax.html#axvexsupport">AX VEX Support</a></li>
<li><a class="el" href="axexamples.html">AX Code Examples</a></li>
</ul>
</div><div style="width:800px;text-align:justify;"></div><h1><a class="anchor" id="axintro"></a>
Introduction</h1>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>AX is a fast and portable JIT compiled expression language, designed for writing volume and point kernels represented as OpenVDB grids. It was originally developed by the RNDFX team at <a href="https://www.dneg.com">DNEG</a> to provide a more consistent way for artists to be able to interface with OpenVDB data across a variety of in house and external digital content creation software, whilst retaining the performance achievable by custom C++ operators. </dd></dl>
<dl class="section user"><dt></dt><dd>The language is predominately inspired by <a href="https://www.sidefx.com/docs/houdini/vex/index.html">SideFX's VEX</a> language which itself takes elements from C, C++ and the Renderman Shading Language. The design of AX uses concepts from these languages and refrains from deviating from their syntax too significantly. Specifically, it does not aim to change what are already well established and heavily used language syntaxes within the Visual Effects industry; on the contrary, AX aims to provide an interface to which a user with previous or little programming experience can easily transition to. However, it does introduce new concepts where the creators deemed necessary to provide the best and most representative syntax relating to the design for OpenVDB volume and point modification.</dd></dl>
</div><h1><a class="anchor" id="axprograms"></a>
AX Programs</h1>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>AX programs represent a set of statements which read and write to geometry, with each program designed in such a way that it can be executed in a highly parallelized framework to access and update individual geometric components. For example, consider a mesh with point, vertex and primitive attributes. AX programs are designed to run independently across "elements" of input geometry and process "attributes" from a particular element. In this case, the element level would correlate to either points, vertexes or primitives, and a single element would be a unique instance of one of these. These programs are at their most efficient writing to the currently processing element, however do provide varying levels of access to the geometry as a whole. </dd></dl>
<dl class="section user"><dt></dt><dd>Note that native AX only supports the modification of OpenVDB data. Currently, that means that native AX programs can be written and built for execution over OpenVDB Points or OpenVDB Volumes. For any given AX program, the execution context (what it's processing) may change what functionality is available and, more importantly, the behaviour of reading/writing from attributes. See the <a class="el" href="ax.html#axexecutionxcontext">OpenVDB Execution Context</a> for details. </dd></dl>
<dl class="section user"><dt></dt><dd>Whilst powerful, AX is not a catch all replacement for all types of VDB operations. Some of this is related to its infancy i.e. missing native support for some useful functions, the foundations of which may be supported by AX but have not yet been exposed. However there may be certain paradigms which AX is better tailored to support than others. Grid reductions, for example, typically require the passing of a state between programs; a design pattern which AX is less equipped to handle. AX kernels can be abstractly thought of as a "foreach()" function (see <a class="el" href="ax.html#axprogramexample">A Program Example</a>) and whilst there are ways to achieve reductions, it is an example which would be better suited to a custom C++ implementation. </dd></dl>
<dl class="section user"><dt></dt><dd>For details of extending AX for custom geometry, see the <a class="el" href="axcplusplus.html">OpenVDB AX</a> developer documentation. Note that custom geometry support requires C++ extension.</dd></dl>
</div><h2><a class="anchor" id="axprogramexample"></a>
A Program Example</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Before getting into the technical depths of the language, it's a good idea to observe a small but complete AX program which could be compiled and executed. To begin with, here is a very simple example of a program that reads and writes to a particular attribute: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="comment">// read a floating point attribute from the value of &quot;myattribute&quot;</span></div><div class="line"><span class="keywordtype">float</span> temp = <span class="keywordtype">float</span>@myattribute;</div><div class="line"><span class="comment">// if the value is less than 0, clamp it to 0</span></div><div class="line"><span class="keywordflow">if</span> (temp &lt; 0.0f) <span class="keywordtype">float</span>@myattribute = 0.0f;</div></div><!-- fragment --> Note that there is no other required logic here to make this a compatible program i.e. feeding this code to the <a class="el" href="axcplusplus.html#vdbaxbinary">vdb_ax command line binary</a> will compile and execute over provided OpenVDB files. </dd></dl>
<dl class="section user"><dt></dt><dd>The following explains the above example in relation to OpenVDB data; OpenVDB points and OpenVDB volumes. The example demonstrates reading from a value on some input, either a point attribute or a voxel value, and storing the result in a <a class="el" href="ax.html#axdecls">local variable</a>. Importantly, the attribute being accessed has the name <b><code>myattribute</code></b> and the type <b><code>float</code></b>. The first statement: <div class="fragment"><div class="line"><span class="keywordtype">float</span> temp = <span class="keywordtype">float</span>@myattribute;</div></div><!-- fragment --> Invokes a <b>read</b> from this attribute (see <a class="el" href="ax.html#axattribaccess">Attribute Access</a>), retrieving the value from the geometry and storing it in the variable <b><code>temp</code></b> to be used in the AX program. The second statement: <div class="fragment"><div class="line"><span class="keywordflow">if</span> (temp &gt; 0.0f) <span class="keywordtype">float</span>@myattribute = 0.0f;</div></div><!-- fragment --> Performs a comparison of this value with <b><code>0.0f</code></b> and, if the value is greater than <b><code>0.0f</code></b>, performs a <b>write</b> to the geometry in the form of <b><code>float@myattribute = 0.0f;</code></b> which sets the value of this attribute on the geometry to <b><code>0.0f</code></b>. </dd></dl>
<dl class="section user"><dt></dt><dd>For OpenVDB Points, this kernel is run over every point in an OpenVDB Points Grid. In simple pseudo code: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;foreach(point in pointgrid)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    run_ax_kernel(point)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;done()</div></div><!-- fragment --> Where <b><code>pointgrid</code></b> is a single Point Data Grid. For OpenVDB volumes the kernel is run over each voxel in a provided grid: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;foreach(grid in grids)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    foreach(voxel IN grid)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;        run_ax_kernel(voxel)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    done()</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;done()</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Where <b><code>grids</code></b> can comprise of any number of OpenVDB volumes. In this program, only a floating point grid with the name <b><code>myattribute</code></b> will be updated. Each voxel in this grid will have it's value compared in the same way as the points example given above.</dd></dl>
</div><h2><a class="anchor" id="axexecutionxcontext"></a>
OpenVDB Execution Context</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>AX programs are designed to run over different types of grids, specifically OpenVDB points and OpenVDB volumes, the latter of which is the set of all default supported mathematic volume types in OpenVDB. Programs must be compiled separately for points and volumes, or twice to support both (see the <a class="el" href="axcplusplus.html#vdbaxbinary">vdb_ax binary</a>). This is known as compiling for a target <b>Execution Context</b>. There are two main considerations to make when switching between execution contexts:<ul>
<li>Certain <a class="el" href="ax.html#axfunctions">functions</a> may not be available under a given context. Some natively supported functions are designed to interface directly with geometry attributes, and a further subset of these are tailored specifically for point attributes <b>or</b> voxel values, not both.</li>
<li>Whilst the AX grammar does not change syntactically, <a class="el" href="ax.html#axattribaccess">attribute accesses</a> may be affected. This is due to the fundamental differences of executing over different types of VDBs/geometry. </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Execution over Points</dt><dd>AX kernels compiled for OpenVDB Points run <b>individually</b> on <b>each point</b> in every <b>active voxel</b> in a points VDB. Attributes that have been accessed in the program are provided such that the program has access to all data available on the currently processing point. Multiple OpenVDB Point grids can be processed by the same AX program, but only a single OpenVDB Points grid can be processed at a time. The default behaviour for AX point programs is to process every point which exists in active OpenVDB voxels. </dd></dl>
<dl class="section user"><dt>Execution over Volumes</dt><dd>AX kernels for OpenVDB volumes run individually on every <b>active voxel</b> of VDBs which are <b>written</b> to (whilst retaining access to all available VDBs). Volumes can be thought of as only holding a single "attribute". Whilst points hold all attributes within a single VDB points grid (and values for all attributes are are defined for all points in that grid), multiple volume attributes require multiple VDB volumes to be accessed. The location of this access is the <b>world space position</b> of each voxel. Assignment operations determine which volumes will be executed over. </dd></dl>
<dl class="section user"><dt></dt><dd>See the syntax section on <a class="el" href="ax.html#axattribaccess">accessing attribute</a> for more information.</dd></dl>
<br />
<hr/>
</div><div style="width:800px;text-align:justify;"></div><h1><a class="anchor" id="axdatatypes"></a>
Data Types</h1>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>AX supports a rich variety of native types to be able to maximise the efficiency of arithmetic operations and facilitate accessing underlying geometry. As AX is designed for OpenVDB, native AX types aim to provide direct access to all supported OpenVDB data types. You may find, however, that some AX types do not exist as OpenVDB volume/point types or refuse to be serialized in some installations of OpenVDB. The table below lists all available types in AX, the exposed <a class="el" href="ax.html#axattribaccess">attribute access</a> syntax and whether or not the attribute syntax is valid for both point and volume execution contexts. Developers installing OpenVDB and OpenVDB AX may wish to read the <a class="el" href="axcplusplus.html#vdbaxtoaxtypes">type registry documentation</a> which explains how to enable missing types from OpenVDB. <a class="anchor" id="axdatatypestable"></a></dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Category</th><th>Type</th><th>Definition</th><th>Attribute Syntax</th><th>Points</th><th>Voxels  </th></tr>
<tr>
<td rowspan="7"><a class="el" href="ax.html#axscalars">Scalars</a>  </td><td><code>bool</code> </td><td>Boolean value, true or false</td><td><code>bool@</code> </td><td><b>Yes</b> </td><td><b>Yes</b>   </td></tr>
<tr>
<td><code>int16</code>*</td><td>16-bit signed integer value</td><td><code>int16@</code></td><td><b>Yes</b> </td><td>No </td></tr>
<tr>
<td><code>int32</code></td><td>32-bit signed integer value</td><td><code>int32@, int@, i@</code></td><td><b>Yes</b> </td><td><b>Yes</b>  </td></tr>
<tr>
<td><code>int</code></td><td colspan="4">Alias for integer type (typically int32) </td></tr>
<tr>
<td><code>int64</code></td><td>64-bit signed integer value</td><td><code>int64@</code></td><td><b>Yes</b> </td><td><b>Yes</b>  </td></tr>
<tr>
<td><code>float</code></td><td>32-bit floating point value</td><td><code>float@ f@ @</code></td><td><b>Yes</b> </td><td><b>Yes</b>  </td></tr>
<tr>
<td><code>double</code></td><td>64-bit floating point value</td><td><code>double@</code></td><td><b>Yes</b> </td><td><b>Yes</b>  </td></tr>
<tr>
<td style="border-top-width: thick" rowspan="9"><a class="el" href="ax.html#axvecmats">Vectors</a>  </td><td style="border-top-width: thick"><code>vec2i</code> </td><td style="border-top-width: thick">2-element vector of integer values </td><td style="border-top-width: thick"><code>vec2i@</code> </td><td style="border-top-width: thick">No </td><td style="border-top-width: thick">No  </td></tr>
<tr>
<td><code>vec2f</code></td><td>2-element vector of float values </td><td><code>vec2f@</code></td><td>No</td><td>No </td></tr>
<tr>
<td><code>vec2d</code></td><td>2-element vector of double values </td><td><code>vec2d@</code></td><td>No</td><td>No </td></tr>
<tr>
<td><code>vec3i</code></td><td>3-element vector of integer values</td><td><code>vec3i@</code></td><td><b>Yes</b> </td><td><b>Yes</b>  </td></tr>
<tr>
<td><code>vec3f</code></td><td>3-element vector of float values </td><td><code>vec3f@ v@</code></td><td><b>Yes</b> </td><td><b>Yes</b>  </td></tr>
<tr>
<td><code>vec3d</code></td><td>3-element vector of double values </td><td><code>vec3d@</code></td><td><b>Yes</b> </td><td><b>Yes</b>  </td></tr>
<tr>
<td><code>vec4i</code></td><td>4-element vector of integer values</td><td><code>vec4i@</code></td><td>No</td><td>No </td></tr>
<tr>
<td><code>vec4f</code></td><td>4-element vector of float values </td><td><code>vec4f@</code></td><td>No</td><td>No </td></tr>
<tr>
<td><code>vec4d</code></td><td>4-element vector of double values </td><td><code>vec4d@</code></td><td>No</td><td>No </td></tr>
<tr>
<td style="border-top-width: thick" rowspan="4"><a class="el" href="ax.html#axvecmats">Matrices</a>  </td><td style="border-top-width: thick"><code>mat3f</code> </td><td style="border-top-width: thick">3x3-matrix of float values  </td><td style="border-top-width: thick"><code>mat3f@</code>  </td><td style="border-top-width: thick"><b>Yes</b>  </td><td style="border-top-width: thick">No  </td></tr>
<tr>
<td><code>mat3d</code></td><td>3x3-matrix of double values</td><td><code>mat3d@</code></td><td><b>Yes</b> </td><td>No </td></tr>
<tr>
<td><code>mat4f</code></td><td>4x4-matrix of float values </td><td><code>mat4f@</code></td><td><b>Yes</b> </td><td>No </td></tr>
<tr>
<td><code>mat4d</code></td><td>4x4-matrix of double values</td><td><code>mat4d@</code></td><td><b>Yes</b> </td><td>No </td></tr>
<tr>
<td style="border-top-width: thick" rowspan="1"><a class="el" href="ax.html#axstrings">Strings</a>  </td><td style="border-top-width: thick"><code>string</code> </td><td style="border-top-width: thick">A string of characters  </td><td style="border-top-width: thick"><code>string@</code>  </td><td style="border-top-width: thick"><b>Yes</b>  </td><td style="border-top-width: thick"><b>Yes</b>   </td></tr>
</table>
<ul>
<li><b>Note*</b> - There is no support for int16 local variables or integer literals.</li>
</ul>
</dd></dl>
</div><h2><a class="anchor" id="axscalars"></a>
Scalars</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>AX Supports boolean, integer and floating point scalar types. <b><code>int</code></b> and <b><code>int32</code></b> represent 32-bit integer values and <b><code>int64</code></b> represents a 64-bit value. <b><code>float</code></b> and <b><code>double</code></b> represent 32-bit and 64-bit floating point values respectively. All scalars, excluding bools, are signed; there are no other unsigned scalar types in AX. </dd></dl>
<dl class="section user"><dt>Integer Overflow and Floating Point Truncation</dt><dd>Scalars may be cast from one type to another, either explicitly using the <a class="el" href="ax.html#axopother">cast</a> operator or implicitly during <a class="el" href="ax.html#axopassignment">assignments</a> or <a class="el" href="ax.html#axopbinarithmetic">binary arthimetic</a> operations (in which case the order of <a class="el" href="ax.html#axtypeprecedence">type precedence</a> is observed). Data can be truncated (converting floats to integrals) or overflow (conversions from integers of larger bit widths to integers of smaller bit widths) depending on the source and target types. See the below examples: </dd></dl>
<dl class="section user"><dt></dt><dd>This example demonstrates floating point truncation in AX. <div class="fragment"><div class="line"><span class="keywordtype">float</span> a = 1.1f;</div><div class="line"><span class="keywordtype">int</span> b = 5.5f; <span class="comment">// implict conversion from literal 5.5f. &quot;b&quot; is set to 5</span></div><div class="line">b = a; <span class="comment">// implicit conversion from float &quot;a&quot;. &quot;b&quot; is set to 1</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>This example demonstrates integer overflow in AX. <div class="fragment"><div class="line">int64 a = 2147483648l; <span class="comment">// one more than can be held in an int (note the last letter &quot;l&quot;)</span></div><div class="line"><span class="keywordtype">int</span> b = a; <span class="comment">// implicit conversion. &quot;b&quot; is set to -2147483648</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Infinite and NaN values</dt><dd>Floating point values have two additional intrinsic states; <b><code>inf</code></b> and <b><code>nan</code></b>. These states can occur during invalid floating point arithmetic. AX performs no checks on arithmetic to catch these values. A typical example of both <b><code>inf</code></b> and <b><code>nan</code></b> values are division by zero expressions: <div class="fragment"><div class="line"><span class="keywordtype">float</span> a = 1.0f/0.0f;</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a776b0b1a1fe663a634b62f53a91766f2">print</a>(a); <span class="comment">// prints &quot;inf&quot;</span></div></div><!-- fragment --> <div class="fragment"><div class="line"><span class="keywordtype">float</span> a = 0.0f/0.0f;</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1ax_1_1ast.html#a776b0b1a1fe663a634b62f53a91766f2">print</a>(a); <span class="comment">// prints some version of &quot;nan&quot;</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Generally these values are not desired and can cause problems as they propagate throughout your program.</dd></dl>
</div><h2><a class="anchor" id="axvecmats"></a>
Vectors / Matrices</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>All vector and matrix types in AX are implemented as flat arrays of a given size, with all elements stored contiguously in memory. Both container types are represented by <a class="el" href="ax.html#axdatatypestable">specific tokens</a> which tell AX functions and operators how to handle various arithmetic. </dd></dl>
<dl class="section user"><dt>Vectors</dt><dd>There is currently support for vectors of sizes 2, 3 and 4 elements. The suffix letter on the vector types denotes the contained elements precision, with the number corresponding to the vector size. For example, <b><code>vec2i</code></b> denotes a vector of two 32-bit integer elements. There are no native types for vectors with <b><code>bool</code></b>, <b><code>int16</code></b> or <b><code>int64</code></b> elements, so these are not supported. </dd></dl>
<dl class="section user"><dt>Matrices</dt><dd>Matrices are stored in row major layout (lexographical access order) which matches the representation of a matrix in OpenVDB. Matrix support consists of <b><code>float</code></b> and <b><code>double</code></b> precision elements with dimensions either <b><code>3x3</code></b> or <b><code>4x4</code></b> (total size of 9 and 16 elements respectively). There are no integer or boolean matrix types. Similiar to vectors, the suffix letter on the type denotes the contained elements precision, with the number corresponding to the matrix dimension. A matrix of type <b><code>mat3d</code></b> therefor corresponds to a <b><code>3x3</code></b> matrix (9 elements) with <b><code>double</code></b> precision elements. </dd></dl>
<dl class="section user"><dt>Element Access</dt><dd>As elements of all matrix and vector types are stored contiguously, they can be accessed by the <a class="el" href="ax.html#axvecaccessop">[]&#160;operator</a>. Vector elements can also be accessed by supported <a class="el" href="ax.html#axopaccess">.&#160;operator</a> components and matrix elements can be accessed with the <a class="el" href="ax.html#axmataccessop">[,]&#160;operator</a>. </dd></dl>
<dl class="section user"><dt>Initialization</dt><dd>Both matrices and vector declarations can be flat initialized from scalars or component initialized from containers of the same size (see <a class="el" href="ax.html#axopassignment">assignments</a>). However both types can also be represented as temporary containers without declarations using the <a class="el" href="ax.html#axvecmatinit">{,} syntax.</a> </dd></dl>
<dl class="section user"><dt>A Note on Operators</dt><dd>Most <a class="el" href="ax.html#axopbinary">binary operators</a> only accept vectors of <b>equal</b> sizes as valid left and right operands - however there exists valid <a class="el" href="ax.html#axopbinarithmetic">arithmetic</a> for combinations of vectors/matrices with scalars and, importantly, <a class="el" href="ax.html#axbinmultop">multiplicative arithmetic</a> for vectors with matrices, the latter performing matrix projections (transformations) on vector arguments.</dd></dl>
</div><h2><a class="anchor" id="axstrings"></a>
Strings</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Strings are an array of characters stored in a unique AX type which is incompatible with <a class="el" href="ax.html#axopaccess">container accesses</a>. As such, string support is currently fairly limited. Characters themselves (users may know this as a <b><code>char</code></b> type) have no frontend type, so a <b><code>string</code></b> type must be used for any number of characters (including the empty string). String literals are represented by enclosing any number of <a class="el" href="ax.html#axtokens">supported AX characters</a> by quotes <b>"&#160;"</b>.</dd></dl>
</div><h2><a class="anchor" id="axtypeprecedence"></a>
Implicit conversion / type precedence</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>All operators that perform on two or more types must internally run the operation at a single precision. When mixing different types (e.g. <code>int + float</code>) values may need to be converted to another type before the operation is performed. To allow for easier writing of expressions, AX will automatically detect these cases and convert values when necessary. This is known as <b>implicit type conversion</b> and the way in which the target operation type is chosen is known as <b>type precedence</b>. </dd></dl>
<dl class="section user"><dt></dt><dd>When referring to type precedence, we are primarily refering to the conversion of one <b>scalar</b> type to another. For vectors, matrices and other containers, this refers to the conversion of their element type e.g. <code>mat3f</code> to <code>mat3d</code>. The conversion rules for more than the element type (e.g. <code>int</code> to <code>mat4f</code>) are governed by AX's assignment and operator rules, detailed in the <a class="el" href="ax.html#axoperators">Operators</a> section of this documentation. </dd></dl>
<dl class="section user"><dt></dt><dd>Type precedence <b>only</b> applies to the <b>element</b> type of the type in question. Containers (such as vectors or matrices) may change their element type precision (e.g. <code>vec2i</code> to <code>vec2f</code>). Each scalar type has a ranking which is compared, and the resulting highest rank is chosen as the target type for all values. These rankings are defined as follows:<ul>
<li>If any element types are of type <code>double</code>, all other element types are converted to <code>double</code></li>
<li>else, if any element types are of type <code>float</code>, all other element types are converted to <code>float</code></li>
<li>else, if any element types are of type <code>int64</code>, all other element types are converted to <code>int64</code></li>
<li>else, if any element types are of type <code>int32</code>, all other element types are converted to <code>int32</code></li>
<li>else, all element types are <code>bool</code> </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd>For example: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 0;</div><div class="line"><span class="keywordtype">float</span> b = 0.0f;</div><div class="line"><span class="comment">// In the following, the arithmetic a + b chooses floating point precision as</span></div><div class="line"><span class="comment">// defined by the above type precedence rules (i.e. float(a) + b). The temporary</span></div><div class="line"><span class="comment">// value created by the arithmetic + will be at float precision. The subsequent</span></div><div class="line"><span class="comment">// assignment must then convert the final result back an integer, resulting in</span></div><div class="line"><span class="comment">// an expression equal to: a = int(float(a) + b);</span></div><div class="line">a = a + b;</div><div class="line"></div><div class="line"><span class="comment">// This example shows arithmetic minus with a float scalar and vec4d. Minus is a</span></div><div class="line"><span class="comment">// supported operator of vec4d, however as the element types do not match</span></div><div class="line"><span class="comment">// (float vs double), implicit conversion must be observed. With the above rules,</span></div><div class="line"><span class="comment">// we can determine the following expression: c = double(b) + c. Note that</span></div><div class="line"><span class="comment">// as the result of &quot;double(b) + c&quot; is a vec4d and the target of the subsequent</span></div><div class="line"><span class="comment">// assignment (&quot;c&quot;) is a vec4d, no further conversion needs to be performed.</span></div><div class="line">vec4d c = 0.0; <span class="comment">// double element type</span></div><div class="line">c = b - c;</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Strings are not included in this precedence as there are no supported arithmetic binary operations for strings with operand types other than string.</dd></dl>
<br />
<hr/>
</div><div style="width:800px;text-align:justify;"></div><h1><a class="anchor" id="axoperators"></a>
Operators</h1>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>The below table lists all available operators supported by AX. Note that not all AX types support all operators and some operators have unique functionality depending on the operand types. </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th colspan="9">Operators  </th></tr>
<tr style="text-align:center">
<td bgcolor="#ffc4c4" style="border-right-width: thick" colspan="4"><a class="el" href="ax.html#axopbinary">Binary Operators</a>  </td><td bgcolor="#ffc4c4" style="border-right-width: thick" colspan="3"><a class="el" href="ax.html#axopunary">Unary Operators</a>  </td><td bgcolor="#ffc4c4" colspan="2">Other  </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axopassignment">Assignments</a>  </td><td><a class="el" href="ax.html#axopbinarithmetic">Arithmetic</a>  </td><td><a class="el" href="ax.html#axopcomparison">Comparisons / Relational</a>  </td><td style="border-right-width: thick"><a class="el" href="ax.html#axopbinlogical">Logical</a>  </td><td><a class="el" href="ax.html#axopunarithmetic">Arithmetic</a>  </td><td><a class="el" href="ax.html#axopunlogical">Logical</a>  </td><td style="border-right-width: thick"><a class="el" href="ax.html#axopunincdec">Increment / Decrement</a>  </td><td><a class="el" href="ax.html#axopaccess">Container Access</a>  </td><td><a class="el" href="ax.html#axopother">Other</a>  </td></tr>
<tr style="text-align:center">
<td><p class="starttd"></p>
<p><code> a = b<br />
a += b<br />
a -= b<br />
a *= b<br />
a /= b<br />
a %= b<br />
 a &amp;= b<br />
a |= b<br />
a ^= b<br />
a &lt;&lt;= b<br />
a &gt;&gt;= b </code> </p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p><code> a + b<br />
a - b<br />
a * b<br />
a / b<br />
a % b<br />
a &amp; b<br />
a | b<br />
 a ^ b<br />
a &lt;&lt; b<br />
a &gt;&gt; b </code></p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p><code> a == b<br />
a != b<br />
a &lt; b<br />
a &gt; b<br />
a &lt;= b<br />
a &gt;= b </code> </p>
<p class="endtd"></p>
</td><td style="border-right-width: thick"><p class="starttd"></p>
<p><code> a&#160;&amp;&amp;&#160;b<br />
a&#160;||&#160;b </code> </p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p><code> +a<br />
-a<br />
~a </code> </p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p><code> !a </code> </p>
<p class="endtd"></p>
</td><td style="border-right-width: thick"><p class="starttd"></p>
<p><code> ++a<br />
--a<br />
a++<br />
a-- </code> </p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p><code> a[]<br />
a[,]<br />
a.b </code> </p>
<p class="endtd"></p>
</td><td><p class="starttd"></p>
<p><code> a(...)<br />
a, b<br />
a ? b : c<br />
{&#160;a,b&#160;...&#160;} </code> </p>
<p class="endtd"></p>
</td></tr>
</table>
</dd></dl>
</div><h2><a class="anchor" id="axopbinary"></a>
Binary Operators</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Binary operators are the most common inbuilt operators for AX types. These operators take two inputs; a left hand side and a right hand side. There exists a number of valid combinations of AX types with different binary operators, as well as different implicit casting schemes depending on the binary operation being performed.</dd></dl>
</div><h3><a class="anchor" id="axopassignment"></a>
Assignments</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Assignment operators are the only way to directly modify the value of local and external data (except for <a class="el" href="ax.html#axfunctions">Functions</a> which take <b>references</b>). The assignment operators have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator Name</th><th>Operator Syntax</th><th>Returns </th></tr>
<tr>
<td>Simple assignment</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>=</code></b> <em><code>rhs</code></em> </td><td>Reference to <em><code>lhs</code></em>  </td></tr>
<tr>
<td>Addition assignment</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>+=</code></b> <em><code>rhs</code></em> </td><td>Reference to <em><code>lhs</code></em>  </td></tr>
<tr>
<td>Subtraction assignment</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>-=</code></b> <em><code>rhs</code></em> </td><td>Reference to <em><code>lhs</code></em>  </td></tr>
<tr>
<td>Multiplication assignment</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>*=</code></b> <em><code>rhs</code></em> </td><td>Reference to <em><code>lhs</code></em>  </td></tr>
<tr>
<td>Division assignment</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>/=</code></b> <em><code>rhs</code></em> </td><td>Reference to <em><code>lhs</code></em>  </td></tr>
<tr>
<td>Modulo assignment</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>%=</code></b> <em><code>rhs</code></em> </td><td>Reference to <em><code>lhs</code></em>  </td></tr>
<tr>
<td>Bitwise AND assignment</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&amp;=</code></b> <em><code>rhs</code></em> </td><td>Reference to <em><code>lhs</code></em>  </td></tr>
<tr>
<td>Bitwise OR assignment</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>|=</code></b> <em><code>rhs</code></em> </td><td>Reference to <em><code>lhs</code></em>  </td></tr>
<tr>
<td>Bitwise XOR assignment</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>^=</code></b> <em><code>rhs</code></em> </td><td>Reference to <em><code>lhs</code></em>  </td></tr>
<tr>
<td>Bitwise shift left assignment</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&lt;&lt;=</code></b> <em><code>rhs</code></em> </td><td>Reference to <em><code>lhs</code></em>  </td></tr>
<tr>
<td>Bitwise shift right assignment</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&gt;&gt;=</code></b> <em><code>rhs</code></em> </td><td>Reference to <em><code>lhs</code></em>  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>These can be further categorised into two types; direct assignment, which is comprised only of the <b>simple assignment</b> operator, and compound assignments, which is the set of all other assignment operators. </dd></dl>
<dl class="section user"><dt>Direct Assignment</dt><dd>Direct assignments replace the contents of the <b><code>lhs</code></b> with a copy of the <b><code>rhs</code></b>: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b>= </b> <em><code>rhs</code></em>  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>The <b><code>rhs</code></b> side is not modified and the <b><code>lhs</code></b> is not read - only written to. If the <b><code>rhs</code></b> type does not match the <b><code>lhs</code></b> type, the <b><code>rhs</code></b> is first implicitly converted into a new temporary with the <b><code>lhs</code></b> type before being copied into the <b><code>lhs</code></b>. The following combination of AX type categories are supported for direct assignment (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description  </th></tr>
<tr style="text-align:center">
<td rowspan="1"><a class="el" href="ax.html#axscalars">scalar</a></td><td rowspan="1"><code>=</code> </td><td><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="text-align:left">On type mismatch, right hand side is copied and <a class="el" href="ax.html#axtypeprecedence">implicitly cast</a> to the left hand side type.  </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="2"><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="border-top-width: thick; text-align:center" rowspan="2"><code>=</code> </td><td style="border-top-width: thick"><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="border-top-width:thick;text-align:left">Each element of the vector is set to the right hand side scalar. i.e. <br />
 <code>a[0]&#160;=&#160;b;&#160;...&#160;a[n-1]&#160;=&#160;b;</code> <br />
 where <code>n</code> is the size of the vector. If the scalar type does not match element type of vector, the scalar is copied and <a class="el" href="ax.html#axtypeprecedence">implicitly cast</a> to that type.  </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="text-align:left">Component wise assignment i.e. <br />
 <code>a[0]&#160;=&#160;b;&#160;...&#160;a[n-1]&#160;=&#160;b;</code> <br />
 where <code>n</code> is the size of the vector. <div class="fragment"><div class="line">vec3f a = 0, b = 1;</div><div class="line">a = b;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 0, b = 1;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) a[i] = b[i];</div></div><!-- fragment --> If the right hand side element type does not match the left hand side element type, each element of the right hand side is copied and <a class="el" href="ax.html#axtypeprecedence">implicitly cast </a>to the target left hand side element type. <b>Operand sizes must match.</b> </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="2"><a class="el" href="ax.html#axvecmats">matrix</a> </td><td style="border-top-width: thick;text-align:center" rowspan="2"><code>=</code> </td><td style="border-top-width: thick"><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="border-top-width:thick;text-align:left">Diagonal matrix construction. Each diagonal component of the left hand side matrix is set to to the right hand side scalar. All other components are zero initialized i.e. <div class="fragment"><div class="line">mat3f a;</div><div class="line"><span class="keywordtype">int</span> dim = 3, b = 1;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dim; ++i)</div><div class="line">    a[i] = (i % (dim+1) == 0) ? b : 0;</div></div><!-- fragment --> Where <code>a</code> is the matrix, <code>dim</code> is the dimension of the matrix (e.g. 3 for <code>mat3f</code>) and <code>b</code> is the scalar. If the scalar type does not match element type of matrix, the scalar is copied and <a class="el" href="ax.html#axtypeprecedence">implicitly cast</a> to that type. </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">matrix</a> </td><td style="text-align:left">Component wise assignment i.e. <br />
 <code>a[0]&#160;=&#160;b[0];&#160;...&#160;a[n-1]&#160;=&#160;b[n-1];</code> <br />
 where <code>n</code> is the <b>total</b> size of the matrix. <div class="fragment"><div class="line">mat4f a = 0, b = 1;</div><div class="line">a = b;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat4f a = 0, b = 1;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; ++i) a[i] = b[i];</div></div><!-- fragment --> If the right hand side element type does not match the left hand side element type, each element of the right hand side is copied and <a class="el" href="ax.html#axtypeprecedence">implicitly cast</a> to the target left hand side element type. <b>Operand sizes must match.</b>  </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick"><a class="el" href="ax.html#axstrings">string</a> </td><td style="border-top-width: thick;text-align:center"><code>=</code> </td><td style="border-top-width: thick"><a class="el" href="ax.html#axstrings">string</a> </td><td style="border-top-width: thick;text-align:left">Replaces the contents of the left hand side string with a copy of the contents in the right hand side string.   </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">float</span> b;</div><div class="line">vec3f c = 0.0f; <span class="comment">// assign components of c (x/y/z) to an floating point literal of value 0.0f</span></div><div class="line"><span class="keywordtype">int</span> a = 1; <span class="comment">// assign a from an integer literal of value 1</span></div><div class="line">c = a; <span class="comment">// assign components of c (x/y/z) to the result of float(a)</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Compound Assignment</dt><dd>Compound assignments replace the the contents of the <b><code>lhs</code></b> with the result of a <a class="el" href="ax.html#axopbinarithmetic">binary arithmetic</a> operation of the <b><code>lhs</code></b> with the <b><code>rhs</code></b>: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b>op</b> <em><code>rhs</code></em>  </td></tr>
</table>
Where <b>op</b> is one of : <table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><b><code>+=</code></b> </td><td bgcolor="#ffc4c4"><b><code>-=</code></b> </td><td bgcolor="#ffc4c4"><b><code>*=</code></b> </td><td bgcolor="#ffc4c4"><b><code>/=</code></b> </td><td bgcolor="#ffc4c4"><b><code>%=</code></b> </td><td bgcolor="#ffc4c4"><b><code>&amp;=</code></b> </td><td bgcolor="#ffc4c4"><b><code>|=</code></b> </td><td bgcolor="#ffc4c4"><b><code>^=</code></b> </td><td bgcolor="#ffc4c4"><b><code>&lt;&lt;=</code></b> </td><td bgcolor="#ffc4c4"><b><code>&gt;&gt;=</code></b> </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>The behaviour of a given compound assignment (for example <code>a += b</code>) is similar to replacing the compound assignment with a <a class="el" href="ax.html#axopassignment">direct assignment</a> followed by a <a class="el" href="ax.html#axopbinarithmetic">binary expression</a> with the same operands and given arithmetic token (i.e. <code>a = a + b</code>). However, compound assignments imporantly do <b>not</b> evaluate the <b><code>lhs</code></b> twice. This is important when assigning to an expression which is not an attribute or local value. The best example of this is assigning to a <a class="el" href="ax.html#axopunincdec">pre-crement</a> operation: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 1;</div><div class="line">++a += 1; <span class="comment">// equal to a = ++a + 1 which is equal to 3</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>The <b><code>rhs</code></b> side is not modified, however the <b><code>lhs</code></b> is both read from and written to. Note that the arithmetic operation may cast either <b><code>lhs</code></b> or <b><code>rhs</code></b> following the rules of AX's <a class="el" href="ax.html#axopbinarithmetic">arithmetic type precedence</a>. See the <a class="el" href="ax.html#axopbinarithmetic">arithmetic operations</a> section for more information on arithmetic type precedence and explanations on the above compound operators. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 3;</div><div class="line">a += a; <span class="comment">// the same as a = a + a; a will be set to 6</span></div><div class="line"><span class="keywordtype">float</span> b = 0;</div><div class="line">b -= a; <span class="comment">// the same as b = b - float(a);</span></div><div class="line">a *= b; <span class="comment">// the same as a = float(a) * b; Note that although the target type is int, the binary op is performed at float precision</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt>Assignment Chains</dt><dd>As assignments return a <b>reference</b> to the left hand side, all assignment operators can be <b>chained</b>. Note however that the return result will be at the type of the left hand side. For example: </dd></dl>
<dl class="section user"><dt></dt><dd>Given </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">float</span> a;</div><div class="line"><span class="keywordtype">int</span> b, c;</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>This </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">a = b = c = 4.5f;</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>is fundamentally the same as: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">c = 4.5f; <span class="comment">// c of type int. 4.5f will be floored (int(4.5)). c becomes 4</span></div><div class="line">b = c;    <span class="comment">// b becomes 4</span></div><div class="line">a = b;    <span class="comment">// a becomes float(4)</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Importantly, <b><code>a</code></b> receives the result of any previous implicit casts to the right hand side of its binary assignment.</dd></dl>
</div><h3><a class="anchor" id="axopbinarithmetic"></a>
Arithmetic</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Binary arithmetic operations compute the result of a arithmetic operand token on two inputs and returns the result. The inputs are not modified, however may be copied and <a class="el" href="ax.html#axtypeprecedence">implicitly cast</a> to temporary values if the types do not match. All results are returned as new temporary values. If <b>integral</b> is explicitly stated, the operation is only valid on types which have an integer element type and will involve and implicit cast to integer types for floating point operands (the operation may be further restricted for container types). Binary arithmetic operations have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator&#160;Name</th><th>Operator&#160;Syntax</th><th>Returns </th></tr>
<tr>
<td>Addition</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>+</code></b> <em><code>rhs</code></em> </td><td>The sum of both operands </td></tr>
<tr>
<td>Subtraction</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>-</code></b> <em><code>rhs</code></em> </td><td>The first operand minus the second operand </td></tr>
<tr>
<td>Multiplication</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>*</code></b> <em><code>rhs</code></em> </td><td>The product of both operands </td></tr>
<tr>
<td>Division</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>/</code></b> <em><code>rhs</code></em> </td><td>The first operand divided by the second operand </td></tr>
<tr>
<td>Modulo</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>%</code></b> <em><code>rhs</code></em> </td><td>The <b>floored</b> modulo operator. See <a class="el" href="ax.html#axbinmultop">Multiplicative operands</a> </td></tr>
<tr>
<td>Bitwise AND</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&amp;</code></b> <em><code>rhs</code></em>  </td><td>The <b>integral</b> bitwise AND result of each bit in the first operand applied to the bit at the same location in the second operand </td></tr>
<tr>
<td>Bitwise OR</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>|</code></b> <em><code>rhs</code></em>  </td><td>The <b>integral</b> bitwise OR result of each bit in the first operand applied to the bit at the same location in the second operand </td></tr>
<tr>
<td>Bitwise XOR</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>^</code></b> <em><code>rhs</code></em>  </td><td>The <b>integral</b> bitwise XOR result of each bit in the first operand applied to the bit at the same location in the second operand </td></tr>
<tr>
<td>Bitwise shift left</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&lt;&lt;</code></b> <em><code>rhs</code></em>  </td><td>The <b>integral</b> bitwise left shift of the first operand by the second operand </td></tr>
<tr>
<td>Bitwise shift right</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&gt;&gt;</code></b> <em><code>rhs</code></em>  </td><td>The <b>integral</b> bitwise right shift of the first operand by the second operand </td></tr>
</table>
<a class="anchor" id="axbinadditiveop"></a></dd></dl>
<dl class="section user"><dt>Additive operands</dt><dd>Binary additive operations perform summations on the input arguments. They have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>+</code></b> <em><code>rhs</code></em>  </td></tr>
<tr>
<td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>-</code></b> <em><code>rhs</code></em>  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>After <a class="el" href="ax.html#axtypeprecedence">implicit conversion</a>, the result of the binary operation with the arithmetic <b><code>+</code></b> (<a class="el" href="ax.html#axtokens">plus token</a>) is the sum of the operands, and the result of the binary operation with the arithmetic <b><code>-</code></b> (<a class="el" href="ax.html#axtokens">minus token</a>) token is the second operand subtracted from the first operand. The following combination of AX type categories are supported for additive operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description  </th></tr>
<tr style="text-align:center">
<td rowspan="3"><a class="el" href="ax.html#axscalars">scalar</a></td><td rowspan="3"><code>+</code> <code>-</code></td><td><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="text-align:left">Returns the result of the scalar addition or subtraction.  </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="text-align:left" rowspan="2">Performs per component binary operations (after <a class="el" href="ax.html#axtypeprecedence">implicit conversion</a>) with the left hand side scalar to every element of the right hand side vector or matrix, returning a vector or matrix. <div class="fragment"><div class="line">vec3f a = 2.0f;</div><div class="line"><span class="keywordtype">int</span> b = 1;</div><div class="line">vec3f c = b + a;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2.0f;</div><div class="line"><span class="keywordtype">int</span> b = 1;</div><div class="line">vec3f c;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) c[i] = b + a[i];</div></div><!-- fragment -->   </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">matrix</a>  </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="2"><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="border-top-width: thick; text-align:center" rowspan="2"><code>+</code> <code>-</code> </td><td style="border-top-width: thick"><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="border-top-width: thick;text-align:left">Same as <code>scalar op vector</code>  </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="text-align:left">Performs per component binary operations (after <a class="el" href="ax.html#axtypeprecedence">implicit conversion</a>), returning a new vector with each element holding the corresponding result. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">vec3f a = 2, b = 1;</div><div class="line">vec3f c = a - b;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2, b = 1;</div><div class="line">vec3f c;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) c[i] = a[i] - b[i];</div></div><!-- fragment -->   </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="2"><a class="el" href="ax.html#axvecmats">matrix</a> </td><td style="border-top-width: thick;text-align:center" rowspan="2"><code>+</code> <code>-</code> </td><td style="border-top-width: thick"><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="border-top-width: thick;text-align:left">Same as <code>scalar op matrix</code>  </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">matrix</a> </td><td style="text-align:left">Performs per component binary operations (after <a class="el" href="ax.html#axtypeprecedence">implicit conversion</a>), returning a new matrix with each element holding the corresponding result. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">mat4f a = 0, b = 1;</div><div class="line">mat4f c = a - b;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat4f a = 0, b = 1;</div><div class="line">mat4f c;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; ++i) c[i] = a[i] - b[i];</div></div><!-- fragment -->   </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick"><a class="el" href="ax.html#axstrings">string</a> </td><td style="border-top-width: thick;text-align:center"><code>+</code> </td><td style="border-top-width: thick"><a class="el" href="ax.html#axstrings">string</a> </td><td style="border-top-width: thick;text-align:left">Performs string concatenation  </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Floating point addition and subtraction is communicative (<code>a + b = b + a</code>) but is not <b>necessarily</b> associative. i.e. <code>(a + b) + c</code> is not necessarily equal to <code>a + (b + c)</code>. </dd></dl>
<dl class="section user"><dt></dt><dd>Examples of validity of additive operations: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 0;</div><div class="line">vec2f b = 1.0f;</div><div class="line">vec2i c = 2;</div><div class="line">mat4d d = 0.0;</div><div class="line">c + a; <span class="comment">// valid vec + scalar</span></div><div class="line">c + d; <span class="comment">// invalid vec + matrix</span></div><div class="line">c - b; <span class="comment">// valid vec - scalar</span></div></div><!-- fragment --> <a class="anchor" id="axbinmultop"></a></dd></dl>
<dl class="section user"><dt>Multiplicative operands</dt><dd>The binary multiplicative operands have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>*</code></b> <em><code>rhs</code></em>  </td></tr>
<tr>
<td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>/</code></b> <em><code>rhs</code></em>  </td></tr>
<tr>
<td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>%</code></b> <em><code>rhs</code></em>  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>After <a class="el" href="ax.html#axtypeprecedence">implicit conversion</a>, the result of the binary operation:<ul>
<li>with the arithmetic <b><code>*</code></b> (<a class="el" href="ax.html#axtokens">asterisk token</a>) is:<ul>
<li>the product of the operands</li>
<li><b>OR</b> performs matrix multiplication for vector and matrix types.</li>
</ul>
</li>
<li>with the arithmetic <b><code>/</code></b> (<a class="el" href="ax.html#axtokens">forward slash token</a>) is the first operand divided by the second operand.</li>
<li>with the arithmetic <b><code>%</code></b> (<a class="el" href="ax.html#axtokens">percentage token</a>) is the <b>floored</b> modulo operations .i.e. the expression <code>d % D</code> returns the result <code>D - d * floor(D/d)</code>. This is in contrast to truncated modulo operations <code>D - d * (D/d)</code> where the division is truncated. </li>
</ul>
</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Floored modulo has been chosen to provide better expected behaviour with signed dividends. In such cases the result will always be positive; in other words, the sign of the result is <b>always</b> taken from the divisor. This does however mean that the relationship properties between <code>%</code> and <code>/</code> differ when either <b><code>d</code></b> or <b><code>D</code></b> is negative. i.e.: <code>(d/D)*D + (dD) != d</code> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>The multiplicative operation <b><code>*</code></b> has important behaviour for vectors and matrix types. </dd></dl>
<dl class="section user"><dt></dt><dd>The following combination of AX type categories are supported for multiplicative operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description  </th></tr>
<tr style="text-align:center">
<td rowspan="3"><a class="el" href="ax.html#axscalars">scalar</a></td><td rowspan="2"><code>* / %</code></td><td rowspan="1"><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="text-align:left">Returns the result of the scalar multiplication, division or remainder of the division respectively.   </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="text-align:left" rowspan="1">Performs per component binary operations (after <a class="el" href="ax.html#axtypeprecedence">implicit conversion</a>) with the left hand side scalar to every element of the right hand side vector. The scalar is effectively treated as a vector of the same size as the right hand side type. <div class="fragment"><div class="line">vec3f a = 2.0f;</div><div class="line"><span class="keywordtype">int</span> b = 1;</div><div class="line">vec3f c = b * a;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2.0f;</div><div class="line"><span class="keywordtype">int</span> b = 1;</div><div class="line">vec3f c;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) c[i] = b * a[i];</div></div><!-- fragment -->   </td></tr>
<tr style="text-align:center">
<td rowspan="1"><code>*</code></td><td><a class="el" href="ax.html#axvecmats">matrix</a> </td><td style="text-align:left" rowspan="1">Performs matrix multiplication after diagonal matrix construction from the left hand side scalar. <div class="fragment"><div class="line">mat3f a = 1;</div><div class="line"><span class="keywordtype">float</span> b = 1;</div><div class="line">mat3f c = a * b;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat3f a = 1;</div><div class="line"><span class="keywordtype">float</span> b = 1;</div><div class="line">mat3f tmp = b; <span class="comment">// diagonal matrix</span></div><div class="line">mat3f c = a * tmp;</div></div><!-- fragment -->   </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="3"><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="border-top-width: thick; text-align:center" rowspan="2"><code>* / %</code> </td><td style="border-top-width: thick"><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="border-top-width: thick;text-align:left">Same as <code>scalar op vector</code> with the operands reversed (importantly for division and modulus)  </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="text-align:left">Performs per component binary operations (after <a class="el" href="ax.html#axtypeprecedence">implicit conversion</a>), returning a new vector with each element holding the corresponding result. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">vec3f a = 2, b = 1;</div><div class="line">vec3f c = a * b;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2, b = 1;</div><div class="line">vec3f c;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) c[i] = a[i] * b[i];</div></div><!-- fragment -->   </td></tr>
<tr style="text-align:center">
<td><code>*</code></td><td><a class="el" href="ax.html#axvecmats">matrix</a> </td><td style="text-align:left">Transforms the left hand side vector by the right hand side matrix using matrix multiplication. This is the same as calling the <a class="el" href="axfunctionlist.html#axtransform">transform</a> function. e.g: <div class="fragment"><div class="line">mat4f a = identity4();</div><div class="line">vec3f b = { 1, 2, 3 };</div><div class="line">b = b * a;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat4f a = identity4();</div><div class="line">vec3f b = { 1, 2, 3 };</div><div class="line">b = transform(b, a);</div></div><!-- fragment --> Typically, matrix multiplication requires arguments of the same dimension sizes - that is, a <code>mat4</code> can only be applied to a <code>vec4</code>. However, it is often useful to be able to directly apply <code>mat4</code> transformations to <code>vec3</code> types, most often due to positions being represented as <code>vec3</code>. <code>vec3 * mat4</code> multiplication is supported, where by the <code>vec3</code> is extended with a <code>1</code> component and the resulting last last component is dropped from the return value: <div class="fragment"><div class="line">mat4f a = identity4();</div><div class="line">vec3f b = { 1, 2, 3 };</div><div class="line"><span class="comment">// b * a is equal to:</span></div><div class="line">vec4f tmp;</div><div class="line">tmp[0] = b[0];</div><div class="line">tmp[1] = b[1];</div><div class="line">tmp[2] = b[2];</div><div class="line">tmp[3] = 1;</div><div class="line">tmp = tmp * a;</div><div class="line">b[0] = tmp[0];</div><div class="line">b[1] = tmp[1];</div><div class="line">b[2] = tmp[2];</div></div><!-- fragment --> <b>Note:</b> Valid operand sizes and return types match those of the <a class="el" href="axfunctionlist.html#axtransform">transform</a> function i.e:<ul>
<li><code>vec3 * mat3 = vec3</code></li>
<li><code>vec3 * mat4 = vec3</code></li>
<li><code>vec4 * mat4 = vec4</code>   </li>
</ul>
</td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="3"><a class="el" href="ax.html#axvecmats">matrix</a> </td><td style="border-top-width: thick;text-align:center" rowspan="3"><code>*</code> </td><td style="border-top-width: thick"><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="border-top-width: thick;text-align:left">Same as <code>scalar * matrix</code>  </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="text-align:left">Transforms the right hand side vector by the left hand side matrix using matrix multiplication. This is the same as calling the <a class="el" href="axfunctionlist.html#axpretransform">pretransform</a> function. e.g: <div class="fragment"><div class="line">mat4f a = identity4();</div><div class="line">vec3f b = { 1, 2, 3 };</div><div class="line">b = a * b;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat4f a = identity4();</div><div class="line">vec3f b = { 1, 2, 3 };</div><div class="line">b = pretransform(a, b);</div></div><!-- fragment --> Typically, matrix multiplication requires arguments of the same dimension sizes - that is, a <code>mat4</code> can only be applied to a <code>vec4</code>. However, it is often useful to be able to directly apply <code>mat4</code> transformations to <code>vec3</code> types, most often due to positions being represented as <code>vec3</code>. <code>mat4 * vec3</code> multiplication is supported, where by the <code>vec3</code> is extended with a <code>1</code> component and the resulting last last component is dropped from the return value: <div class="fragment"><div class="line">mat4f a = identity4();</div><div class="line">vec3f b = { 1, 2, 3 };</div><div class="line"><span class="comment">// a * b is equal to:</span></div><div class="line">vec4f tmp;</div><div class="line">tmp[0] = b[0];</div><div class="line">tmp[1] = b[1];</div><div class="line">tmp[2] = b[2];</div><div class="line">tmp[3] = 1;</div><div class="line">tmp = a * tmp;</div><div class="line">b[0] = tmp[0];</div><div class="line">b[1] = tmp[1];</div><div class="line">b[2] = tmp[2];</div></div><!-- fragment --> <b>Note:</b> Valid operand sizes and return types match those of the <a class="el" href="axfunctionlist.html#axpretransform">pretransform</a> function i.e:<ul>
<li><code>mat3 * vec3 = vec3</code></li>
<li><code>mat4 * vec3 = vec3</code></li>
<li><code>mat4 * vec4 = vec4</code>   </li>
</ul>
</td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">matrix</a> </td><td style="text-align:left">Performs matrix multiplication and returns the matrix product, which is matrix of matchign size and type. <b>Operand sizes must match.</b> e.g: <div class="fragment"><div class="line">mat4f a = 1, b = 2;</div><div class="line">mat4f c = a * b;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat4f a = 1, b = 2;</div><div class="line">mat4f c;</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 4; ++i) {</div><div class="line">    <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 4; ++j) {</div><div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 4; ++k) {</div><div class="line">            c[i,j] += a[i,k] * b[k,j];</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment -->   </td></tr>
</table>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Floating point multiplication is communicative (<code>a * b = b * a</code>) but is not <b>necessarily</b> associative. i.e. <code>(a * b) * c</code> is not necessarily equal to <code>a * (b * c)</code>.</dd></dl>
<a class="anchor" id="axbinbitwiseop"></a><dl class="section user"><dt>Bitwise operands</dt><dd>Binary bitwise operations have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&amp;</code></b> <em><code>rhs</code></em>  </td></tr>
<tr>
<td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code></b>|</code> <em><code>rhs</code></em>  </td></tr>
<tr>
<td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>^</code></b> <em><code>rhs</code></em>  </td></tr>
<tr>
<td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&lt;&lt;</code></b> <em><code>rhs</code></em>  </td></tr>
<tr>
<td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&gt;&gt;</code></b> <em><code>rhs</code></em>  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>These operations only run on <b>integral</b> operands. After <a class="el" href="ax.html#axtypeprecedence">implicit conversion</a>, the result of the binary operation:<ul>
<li>with the <b><code>&amp;</code></b> (<a class="el" href="ax.html#axtokens">ampersand token</a>) is the result of the logical AND operation on each pair of the corresponding bits of the input operands.</li>
<li>with the <b><code></b>|</code> (<a class="el" href="ax.html#axtokens">pipe token</a>) is the result of the logical OR operation on each pair of the corresponding bits of the input operands.</li>
<li>with the <b><code>^</code></b> (<a class="el" href="ax.html#axtokens">hat token</a>) is the result of the logical XOR operation on each pair of the corresponding bits of the input operands.</li>
<li>with the <b><code>&lt;&lt;</code></b> (<a class="el" href="ax.html#axtokens">less than tokens</a>) is the value shifted left with zeros shifted in on the right.</li>
<li>with the <b><code>&gt;&gt;</code></b> (<a class="el" href="ax.html#axtokens">greater than tokens</a>) is the value shifted right with zeros shifted in on the left. </li>
</ul>
</dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description  </th></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axscalars">intergral</a> </td><td><code>&amp; | ^ &lt;&lt; &gt;&gt;</code> </td><td><a class="el" href="ax.html#axscalars">intergral</a> </td><td style="text-align:left">Returns the result of the bitwise operation as described above. If either operand is not an integral type (<code>bool</code> <code>int32</code> or <code>int64</code>), the program is ill formed.  </td></tr>
</table>
</dd></dl>
</div><h3><a class="anchor" id="axopcomparison"></a>
Comparisons / Relational</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Binary comparison and relational operations compute the result of a equality operand token on two inputs and returns the result. The inputs are not modified, however may be copied and <a class="el" href="ax.html#axtypeprecedence">implicitly cast</a> to temporary values if the types do not match. The result type of all comparison operators is of type <b><code>bool</code></b>. Binary comparison operations have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator&#160;Name</th><th>Operator&#160;Syntax</th><th>Returns </th></tr>
<tr>
<td>Equal to</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>==</code></b> <em><code>rhs</code></em>  </td><td>Returns <code>true</code> if both operands are equal </td></tr>
<tr>
<td>Not equal to</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>!=</code></b> <em><code>rhs</code></em>  </td><td>Returns <code>true</code> if operands are not equal </td></tr>
<tr>
<td>Less than</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&lt;</code></b> <em><code>rhs</code></em>  </td><td>Returns <code>true</code> the left hand side value is less than the right hand side </td></tr>
<tr>
<td>Greater than</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&gt;</code></b> <em><code>rhs</code></em>  </td><td>Returns <code>true</code> the left hand side value is greater than the right hand side </td></tr>
<tr>
<td>Less than or equal to</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&lt;=</code></b> <em><code>rhs</code></em>  </td><td>Returns <code>true</code> the left hand side value is less than or equal to the right hand side </td></tr>
<tr>
<td>Greater than or equal to</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&gt;=</code></b> <em><code>rhs</code></em>  </td><td>Returns <code>true</code> the left hand side value is greater than or equal to the right hand side </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>The following combination of AX type categories are supported for comparison operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description  </th></tr>
<tr style="text-align:center">
<td rowspan="3"><a class="el" href="ax.html#axscalars">scalar</a></td><td rowspan="3"><code>== != &lt; &gt; &lt;= &gt;=</code></td><td><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="text-align:left">Returns the result of the scalar comparison.  </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="text-align:left" rowspan="2">Performs per component comparisons (after <a class="el" href="ax.html#axtypeprecedence">implicit conversion</a>) with the lefthand side scalar to every element of the right hand side vector or matrix and perform a logical AND combination on the results of these comparisons. This effectively returns true if every element of the vector or matrix is equal to the scalar. <div class="fragment"><div class="line">vec3f a = 2.0f;</div><div class="line"><span class="keywordtype">int</span> b = 1;</div><div class="line"><span class="keywordtype">bool</span> c = b == a;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2.0f;</div><div class="line"><span class="keywordtype">int</span> b = 1;</div><div class="line"><span class="keywordtype">bool</span> c = a[0] == b;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 3; ++i) c &amp;= a[i] == b;</div></div><!-- fragment -->   </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">matrix</a>  </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="2"><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="border-top-width: thick; text-align:center" rowspan="2"><code>== != &lt; &gt; &lt;= &gt;=</code> </td><td style="border-top-width: thick"><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="border-top-width: thick;text-align:left">Same as <code>scalar op vector</code>  </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="text-align:left">Performs binary comparison operations (after <a class="el" href="ax.html#axtypeprecedence">implicit conversion</a>) on each pair corresponding components in the vector operands and returns true if all component pairs are equal. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">vec3f a = 1, b = 2;</div><div class="line"><span class="keywordtype">bool</span> c = a == b;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 1, b = 2;</div><div class="line"><span class="keywordtype">bool</span> c = a[0] == b[0];</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 3; ++i) c &amp;= a[i] == b[i];</div></div><!-- fragment -->   </td></tr>
<tr style="text-align:center">
<td style="border-top-width: thick" rowspan="2"><a class="el" href="ax.html#axvecmats">matrix</a> </td><td style="border-top-width: thick; text-align:center" rowspan="2"><code>== != &lt; &gt; &lt;= &gt;=</code> </td><td style="border-top-width: thick"><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="border-top-width: thick;text-align:left">Same as <code>scalar op matrix</code>  </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">matrix</a> </td><td style="text-align:left">Performs binary comparison operations (after <a class="el" href="ax.html#axtypeprecedence">implicit conversion</a>) on each pair corresponding components in the matrix operands and returns true if all component pairs are equal. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">mat4f a = 1, b = 2;</div><div class="line"><span class="keywordtype">bool</span> c = a == b;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">mat4f a = 1, b = 2;</div><div class="line"><span class="keywordtype">bool</span> c = a[0] == b[0];</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; 16; ++i) c &amp;= a[i] == b[i];</div></div><!-- fragment -->   </td></tr>
</table>
</dd></dl>
</div><h3><a class="anchor" id="axopbinlogical"></a>
Logical</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Binary logical operations compute and return the result of a boolean operation on two operands. Both operands are implicitly converted to <b><code>bool</code></b> types if they are not already. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>These operators are short-circuiting; for logical AND, the second operand is only evaluated if the first is <b>true</b>. For logical OR, the second operand is only evaluated if the first is <b>false</b>. In both cases, the first operand is always evaluated. </dd></dl>
<dl class="section user"><dt></dt><dd>They have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator&#160;Name</th><th>Operator&#160;Syntax</th><th>Returns </th></tr>
<tr>
<td>AND</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>&amp;&amp;</code></b> <em><code>rhs</code></em>  </td><td>Returns true if both operands are true. Otherwise, the result is false. This operator is short-circuiting. </td></tr>
<tr>
<td>Inclusive OR</td><td bgcolor="#ffc4c4"><em><code>lhs</code></em> <b><code>||</code></b> <em><code>rhs</code></em>  </td><td>Returns true if either the first or the second operand is true. This operator is short-circuiting. </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>The following combination of AX type categories are supported for comparison operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Left Operand Type</th><th>Binary Op(s)</th><th>Right Operand Type</th><th>Description  </th></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axscalars">scalar</a></td><td><code>&amp;&amp; ||</code></td><td><a class="el" href="ax.html#axscalars">scalar</a> </td><td style="text-align:left">Returns the result of the scalar logical operation. Both scalars are converted to bools if they are not already.  </td></tr>
</table>
</dd></dl>
</div><h2><a class="anchor" id="axopunary"></a>
Unary Operators</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Unary operators only execute on a single value. The operator token(s) may come before or after the value, precedence of which is defined by AX's <a class="el" href="ax.html#axopprecedence">operator precedence</a>. Arithmetic, logical and increment / decrement operators are supported.</dd></dl>
</div><h3><a class="anchor" id="axopunarithmetic"></a>
Arithmetic</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Arithmetic unary operators are comprised of arithemtic and bitwise operators. </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator Name</th><th>Operator Syntax</th><th>Returns </th></tr>
<tr>
<td>Unary plus</td><td bgcolor="#ffc4c4"><b><code>+</code></b><em><code>a</code></em>  </td><td>Returns the value of its operand, <b><code>a</code></b>   </td></tr>
<tr>
<td>Unary minus</td><td bgcolor="#ffc4c4"><b><code>-</code></b><em><code>a</code></em>  </td><td>Returns the negative representation of <b><code>a</code></b>   </td></tr>
<tr>
<td>Bitwise NOT</td><td bgcolor="#ffc4c4"><b><code>~</code></b><em><code>a</code></em>  </td><td>Returns the bitwise NOT (one's complement) value of <b><code>a</code></b>. This operator is only valid on integral element types.  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>The following combination of AX type categories are supported for unary arithmetic operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Operand Type</th><th>Binary Op(s)</th><th>Description  </th></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axscalars">scalar</a></td><td rowspan="2"><code>+ - ~</code> </td><td style="text-align:left">Returns the result of the scalar unary operations.  </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="text-align:left">Performs per component unary operations, returning a new vector with each element holding the corresponding result. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">vec3f a = 2;</div><div class="line">vec3f b = -a;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2;</div><div class="line">vec3f b;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) b[i] = -a[i];</div></div><!-- fragment --> <b>Note:</b> The bitwise not <code>~</code> operator is only valid on integer vector types; <code>vec2i</code>, <code>vec3i</code> and <code>vec4i</code>.   </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">matrix</a></td><td><code>+ -</code> </td><td style="text-align:left">Performs per component unary operations, returning a new matrix with each element holding the corresponding result. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">vec3f a = 2;</div><div class="line">vec3f b = -a;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3f a = 2;</div><div class="line">vec3f b;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) b[i] = -a[i];</div></div><!-- fragment -->   </td></tr>
</table>
</dd></dl>
</div><h3><a class="anchor" id="axopunlogical"></a>
Logical</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Logical unary operators consist of a single operand. </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator Name</th><th>Operator Syntax</th><th>Returns </th></tr>
<tr>
<td>Logical NOT</td><td bgcolor="#ffc4c4"><b><code>!</code></b><em><code>a</code></em>  </td><td>Returns true if the operand is false. Otherwise, returns false.  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>The following combination of AX type categories are supported for logical unary operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Operand Type</th><th>Binary Op(s)</th><th>Description  </th></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axscalars">scalar</a></td><td rowspan="2"><code>!</code> </td><td style="text-align:left">Returns the result of the scalar logical operation. The scalar operand is converted to a bool if it is not already.  </td></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axvecmats">vector</a> </td><td style="text-align:left">Performs per component unary operations, returning a new vector with each element holding the corresponding result. <b>Operand sizes must match.</b> <div class="fragment"><div class="line">vec3i a = 2;</div><div class="line">vec3i b = !a;</div></div><!-- fragment --> is equal to: <div class="fragment"><div class="line">vec3i a = 2;</div><div class="line">vec3i b;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i) b[i] = !a[i];</div></div><!-- fragment --> <b>Note:</b> The logical not <code>!</code> operator is only valid on integer vector types; <code>vec2i</code>, <code>vec3i</code> and <code>vec4i</code>.   </td></tr>
</table>
</dd></dl>
</div><h3><a class="anchor" id="axopunincdec"></a>
Increment / Decrement</h3>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Increment/decrement operators increment or decrement the value of a scalar, or each component of a vector or matrix. They have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator Name</th><th>Operator Syntax</th><th>Returns </th></tr>
<tr>
<td>Pre-increment</td><td bgcolor="#ffc4c4"><b><code>++</code></b><em><code>a</code></em> </td><td>Returns a reference to the incremented result. </td></tr>
<tr>
<td>Post-increment</td><td bgcolor="#ffc4c4"><em><code>a</code><b><code>++</code></b></em> </td><td>Returns a copy of the incremented result. </td></tr>
<tr>
<td>Pre-decrement</td><td bgcolor="#ffc4c4"><b><code>--</code></b><em><code>a</code></em> </td><td>Returns a reference to the decremented result. </td></tr>
<tr>
<td>Post-decrement</td><td bgcolor="#ffc4c4"><em><code>a</code><b><code>--</code></b></em> </td><td>Returns a copy of the decremented result.  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Importantly, pre evaluation returns a reference to the value operand, where as post evaluation returns a copy of the operand. The following combination of AX type categories are supported for logical unary operations (if an operation is not listed, it is not supported): </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<th>Operand Type</th><th>Binary Op(s)</th><th>Description  </th></tr>
<tr style="text-align:center">
<td><a class="el" href="ax.html#axscalars">scalar</a> </td><td><code>++(pre) (post)++</code> <br />
 <code>--(pre) (post)--</code> </td><td style="text-align:left">Returns the result (reference or copy) of the scalar increment or decrement operation.<br />
<b>Note:</b> boolean incrementation and decrementation is not supported. Only <code>int32</code>, <code>int64</code>, <code>float</code> and <code>double</code> types are valid.   </td></tr>
</table>
</dd></dl>
</div><h2><a class="anchor" id="axopaccess"></a>
Container Access</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Container access operators are valid on AX Vector and matrix types. They have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator Name</th><th>Operator Syntax</th><th>Returns </th></tr>
<tr style="text-align:left">
<td>Dot&#160;Component&#160;Access </td><td bgcolor="#ffc4c4"><em><code>vector</code>&#160;<b></em>.</b>&#160;<em><code>component</code></em>  </td><td>Reference to component <em><code>component</code></em> of <em><code>vector</code></em>   </td></tr>
<tr style="text-align:left">
<td>Container&#160;Component&#160;Access </td><td bgcolor="#ffc4c4"><em><code>container</code>&#160;<b></em>[</b>&#160;<em><code>exp</code></em> <b>]</b>  </td><td>Reference to component at index <em><code>exp</code></em> of <em><code>container</code></em>   </td></tr>
<tr style="text-align:left">
<td>Matrix&#160;Component&#160;Access </td><td bgcolor="#ffc4c4"><em><code>matrix</code>&#160;<b></em>[</b>&#160;<em><code>exp1</code></em>,&#160;<em><code>exp2</code>&#160;<b></em>]</b>  </td><td>Reference to component in row <b><em><code>exp1</code></b></em>, column <b><em><code>exp2</code></b></em>. Also equal to returning a reference to component at index: <b> <em><code></em>[exp1&#160;*&#160;dimension&#160;+&#160;exp2]</code> </b> of <em><code>matrix</code></em> where <em><code>dimension</code></em> is the the size of the matrix  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>As data is stored contiguously for both vectors and matrices, the <b><code>[]</code></b> operator is valid for both types. However the <b>.</b> operator is only valid on vector types, and the <b><code>[,]</code></b> operator is only valid on matrix types. As return values for these operators are references, any modifications through <a class="el" href="ax.html#axopassignment">assignments</a> will update the stored value in the container. </dd></dl>
<dl class="section user"><dt>. operator</dt><dd>The dot operator <b>.</b> is only valid for vector types. It has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><em><code>vector</code></em> <b>.</b> <em><code>component</code></em>  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Where component is one of the below supported component letters. It only provides access for the first three elements of any vector (for <b><code>vec2</code></b> types, only the first 2 components are accessible). Accessing a vector using the dot operator is fundamentally the same as using the <b><code></b>[]</code> operator with the corresponding integer index. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">vec4i a = { 6, 7, 8, 9 };</div><div class="line"><span class="keywordtype">int</span> b = a.z; <span class="comment">// get the the third elements value (8)</span></div></div><!-- fragment --> <center> <p class="formulaDsp">
<img class="formulaDsp" alt="\[ A=\begin{bmatrix} a_{0}\quad a_{1}\quad a_{2} \end{bmatrix} \]" src="form_3.png"/>
</p>
 <table class="doxtable">
<tr>
<th align="center">Component </th><th align="center">Access Index </th><th align="center">Result  </th></tr>
<tr>
<td align="center"><b><code>A.x</code></b> </td><td align="center">0 </td><td align="center"><img class="formulaInl" alt="$ a_{0} $" src="form_4.png"/> </td></tr>
<tr>
<td align="center"><b><code>A.r</code></b> </td><td align="center">0 </td><td align="center"><img class="formulaInl" alt="$ a_{0} $" src="form_4.png"/> </td></tr>
<tr>
<td align="center"><b><code>A.y</code></b> </td><td align="center">1 </td><td align="center"><img class="formulaInl" alt="$ a_{1} $" src="form_5.png"/> </td></tr>
<tr>
<td align="center"><b><code>A.g</code></b> </td><td align="center">1 </td><td align="center"><img class="formulaInl" alt="$ a_{1} $" src="form_5.png"/> </td></tr>
<tr>
<td align="center"><b><code>A.z</code></b> </td><td align="center">2 </td><td align="center"><img class="formulaInl" alt="$ a_{2} $" src="form_6.png"/> </td></tr>
<tr>
<td align="center"><b><code>A.b</code></b> </td><td align="center">2 </td><td align="center"><img class="formulaInl" alt="$ a_{2} $" src="form_6.png"/> </td></tr>
</table>
</center> </dd></dl>
<dl class="section user"><dt></dt><dd>This operator can provide more immediately readability when working with expressions that focus on colour or Cartesian coordinate systems. <a class="anchor" id="axvecaccessop"></a></dd></dl>
<dl class="section user"><dt>[] operator</dt><dd>The <b><code></b>[]</code> operator is valid for both vectors and matrices. It has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><em><code>container</code></em> <b>[</b> <em><code>exp</code></em> <b>]</b>  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd><em><code>exp</code></em> is expected to evaluate to a value which is castable to an integer following the <a class="el" href="ax.html#axopassignment">assignment casting</a> rules and falls within the valid size of the <em><code>container</code></em>. <b>No bounds checking is performed</b>. </dd></dl>
<dl class="section user"><dt></dt><dd>As matrices are also an array of contigous values, they can be accessed in the same way. This can make some operations much simplier; a typical example being iterating through all matrix elements and performing some logic: </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">vec3f a = 0;</div><div class="line">a[0] = 1; <span class="comment">// valid</span></div><div class="line">a[<span class="stringliteral">&quot;&quot;</span>] = 1; <span class="comment">// invalid - can&#39;t cast to int</span></div><div class="line">a[1.2f] = 1; <span class="comment">// valid - float exp will be clamped to an int</span></div><div class="line">a[a[0]] = 1; <span class="comment">// valid - use the value of a[0] to index into a</span></div><div class="line"><span class="comment">// assign each element its actual index value i.e. b[5] = 5;</span></div><div class="line">mat4d b;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 16; ++i) b[i] = i;</div></div><!-- fragment --> <a class="anchor" id="axmataccessop"></a></dd></dl>
<dl class="section user"><dt>[,] operator</dt><dd>The <b><code></b>[,]</code> operator is only valid for matrices. It has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><em><code>matrix</code></em> <b>[</b> <em><code>exp1</code></em>, <em><code>exp2</code></em> <b>]</b>  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd><em><code>exp1</code></em> and <em><code>exp2</code></em> are expected to evaluate to a value which is castable to an integer following the <a class="el" href="ax.html#axopassignment">assignment casting</a> rules and falls within the valid size of the <em><code>matrix</code></em> dimensions. <b>No bounds checking is performed</b>. In general it is more readable to use this operator when accessing specific elements, where <b><code>exp1</code></b> is the row index and <b><code>exp2</code></b> is the column index. The tables below show the different access patterns for <b><code>3x3</code></b> and <b><code>4x4</code></b> matrices. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line">mat3f a;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 3; ++i)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 3; ++j)</div><div class="line">        a[i,j] = i*j; <span class="comment">// assign matrix element the product of its index</span></div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr style="text-align:center">
<td style="border:none" colspan="3"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A=\begin{bmatrix} a_{00}\quad a_{01}\quad a_{02}\\ a_{10}\quad a_{11}\quad a_{12}\\ a_{20}\quad a_{21}\quad a_{22}\\ \end{bmatrix} \]" src="form_7.png"/>
</p>
  </td><td style="border:none"></td><td style="border:none" colspan="3"><p class="formulaDsp">
<img class="formulaDsp" alt="\[ A=\begin{bmatrix} a_{00}\quad a_{01}\quad a_{02}\quad a_{03}\\ a_{10}\quad a_{11}\quad a_{12}\quad a_{13}\\ a_{20}\quad a_{21}\quad a_{22}\quad a_{23}\\ a_{30}\quad a_{31}\quad a_{32}\quad a_{33}\\ \end{bmatrix} \]" src="form_8.png"/>
</p>
   </td></tr>
<tr style="text-align:center">
<th>Access [a] </th><th>Access [a,b] </th><th style="border-right-style:none;">Result </th><td style="border:none" rowspan="17"></td><th>Access [a] </th><th>Access [a,b] </th><th>Result  </th></tr>
<tr style="text-align:center">
<td><code>A[0]</code> </td><td><code>A[0,0]</code> </td><td><img class="formulaInl" alt="$ a_{00} $" src="form_9.png"/> </td><td><code>A[0]</code> </td><td><code>A[0,0]</code> </td><td><img class="formulaInl" alt="$ a_{00} $" src="form_9.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[1]</code> </td><td><code>A[0,1]</code> </td><td><img class="formulaInl" alt="$ a_{01} $" src="form_10.png"/> </td><td><code>A[1]</code> </td><td><code>A[0,1]</code> </td><td><img class="formulaInl" alt="$ a_{01} $" src="form_10.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[2]</code> </td><td><code>A[0,2]</code> </td><td><img class="formulaInl" alt="$ a_{02} $" src="form_11.png"/> </td><td><code>A[2]</code> </td><td><code>A[0,2]</code> </td><td><img class="formulaInl" alt="$ a_{02} $" src="form_11.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[3]</code> </td><td><code>A[1,0]</code> </td><td><img class="formulaInl" alt="$ a_{10} $" src="form_12.png"/> </td><td><code>A[3]</code> </td><td><code>A[0,3]</code> </td><td><img class="formulaInl" alt="$ a_{03} $" src="form_13.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[4]</code> </td><td><code>A[1,1]</code> </td><td><img class="formulaInl" alt="$ a_{10} $" src="form_12.png"/> </td><td><code>A[4]</code> </td><td><code>A[1,0]</code> </td><td><img class="formulaInl" alt="$ a_{10} $" src="form_12.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[5]</code> </td><td><code>A[1,2]</code> </td><td><img class="formulaInl" alt="$ a_{12} $" src="form_14.png"/> </td><td><code>A[5]</code> </td><td><code>A[1,1]</code> </td><td><img class="formulaInl" alt="$ a_{11} $" src="form_15.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[6]</code> </td><td><code>A[2,0]</code> </td><td><img class="formulaInl" alt="$ a_{20} $" src="form_16.png"/> </td><td><code>A[6]</code> </td><td><code>A[1,2]</code> </td><td><img class="formulaInl" alt="$ a_{12} $" src="form_14.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[7]</code> </td><td><code>A[2,1]</code> </td><td><img class="formulaInl" alt="$ a_{21} $" src="form_17.png"/> </td><td><code>A[7]</code> </td><td><code>A[1,3]</code> </td><td><img class="formulaInl" alt="$ a_{13} $" src="form_18.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[8]</code> </td><td><code>A[2,2]</code> </td><td><img class="formulaInl" alt="$ a_{22} $" src="form_19.png"/> </td><td><code>A[8]</code> </td><td><code>A[2,0]</code> </td><td><img class="formulaInl" alt="$ a_{20} $" src="form_16.png"/>  </td></tr>
<tr style="text-align:center">
<td style="border:none;" colspan="3" rowspan="7"></td><td><code>A[9]</code> </td><td><code>A[2,1]</code> </td><td><img class="formulaInl" alt="$ a_{21} $" src="form_17.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[10]</code> </td><td><code>A[2,2]</code> </td><td><img class="formulaInl" alt="$ a_{22} $" src="form_19.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[11]</code> </td><td><code>A[2,3]</code> </td><td><img class="formulaInl" alt="$ a_{23} $" src="form_20.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[12]</code> </td><td><code>A[3,0]</code> </td><td><img class="formulaInl" alt="$ a_{30} $" src="form_21.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[13]</code> </td><td><code>A[3,1]</code> </td><td><img class="formulaInl" alt="$ a_{31} $" src="form_22.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[14]</code> </td><td><code>A[3,2]</code> </td><td><img class="formulaInl" alt="$ a_{32} $" src="form_23.png"/>  </td></tr>
<tr style="text-align:center">
<td><code>A[15]</code> </td><td><code>A[3,3]</code> </td><td><img class="formulaInl" alt="$ a_{33} $" src="form_24.png"/>  </td></tr>
</table>
</dd></dl>
</div><h2><a class="anchor" id="axopother"></a>
Other</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>A number of uncategorised operators that are more general are documented in this section. They have the following forms: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Operator Name</th><th>Operator Syntax</th><th>Returns </th></tr>
<tr style="text-align:left">
<td>Call / Explicit Cast </td><td bgcolor="#ffc4c4"><em><code>a</code><b><code></em>(...)</code></b> </td><td>Returns the result of a function call or inbuilt explicit cast  </td></tr>
<tr style="text-align:left">
<td>Comma </td><td bgcolor="#ffc4c4"><em><code>a</code><b></em>,</b>&#160; <em><code>b</code></em>  </td><td>Returns the value of <b><code>b</code></b> after chained evaluation  </td></tr>
<tr style="text-align:left">
<td>Ternary Conditional </td><td bgcolor="#ffc4c4"><em><code>a</code>&#160;<b><code></em>?</code></b>&#160;<em><code>b</code>&#160;<b><code></em>:</code></b> <em><code>c</code></em>  </td><td><b><code>b</code></b> if <b><code>a</code></b> is <b>true</b>, <b><code>c</code></b> otherwise.  </td></tr>
<tr>
<td>Vector/Matrix Initializer </td><td bgcolor="#ffc4c4"><b><code>{</code></b>&#160;<em><code>a</em>,&#160;</code><em><code>b&#160;</code><b><code></em>...&#160;}</code></b>  </td><td>Returns a temporary vector or matrix  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt>Call / Explicit Cast</dt><dd>The function call operator provides the ability to invoke functions <b>or</b> invoke a supported explicit cast. It has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><em><code>func</em>(</code><em><code>a</code></em>, <em><code>b</code></em>, <em><code>c</code></em> <code>...)</code> </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Where <b><code>func</code></b> is a function name <b>or</b> a valid explicit cast typename. Explicit casts are only supported for <a class="el" href="ax.html#axscalars">scalar types</a>. For example: <div class="fragment"><div class="line"><span class="keywordtype">int</span> a = int(1.1f);</div><div class="line">vec3f b = 1.0f;</div><div class="line">a = int(b.x);</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>Whilst explicit casts take only a single argument, the operator itself supports multiple or empty arguments for function calls. Whe multiple arguments are provided, they are parsed from first to last and processed in reverse order. <b>However</b>, the order of runtime evaluation is <b>unspecified</b> i.e. they may evaluate in any order. Each function parameter is initialized with its corresponding argument after following implicit conversion of assignments where necessary. </dd></dl>
<dl class="section user"><dt></dt><dd>See the <a class="el" href="ax.html#axfunctions">function documentation</a> for more information on functions. </dd></dl>
<dl class="section user"><dt>Comma</dt><dd>The Comma operator has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><em><code>a</code><b><code></em>,</code> </b><em><code>b</code></em>  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Where <b><code>a</code></b> and <b><code>b</code></b> are expressions. Chained expressions evaluate each expression in syntactical order (first to last), discarding any return value except for the last expression, which is returned from the entire list. Note that although return values for any expression but the last are discarded, their side effects are still applied before subsequent expression are evaluated. For example: <div class="fragment"><div class="line"><span class="keywordtype">int</span> a = 5;</div><div class="line">a-=1, a+=2; <span class="comment">// a = 6</span></div><div class="line">a = a--, ++a; <span class="comment">// exp1: a = a--, exp2: ++a. a = 7</span></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Although you may consider the comma operator as a type of binary operator, it is fundamentally different as the types either side of the operator do <b>not</b> interact. Each expression in the comma operator is evaluated independently of all other expressions.</dd></dl>
<a class="anchor" id="axopternary"></a><dl class="section user"><dt>Ternary Conditional</dt><dd>The ternary conditional operator can be thought of as an in-line <a class="el" href="ax.html#axbranching">if-else statement</a> that returns a value, where each of the if/else branches has a single expression that will be returned. It has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><em><code>a</code>&#160;<b><code></em>?</code></b>&#160;<em><code>b</code>&#160;<b><code></em>:</code></b> <em><code>c</code></em>  </td></tr>
</table>
Where <b><code>a</code></b> is the condition, evaluated and converted to <b>bool</b>, and <b><code>b</code></b> and <b><code>c</code></b> are expressions of the same or implicit-castable types. <b><code>b</code></b> is evaluated and returned if the condition is <b>true</b>, <b><code>c</code></b> is evaluated and returned if the condition is <b>false</b>. Only the expression out of <b><code>b</code></b> and <b><code>c</code></b> that is returned will be evaluated. Expressions with no return value (a.k.a <b><code>void</code></b>) are supported as long as <b><code>b</code></b> and <b><code>c</code></b> are both of this type. </dd></dl>
<dl class="section user"><dt></dt><dd>Also supported is the 'Elvis' operator, <b><code>a</code></b> <b><code></b>?</code> <b><code></b>:</code> <b><code>c</code></b> (or <code>?:</code>). Here, <b><code>a</code></b> is evaluated once, and if when converted to <b>bool</b> is <b>true</b>, <b><code>a</code></b> is returned, otherwise <b><code>c</code></b> is evaluated and returned. In this case, <b><code>a</code></b> and <b><code>c</code></b> must be the same or implicit-castable types, and both implicit-castable to <b>bool</b>.</dd></dl>
<a class="anchor" id="axvecmatinit"></a><dl class="section user"><dt>Vector/Matrix Initializer</dt><dd><a class="el" href="ax.html#axvecmats">Vectors and matrices</a> can be represented as local variables (e.g. <b><code>vec3f</code></b>), external attributes or parameters (e.g. <b><code>vec3f@attrib</code></b>) or as temporary values using the vector/matrix initializer syntax. This operator has the form: </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<td bgcolor="#ffc4c4"><b><code>{</code></b>&#160;<em><code>a</em>,&#160;</code><em><code>b&#160;</code><b><code></em>...&#160;}</code></b>  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Where <b><code>a</code></b> and <b><code>b</code></b> are expressions returning a scalar value. When this operator is invoked with a specific number of arguments, a vector or matrix is implicitly created with a copy of those arguments which can be assigned to an existing container of matching size. Expression in the operator are evaluated from first to last. This operator is only valid with argument lists of sizes 2, 3, 4, 9 and 16, which implicitly represent <b>vec2, vec3, vec4, mat3,</b> and <b>mat4</b> types respectively. For example: <div class="fragment"><div class="line">vec3f a = { 1.0f, 2.0f, 3.0f }; <span class="comment">// right hand side of assignment creates a vec3f</span></div><div class="line">vec3f b = dot(a, { a[0], 5.0, 6.0 }); <span class="comment">// second argument creates a vec3d</span></div></div><!-- fragment --> </dd></dl>
<dl class="section note"><dt>Note</dt><dd>In the above examples, the value of <b><code>a</b>[0]</code> is copied into the initializer operator. </dd></dl>
<dl class="section user"><dt>Initialization Type</dt><dd>A mixture of arbitrary scalar types can be used in the initializer operator e.g: <div class="fragment"><div class="line">mat3f a = {</div><div class="line">    <span class="keyword">true</span>, 0s, 0,</div><div class="line">    0l, 0.0f, 0.0,</div><div class="line">    <span class="keyword">false</span>, 1, 2</div><div class="line">};</div></div><!-- fragment --> </dd></dl>
<dl class="section user"><dt></dt><dd>The temporary container evaluates all expressions and uses the <b>highest</b> ranking type (as defined by <a class="el" href="ax.html#axtypeprecedence">arithmetic type precedence</a>) to infer the element type of the container, implicitly casting all other types to that type where necessary. In the above example, the temporary created forms a <b><code>mat3d</code></b>, before being implicitly cast to a <b><code>mat3f</code></b> due to the assignment.</dd></dl>
</div><h2><a class="anchor" id="axopprecedence"></a>
Operator Precedence</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>The below table shows the precedence and associativity of all AX operators. Operators are listed in descending precedence. </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th style="text-align: left">Precedence </th><th style="text-align: left">Operator </th><th style="text-align: left">Description </th><th style="text-align: left">Associativity  </th></tr>
<tr>
<th>1 </th><td><code>()</code>  </td><td>Parenthesis  </td><td style="vertical-align: top" rowspan="5">Left-to-right  </td></tr>
<tr>
<th rowspan="4">2 </th><td style="border-bottom-style: none"><code>a++</code> <code>a--</code> </td><td style="border-bottom-style: none">Suffix/postfix <a class="el" href="ax.html#axopunincdec">Increment / Decrement</a>   </td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code><em>type</em>()</code> </td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="ax.html#axopother">Functional cast</a>  </td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>a()</code> </td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="ax.html#axopother">Function call</a>  </td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>a[]</code> <code>.</code> </td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="ax.html#axopaccess">Container Access</a>   </td></tr>
<tr>
<th rowspan="3">3 </th><td style="border-bottom-style: none"><code>++a</code> <code>--a</code> </td><td style="border-bottom-style: none">Prefix <a class="el" href="ax.html#axopunincdec">Increment / Decrement</a>  </td><td style="vertical-align: top" rowspan="3">Right-to-left  </td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>+a</code> <code>-a</code> </td><td style="border-bottom-style: none; border-top-style: none">Unary <a class="el" href="ax.html#axopbinarithmetic">plus and minus</a>  </td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>!</code> <code>~</code> </td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="ax.html#axopbinlogical">Logical</a> NOT and <a class="el" href="ax.html#axopunlogical">Logical</a> NOT  </td></tr>
<tr>
<th>4 </th><td><code>a*b</code> <code>a/b</code> <code>ab</code> </td><td><a class="el" href="ax.html#axopbinarithmetic">Multiplication, division, and remainder</a>  </td><td style="vertical-align: top" rowspan="11">Left-to-right  </td></tr>
<tr>
<th>5 </th><td><code>a+b</code> <code>ab</code> </td><td><a class="el" href="ax.html#axopbinarithmetic">Addition and subtraction</a>   </td></tr>
<tr>
<th>6 </th><td><code>&lt;&lt;</code> <code>&gt;&gt;</code> </td><td><a class="el" href="ax.html#axopbinarithmetic">Bitwise left shift and right shift</a>   </td></tr>
<tr>
<th rowspan="2">7 </th><td style="border-bottom-style: none"><code>&lt;</code> <code>&lt;=</code> </td><td style="border-bottom-style: none">For <a class="el" href="ax.html#axopcomparison">Comparisons / Relational</a> operators &lt; and  respectively  </td></tr>
<tr>
<td style="border-top-style: none"><code>&gt;</code> <code>&gt;=</code> </td><td style="border-top-style: none">For <a class="el" href="ax.html#axopcomparison">Comparisons / Relational</a> operators &gt; and  respectively  </td></tr>
<tr>
<th>8 </th><td><code>==</code> <code>!=</code> </td><td>For <a class="el" href="ax.html#axopcomparison">Comparisons / Relational</a> operators = and  respectively  </td></tr>
<tr>
<th>9 </th><td><code>&amp;</code> </td><td><a class="el" href="ax.html#axopbinarithmetic">Arithmetic</a> AND  </td></tr>
<tr>
<th>10 </th><td><code>^</code> </td><td><a class="el" href="ax.html#axopbinarithmetic">Arithmetic</a> XOR (exclusive or)  </td></tr>
<tr>
<th>11 </th><td><code>|</code> </td><td><a class="el" href="ax.html#axopbinarithmetic">Arithmetic</a> OR (inclusive or)  </td></tr>
<tr>
<th>12 </th><td><code>&amp;&amp;</code> </td><td><a class="el" href="ax.html#axopbinlogical">Logical</a> AND  </td></tr>
<tr>
<th>13 </th><td><code>||</code> </td><td><a class="el" href="ax.html#axopbinlogical">Logical</a> OR  </td></tr>
<tr>
<th rowspan="6">14 </th><td style="border-bottom-style: none; border-top-style: none"><code>a?b:c</code> </td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="ax.html#axopternary">Ternary operator</a>  </td><td style="vertical-align: top" rowspan="6">Right-to-left  </td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>=</code> </td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="ax.html#axopassignment">Direct assignment</a>   </td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>+=</code> <code>-=</code> </td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="ax.html#axopassignment">Compound assignment</a> by sum and difference  </td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>*=</code> <code>/=</code> <code>%=</code> </td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="ax.html#axopassignment">Compound assignment</a> by product, quotient, and remainder  </td></tr>
<tr>
<td style="border-bottom-style: none; border-top-style: none"><code>&lt;&lt;=</code> <code>&gt;&gt;=</code> </td><td style="border-bottom-style: none; border-top-style: none"><a class="el" href="ax.html#axopassignment">Compound assignment</a> by bitwise left shift and right shift  </td></tr>
<tr>
<td style="border-top-style: none"><code>&amp;=</code> <code>^=</code> <code>|=</code> </td><td style="border-top-style: none"><a class="el" href="ax.html#axopassignment">Compound assignment</a> by bitwise AND, XOR, and OR  </td></tr>
<tr>
<th>15 </th><td><code>,</code> </td><td><a class="el" href="ax.html#axopother">Comma</a>  </td><td>Left-to-right </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd>Note that associativity of unary operators is redundant (unary prefix operators are always right-to-left and unary postfix operators are always left-to-right). Operators that have the same precedence are bound to their arguments in the direction of their associativity. For example, the expression <b><code>a = b = c</code></b> is parsed as <b><code>a = (b = c)</code></b>, and not as <b><code>(a = b) = c</code></b> because of right-to-left associativity of assignment, but <b><code>a + b  c</code></b> is parsed <b><code>(a + b)  c</code></b> and not <b><code>a + (b  c)</code></b> because of left-to-right associativity of addition and subtraction. <b>Note</b> that this is based off the <a href="https://en.cppreference.com/w/cpp/language/operator_precedence">C++ operator precedence</a>.</dd></dl>
<br />
<hr/>
</div><div style="width:800px;text-align:justify;"></div><h1><a class="anchor" id="axtokens"></a>
Tokens</h1>
<div style="width:800px;text-align:justify;"></div><h2><a class="anchor" id="axvaridentifiers"></a>
Variable Identifiers</h2>
<div style="width:800px;text-align:justify;"></div><div style="width:800px;text-align:justify;"></div><h2><a class="anchor" id="axliterals"></a>
Literals</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>Literals can be thought of as constant values that are known at compile time. e.g. <div class="fragment"><div class="line">i@a = 1; <span class="comment">// the number 1 is a literal</span></div></div><!-- fragment --> As AX supports different bit width scalar literals, it also supports suffix literal tokens which, when using with a scalar literal, represent a literal of a specific size. AX also supports implicit casting for all <a class="el" href="ax.html#axopassignment">assignment</a> and <a class="el" href="ax.html#axopbinarithmetic">arithmetic</a> operations, so any literal can be used to assign any scalar a value. </dd></dl>
<dl class="section user"><dt></dt><dd><table class="doxtable">
<tr>
<th>Type</th><th>Literal Tokens </th></tr>
<tr>
<td><code>bool</code></td><td>Tokens <b><code>true</code></b> and <b><code>false</code></b>  </td></tr>
<tr>
<td><code>int32</code></td><td>No suffix, automatically infered from integral literals </td></tr>
<tr>
<td><code>int64</code></td><td>The letter <b><code>l</code></b> e.g.<div class="fragment"><div class="line">int64 a = 10l; </div></div><!-- fragment --> </td></tr>
<tr>
<td><code>float</code></td><td>The letter <b><code>f</code></b> e.g.<div class="fragment"><div class="line"><span class="keywordtype">float</span> a = 0.0f; </div></div><!-- fragment --> </td></tr>
<tr>
<td><code>double</code></td><td>No suffix, automatically infered from floating point literals. </td></tr>
<tr>
<td><code>string</code></td><td>Character strings wrapped in double quotes <b>"</b> <b>"</b>  </td></tr>
</table>
</dd></dl>
<dl class="section user"><dt></dt><dd></dd></dl>
</div><h2><a class="anchor" id="axcomments"></a>
Comments</h2>
<div style="width:800px;text-align:justify;"></div><h2><a class="anchor" id="axkeywords"></a>
Keywords</h2>
<div style="width:800px;text-align:justify;"></div><h2><a class="anchor" id="axreserved"></a>
Reserved Keywords</h2>
<div style="width:800px;text-align:justify;"> <br />
<hr/>
</div><div style="width:800px;text-align:justify;"></div><h1><a class="anchor" id="axsyntax"></a>
Syntax</h1>
<div style="width:800px;text-align:justify;"></div><div style="width:800px;text-align:justify;"></div><h2><a class="anchor" id="axattribaccess"></a>
Attribute Access</h2>
<div style="width:800px;text-align:justify;"></div><div style="width:800px;text-align:justify;"><div class="fragment"><div class="line"><span class="keywordtype">float</span>@surface = <span class="keywordtype">float</span>@density;</div></div><!-- fragment --> <dl class="section user"><dt></dt><dd>Assignment operations determine which volumes will be executed over. Here, the AX program will only execute on the <b>surface</b> VDB whilst retaining access to all available VDBs. There exists a number of possible states of both the <b>surface</b> and <b>density</b> volumes.<ul>
<li>Volumes have the same transform and the same topology</li>
<li>Volumes have the same transform, but different topologies</li>
<li>Volumes have different transforms, but the same topology</li>
<li>Volumes have different transforms and different topologies </li>
</ul>
</dd></dl>
<dl class="section user"><dt>Matching Transforms</dt><dd>In the simplest case, all volumes processed have the same transform. Active voxels in the <b>surface</b> VDB will receive a value sampled (<a class="el" href="ax.html#axattribaccess">point sampled</a>) at the corresponding <b>index</b> space position in the <b>density</b> VDB. As the transforms match, this is guaranteed to be at the same <b>world</b> space position. The topology of the <b>density</b> VDB does not influence which values are assigned, AX simply queries the <b>density</b> VDB at the computed position and uses whatever value is returned. This may be the VDB <b>Background</b> value. </dd></dl>
<dl class="section user"><dt>Different Transforms</dt><dd>When transforms differ, AX performs coordinate transformations from the source VDB to the target VDB. Using some simple pseudo code, we can represent each voxel's coordinate query: <div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;foreach(ActiveVoxel in surface)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    SurfaceIndexSpaceCoord = ActiveVoxel.indexSpaceCoordinate();</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    SurfaceWorldSpaceCoord = surface.transformToWorld(SurfaceIndexSpaceCoord);</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    DensityIndexSpaceCoord = density.transformToIndex(SurfaceWorldSpaceCoord);</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;    ActiveVoxel = density.getValue(DensityIndexSpaceCoord);</div></div><!-- fragment --> done() &ndash;&gt;</dd></dl>
</div><h2><a class="anchor" id="axexternalaccess"></a>
External Parameter Access</h2>
<div style="width:800px;text-align:justify;"></div><h2><a class="anchor" id="axdecls"></a>
Declarations</h2>
<div style="width:800px;text-align:justify;"></div><h2><a class="anchor" id="axscopes"></a>
Scopes</h2>
<div style="width:800px;text-align:justify;"></div><h2><a class="anchor" id="axbranching"></a>
Branching (if / else)</h2>
<div style="width:800px;text-align:justify;"></div><h2><a class="anchor" id="axloops"></a>
Loops</h2>
<div style="width:800px;text-align:justify;"></div><div style="width:800px;text-align:justify;"><br />
<hr/>
</div><div style="width:800px;text-align:justify;"></div><h1><a class="anchor" id="axfunctions"></a>
Functions</h1>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>For a list of all functions, see the <a class="el" href="axfunctionlist.html">AX Function List</a>. </dd></dl>
<dl class="section user"><dt></dt><dd>AX supports a variety of mathematical, string, utility and custom function calls which can be used from within an AX program. Native function support is constantly growing and we encourage users who wish to see particular methods exposed and supported natively by AX to contact us. Whilst we can't guarantee to accommodate every function, these requests provide the developers insights into how the language is being used. </dd></dl>
<dl class="section user"><dt>Function Execution Context</dt><dd>Some functions depend on the currently processing <a class="el" href="ax.html#axexecutionxcontext">OpenVDB Execution Context</a> to work correctly and will fail if called from an "invalid" context. Specifically, there exists functions which operate on OpenVDB points or OpenVDB volume grids and interact with the point or voxel data. Some of these methods are incompatible for the other grid type (for example, <a class="el" href="axfunctionlist.html#axdeletepoint">deleting a point from a Point Data Grid</a>) and will result in the compilation failure of an AX program if an attempt is made it use them.</dd></dl>
</div><h2><a class="anchor" id="axuserfunctions"></a>
User Functions</h2>
<div style="width:800px;text-align:justify;"><dl class="section user"><dt></dt><dd>User function declarations are not currently supported, but exist on the <a href="https://github.com/dneg/openvdb_ax/blob/master/ROADMAP.md">AX Roadmap</a> as a near future feature.</dd></dl>
<br />
<hr/>
</div><div style="width:800px;text-align:justify;"></div><h1><a class="anchor" id="axvexsupport"></a>
AX VEX Support</h1>
<div style="width:800px;text-align:justify;"> </div> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
