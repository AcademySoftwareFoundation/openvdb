<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: Transforms and Maps</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenVDB</a></li><li class="navelem"><a class="el" href="overview.html">OpenVDB Overview</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Transforms and Maps </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="sMathContents"></a>
Contents</h1>
<ul>
<li><a class="el" href="transformsAndMaps.html#sTransforms">Transforms in OpenVDB</a><ul>
<li><a class="el" href="transformsAndMaps.html#sLinearTransforms">Linear Transforms</a></li>
<li><a class="el" href="transformsAndMaps.html#sFrustumTransforms">Frustum Transforms</a></li>
<li><a class="el" href="transformsAndMaps.html#sCellVsVertex">Cell-Centered vs. Vertex-Centered Transforms</a></li>
<li><a class="el" href="transformsAndMaps.html#sVoxels">Voxel Interpretations</a></li>
<li><a class="el" href="transformsAndMaps.html#sStaggered">Staggered Velocity Grids</a></li>
</ul>
</li>
<li><a class="el" href="transformsAndMaps.html#sMaps">Maps in OpenVDB Transforms</a><ul>
<li><a class="el" href="transformsAndMaps.html#sGettingMat4">An Equivalent Matrix Representation</a></li>
<li><a class="el" href="transformsAndMaps.html#sCostOfMaps">Working Directly with Maps</a></li>
<li><a class="el" href="transformsAndMaps.html#sGradientAndMaps">Maps and Mathematical Operations</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="sTransforms"></a>
Transforms in OpenVDB</h1>
<p>The OpenVDB <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html">Tree</a> is a sparse representation of a three-dimensional array of voxels, each element of which is addressed via discrete, three-dimensional index space coordinates, typically in the form of a <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Coord.html">Coord</a>. For example, the following code retrieves the floating-point value of a voxel with index coordinates&#160;(1,&#160;2,&#160;3): </p><div class="fragment"><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::FloatGrid</a> grid = ...;</div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#a52aaec5921d1852ab1d33a064f1d13eb">openvdb::FloatGrid::Accessor</a> accessor = grid.<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afd9327e5a015e2e860017765f0eb372c">getAccessor</a>();</div><div class="line">openvdb::Coord ijk(1,2,3);</div><div class="line"><span class="keywordtype">float</span> value = accessor.getValue(ijk);</div></div><!-- fragment --><p>A <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html">Transform</a> relates index space coordinates to world space coordinates that give a spatial context for the discretized data. Translation from index coordinates (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) to world space coordinates (<em>x</em>,&amp;nbsp <em>y</em>,&amp;nbsp <em>z</em>) is done with a call to the <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html#a9b0e6d022b2571d4b0551704406ac4ba">indexToWorld</a> method, and from world space coordinates to index space coordinates with a call to <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html#a917d728a21347bc8528cfdcd0cbada38">worldToIndex</a>: </p><div class="fragment"><div class="line"><span class="comment">// Create a linear transform that scales i, j and k by 0.1</span></div><div class="line">openvdb::math::Transform::Ptr linearTransform =</div><div class="line">    openvdb::math::Transform::createLinearTransform(0.1);</div><div class="line"></div><div class="line"><span class="comment">// Compute the location in world space that is the image of (1,2,3).</span></div><div class="line"><span class="comment">// The result will be (0.1, 0.2, 0.3).</span></div><div class="line">openvdb::Coord ijk(1,2,3);</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a> worldSpacePoint = linearTransform-&gt;indexToWorld(ijk);</div><div class="line"></div><div class="line"><span class="comment">// Compute the location in index space that is the pre-image of (0.1, 0.2, 0.3).</span></div><div class="line"><span class="comment">// The result will be (1.0, 2.0, 3.0).</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a> indexSpacePoint = linearTransform-&gt;worldToIndex(worldSpacePoint);</div></div><!-- fragment --><p> In the above example, there are two things to notice. First, world space locations are specified as three-dimensional, double-precision, floating-point vectors, and second, <b>worldToIndex</b> does not return discrete coordinates, but rather a floating-point vector. This is a reflection of the fact that not every location in a continuous world space, i.e., not every (<em>x</em>,&amp;nbsp <em>y</em>,&amp;nbsp <em>z</em>), is the image of discrete integral coordinates (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>).</p>
<h2><a class="anchor" id="sLinearTransforms"></a>
Linear Transforms</h2>
<p>Currently two different types of transforms are supported: linear and frustum transforms. A linear transform can be composed of scale, translation, rotation, and shear; essentially those things that can be mathematically represented by an invertible, constant-coefficient, 3&times;3 matrix and a translation (mathematically, an affine map). An essential feature of a linear transformation is that it treats all regions of index space equally: a small box in index space about origin (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>)=(0,0,0) is mapped (sheared, scaled, rotated, etc.) in just the same way that a small box about any other index point is mapped. </p><div class="fragment"><div class="line"><span class="comment">// Create a linear transform from a 4x4 matrix (identity in this example).</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">openvdb::math::Mat4d</a> mat = openvdb::math::Mat4d::identity();</div><div class="line">openvdb::math::Transform::Ptr linearTransform =</div><div class="line">    openvdb::math::Transform::createLinearTransform(mat);</div><div class="line"></div><div class="line"><span class="comment">// Rotate the transform by 90 degrees about the X axis.</span></div><div class="line"><span class="comment">// As a result the j-index will now map into the -z physical direction,</span></div><div class="line"><span class="comment">// and the k-index will map to the +y physical direction.</span></div><div class="line">linearTransform-&gt;preRotate(M_PI/2, <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#ae3996976d8ffb3e58d88f58227473f8ea93ed1386222f87948b972889ad82cd33">openvdb::math::X_AXIS</a>);</div></div><!-- fragment --><h2><a class="anchor" id="sFrustumTransforms"></a>
Frustum Transforms</h2>
<p>The frustum transform is a nonlinear transform that treats different index points differently. And while the linear transform can be applied to any point in index or world space, the frustum transform is designed to operate on a subset of space. Specifically, it transforms a given box in index space to a tapered box in world space that is a frustum of a rectangular pyramid. </p><div class="fragment"><div class="line"><span class="comment">// Create the bounding box that will be mapped by the transform into</span></div><div class="line"><span class="comment">// the shape of a frustum.</span></div><div class="line"><span class="comment">// The points (0,0,0), (100,0,0), (0,50,0) and (100,50,0) will map to</span></div><div class="line"><span class="comment">// the corners of the near plane of the frustum, while the corners</span></div><div class="line"><span class="comment">// of the far plane will be the images of (0,0,120), (100,0,120),</span></div><div class="line"><span class="comment">// (0,50,120) and (100,50,120).</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceopenvdb_1_1v8__1.html#aa7e17f708810f66dc1d195abaf1e9dbf">openvdb::math::BBoxd</a> bbox(<span class="comment">/*min=*/</span><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a>(0,0,0),</div><div class="line">                                <span class="comment">/*max=*/</span><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a>(100,50,120));</div><div class="line"></div><div class="line"><span class="comment">// The far plane of the frustum will be twice as big as the near plane.</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> taper = 2;</div><div class="line"></div><div class="line"><span class="comment">// The depth of the frustum will be 10 times the x-width of the near plane.</span></div><div class="line">cosnt <span class="keywordtype">double</span> depth = 10;</div><div class="line"></div><div class="line"><span class="comment">// The x-width of the frustum in world space units</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> xWidth = 100;</div><div class="line"></div><div class="line"><span class="comment">// Construct a frustum transform that results in a frustum whose</span></div><div class="line"><span class="comment">// near plane is centered on the origin in world space.</span></div><div class="line">openvdb::math::Transform::Ptr frustumTransform =</div><div class="line">    openvdb::math:::Transform::createFrustumTransform(</div><div class="line">        bbox, taper, depth, xWidth);</div><div class="line"></div><div class="line"><span class="comment">// The frustum shape can be rotated, scaled, translated and even</span></div><div class="line"><span class="comment">// sheared if desired.  For example, the following call translates</span></div><div class="line"><span class="comment">// the frustum by 10,15,0 in world space:</span></div><div class="line">frustumTransform-&gt;postTranslate(<a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a>(10,15,0));</div><div class="line"></div><div class="line"><span class="comment">// Compute the world space image of a given point within</span></div><div class="line"><span class="comment">// the index space bounding box that defines the frustum.</span></div><div class="line">openvdb::Coord ijk(20,10,18);</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a> worldLocation = frustumTransform-&gt;indexToWorld(ijk);</div></div><!-- fragment --><h2><a class="anchor" id="sCellVsVertex"></a>
Cell-Centered vs. Vertex-Centered Transforms</h2>
<p>When partitioning world space with a regular grid, two popular configurations are cell-centered and vertex-centered grids. This is really a question of interpretation and transforms.</p>
<p>The cell-centered interpretation imagines world space as divided into discrete cells (e.g., cubes) centered on the image of the index-space lattice points. So the physical location (<em>x</em>,&amp;nbsp <em>y</em>,&amp;nbsp <em>z</em>) that is the image (result of <b>indexToWorld</b>) of a lattice point (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) is the center of a cube. In the vertex-centered approach, the images of the lattice points form the vertices of cells, so the location (<em>x</em>,&amp;nbsp <em>y</em>,&amp;nbsp <em>z</em>) would be a corner, not the center, of a cube.</p>
<p>The link between transforms and cell-centered or vertex-centered partitioning of world space is tenuous. It boils down to this: the &ldquo;first&rdquo; cell vertex often is aligned with the origin. In the cell-centered case, when the cells are cubes of length &Delta; on a side, the transform (<em>x</em>,&amp;nbsp <em>y</em>,&amp;nbsp <em>z</em>) = (&Delta;<em>i</em> + &Delta;/2, &Delta;<em>j</em> + &Delta;/2, &Delta;<em>k</em> + &Delta; /2) will place the center of the first cube (i.e., the image of (0,0,0)) at the world space location of (&Delta;/2,&#160;&Delta;/2,&#160;&Delta;/2), and the cube will have walls coincident with the <em>x</em>=0, <em>y</em>=0 and <em>z</em>=0 planes. Using the OpenVDB transforms to create a so-called cell-centered transform could be done like this: </p><div class="fragment"><div class="line"><span class="comment">// -- Constructing a uniform, cell-centered transform --</span></div><div class="line"></div><div class="line"><span class="comment">// The grid spacing</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> delta = 0.1;</div><div class="line"></div><div class="line"><span class="comment">// The offset to cell-center points</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a> offset(delta/2., delta/2., delta/2.);</div><div class="line"></div><div class="line"><span class="comment">// A linear transform with the correct spacing</span></div><div class="line">openvdb::math::Transform::Ptr transform =</div><div class="line">    openvdb::math:::Transform::createLinearTransform(delta);</div><div class="line"></div><div class="line"><span class="comment">// Add the offset.</span></div><div class="line">transform-&gt;postTranslate(offset);</div></div><!-- fragment --><p> In contrast, for the vertex-centered partitions of space the first vertex is just the image of the first lattice point (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) = (0,0,0), and the transform would lack the offset used in the cell-centered case; so it would simply be (<em>x</em>,&amp;nbsp <em>y</em>,&amp;nbsp <em>z</em>) = (&Delta;<em>i</em>,&#160;&Delta;<em>j</em>,&#160;&Delta;<em>k</em>). </p><div class="fragment"><div class="line"><span class="comment">// -- Constructing a uniform, vertex-centered transform --</span></div><div class="line"></div><div class="line"><span class="comment">// The grid spacing</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> delta = 0.1;</div><div class="line"></div><div class="line"><span class="comment">// A linear transform with the correct spacing</span></div><div class="line">openvdb::math::Transform::Ptr transform =</div><div class="line">    openvdb::math:::Transform::createLinearTransform(delta);</div></div><!-- fragment --><h2><a class="anchor" id="sVoxels"></a>
Voxel Interpretations</h2>
<p>A similar and often related concept to cell- and vertex-centered partitioning of world space is the idea of a voxel. A voxel historically refers to the volumetric equivalent of a pixel and as such implies a small region of world space. A voxel could, for instance, be the image under transform of a vertex-centered (or cell-centered) box in index space. In this way the voxel can be seen as a generalization of regular grid cells. The interpretation of data stored in a grid can be related to the concept of a voxel but need not be. An application might interpret the grid value indexed by (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) as the spatial average of a quantity in a defined world-space voxel centered on the image of that lattice point. But in other situations the value stored at (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) might be a discrete sample taken from a single point in world space.</p>
<p>The <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html">Transform</a> class does include methods such as <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html#abe11d7ce015c713f29f88fb376e22d0f">voxelSize</a> and <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html#a23d36bbeb278f0e9ff86bc45dbeb1338">voxelVolume</a> that suppose a particular interpretation of a voxel. They assume a voxel that is the image of a vertex-centered cube in index space, so the <b>voxelSize</b> methods return the lengths of line segments in world space that connect vertices: </p><div class="fragment"><div class="line">openvdb::Coord ijk(0,0,0);</div><div class="line">openvdb::Coord tmp0(1,0,0), tmp1(0,1,0), tmp2(0,0,1);</div><div class="line"></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a> size;</div><div class="line">size.<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html#af59136c0fb2c6ccc665bbc1c1f19a751">x</a>() = (xform.indexToWorld(ijk + tmp0) - xform.indexToWorld(ijk)).length();</div><div class="line">size.y() = (xform.indexToWorld(ijk + tmp1) - xform.indexToWorld(ijk)).length();</div><div class="line">size.z() = (xform.indexToWorld(ijk + tmp2) - xform.indexToWorld(ijk)).length();</div><div class="line"></div><div class="line"><span class="comment">// The voxelSize() for the voxel at (0,0,0) is consistent with</span></div><div class="line"><span class="comment">// the computation above.</span></div><div class="line">assert(xform.voxelSize(ijk) == size);</div></div><!-- fragment --><p> In the case where the transform is linear, the result of <b>voxelSize</b> will be independent of the actual location (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>), but the voxel size for a nonlinear transform such as a frustum will be spatially varying. The related <b>voxelVolume</b> can not in general be computed from the <b>voxelSize</b>, because there is no guarantee that a general transform will convert a cube-shaped voxel into another cube. As a result, <b>voxelVolume</b> actually returns the determinant of the transform, which will be a correct measure of volume even if the voxel is sheared into a general parallelepiped.</p>
<h2><a class="anchor" id="sStaggered"></a>
Staggered Velocity Grids</h2>
<p>Staggered velocity data is often used in fluid simulations, and the relationship between data interpretation and transforms is somewhat peculiar when using a vector grid to hold staggered velocity data. In this case the lattice point (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) identifies a cell in world space by mapping to the cell&rsquo;s center, but each element of the velocity vector is identified with a different face of the cell. The first element of the vector is identified with the image of the (<em>i</em>&minus;1/2,&#160;<em>j</em>,&#160;<em>k</em>) face, the second element with (<em>i</em>,&#160;<em>j</em>&minus;1/2,&#160;<em>k</em>), and the third element with (<em>i</em>,&#160;<em>j</em>,&#160;<em>k</em>&minus;1/2).</p>
<h1><a class="anchor" id="sMaps"></a>
Maps in OpenVDB Transforms</h1>
<p>The actual work of a <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html">Transform</a> is performed by an implementation object called a <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1MapBase.html">Map</a>. The <b>Map</b> in turn is a polymorphic object whose derived types are designed to optimally represent the most common transformations. Specifically, the <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html">Transform</a> holds a <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1MapBase.html">MapBase</a> pointer to a derived type that has been simplified to minimize calculations. When the transform is updated by prepending or appending a linear operation (e.g., with <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html#a827df214068afcf258e91d06dc9d52a8">preRotate</a>), the implementation map is recomputed and simplified if possible. For example, in many level-set-oriented applications the transform between index space and world space is simply a uniform scaling of the index points, i.e., (<em>x</em>,&amp;nbsp <em>y</em>,&amp;nbsp <em>z</em>) = (&Delta;<em>i</em>,&#160;&Delta;<em>j</em>,&#160;&Delta;<em>k</em>), where &Delta; has some world space units. For transforms such as this, the implementation is a <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1UniformScaleMap.html">UniformScaleMap</a>. </p><div class="fragment"><div class="line"><span class="comment">// Create a linear transform that scales i, j and k by 0.1</span></div><div class="line">openvdb::math::Transform::Ptr linearTransform =</div><div class="line">    openvdb::math::Transform::createLinearTransform(0.1);</div><div class="line"></div><div class="line"><span class="comment">// Create an equivalent map.</span></div><div class="line">openvdb::math::UniformScaleMap uniformScale(0.1);</div><div class="line"></div><div class="line"><span class="comment">// At this time the map holds a openvdb::math::UniformScaleMap.</span></div><div class="line">assert(linearTransform-&gt;mapType() == openvdb::math::UniformScaleMap::type());</div><div class="line"></div><div class="line">openvdb::Coord ijk(1,2,3);</div><div class="line"></div><div class="line"><span class="comment">// Applying the transform...</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a> transformResult = linearTransform-&gt;indexToWorld(ijk);</div><div class="line"></div><div class="line"><span class="comment">// ...is equivalent to applying the map.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a> mapResult = uniformScale.applyMap(ijk);</div><div class="line"></div><div class="line">assert(mapResult == transformResult);</div></div><!-- fragment --><p>There are specialized maps for a variety of common linear transforms: pure translation (<a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1TranslationMap.html">TranslationMap</a>), uniform scale (<a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1UniformScaleMap.html">UniformScaleMap</a>), uniform scale and translation (<a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1UniformScaleTranslateMap.html">UniformScaleTranslateMap</a>), non-uniform scale (<a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1ScaleMap.html">ScaleMap</a>), and non-uniform scale and translation (<a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1ScaleTranslateMap.html">ScaleTranslateMap</a>). A general affine map (<a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1AffineMap.html">AffineMap</a>) is used for all other cases (those that include non-degenerate rotation or shear).</p>
<h2><a class="anchor" id="sGettingMat4"></a>
An Equivalent Matrix Representation</h2>
<p>The matrix representation used within OpenVDB adheres to the minority convention of right-multiplication of the matrix against a vector: </p><div class="fragment"><div class="line"><span class="comment">// Example matrix transform that scales, next translates,</span></div><div class="line"><span class="comment">// and finally rotates an incoming vector</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">openvdb::math::Mat4d</a> transform = openvdb::math::Mat4d::identity();</div><div class="line">transform.preScale(<a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a>(2,3,2));</div><div class="line">transform.postTranslate(<a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a>(1,0,0));</div><div class="line">transform.postRotate(<a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#ae3996976d8ffb3e58d88f58227473f8ea93ed1386222f87948b972889ad82cd33">openvdb::math::X_AXIS</a>, M_PI/3.0);</div><div class="line"></div><div class="line"><span class="comment">// Location of a point in index space</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a> indexSpace(1,2,3);</div><div class="line"></div><div class="line"><span class="comment">// Apply the transform by right-multiplying the matrix.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a> worldSpace = indexSpace * transform;</div></div><!-- fragment --><p> Any linear map can produce an equivalent <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1AffineMap.html">AffineMap</a>, which in turn can produce an equivalent 4&times;4 matrix. Starting with a linear transform one can produce a consistent matrix as follows: </p><div class="fragment"><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">openvdb::math::Mat4d</a> matrix;</div><div class="line"><span class="keywordflow">if</span> (transform-&gt;isLinear()) {</div><div class="line">   <span class="comment">// Get the equivalent 4x4 matrix.</span></div><div class="line">   matrix = transform-&gt;getBaseMap()-&gt;getAffineMap()-&gt;getMat4();</div><div class="line">}</div></div><!-- fragment --><p>This could be used as an intermediate form when constructing new linear transforms by combining old ones. </p><div class="fragment"><div class="line"><span class="comment">// Get the matrix equivalent to linearTransformA.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">openvdb::math::Mat4d</a> matrixA =</div><div class="line">    linearTransformA-&gt;getBaseMap()-&gt;getAffineMap()-&gt;getMat4();</div><div class="line"></div><div class="line"><span class="comment">// Invert the matrix equivalent to linearTransformB.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#abaf7f913bf1752b9157259ffa32704ca">openvdb::math::Mat4d</a> matrixBinv =</div><div class="line">    (linearTransformB-&gt;getBaseMap()-&gt;getAffineMap()-&gt;getMat4()).inverse();</div><div class="line"></div><div class="line"><span class="comment">// Create a new transform that maps the index space of linearTransformA</span></div><div class="line"><span class="comment">// to the index space of linearTransformB.</span></div><div class="line">openvdb::math::Transform::Ptr linearTransformAtoB =</div><div class="line">    openvdb::math::Trasform::createLinearTransform(matrixA * matrixBinv);</div></div><!-- fragment --><p> Notice that in the above example, the internal representation used by the transform will be simplified if possible to use one of the various map types.</p>
<h2><a class="anchor" id="sCostOfMaps"></a>
Working Directly with Maps</h2>
<p>Accessing a transform&rsquo;s map through virtual function calls introduces some overhead and precludes compile-time optimizations such as inlining. For this reason, the more computationally intensive OpenVDB tools are templated to work directly with any underlying map. This allows the tools direct access to the map&rsquo;s simplified representation and gives the compiler a free hand to inline.</p>
<p>Maps themselves know nothing of index space and world space, but are simply functions <em>x</em><sub><em>range</em></sub> = <em>f</em>(<em>x</em><sub><em>domain</em></sub>) that map 3-vectors from one space (the domain) to another (the range), or from the range back to the domain (<em>x</em><sub><em>domain</em></sub> = <em>f</em><sup>&minus;1</sup>(<em>x</em><sub><em>range</em></sub>)), by means of the methods <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1MapBase.html#ab73d501388bb6b4da00a3604a1f1d907">applyMap</a> and <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1MapBase.html#a23e1a30c6ff6d75a23ed489b157e8ffe">applyInverseMap</a>.</p>
<div class="fragment"><div class="line"><span class="comment">// Create a simple uniform scale map that scales by 10.</span></div><div class="line">openvdb::math::UniformScaleMap usm(10.0);</div><div class="line"></div><div class="line"><span class="comment">// A point in the domain</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a> domainPoint(0,1,3);</div><div class="line"></div><div class="line"><span class="comment">// The resulting range point</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::math::Vec3d</a> rangePoint = usm.applyMap(domainPoint);</div><div class="line"></div><div class="line"><span class="comment">// The map is inverted thus:</span></div><div class="line">assert(domainPoint == usm.applyInverseMap(rangePoint));</div></div><!-- fragment --><p>In many tools, the actual map type is not known a priori and must be deduced at runtime prior to calling the appropriate map-specific or map-templated code. The type of map currently being used by a transform can be determined using the <a class="el" href="classopenvdb_1_1v8__1_1_1math_1_1Transform.html#af6d21e5dd5380c8db96b67e6eea75b77">mapType</a> method: </p><div class="fragment"><div class="line"><span class="comment">// Test for a uniform scale map.</span></div><div class="line"><span class="keywordflow">if</span> (transform-&gt;mapType() == openvdb::math::UniformScaleMap::type()) {</div><div class="line"></div><div class="line">   <span class="comment">// This call would return a null pointer in the case of a map type mismatch.</span></div><div class="line">   openvdb::math::UniformScaleMap::ConstPtr usm =</div><div class="line">       transform-&gt;map&lt;openvdb::math::UniformScaleMap&gt;();</div><div class="line"></div><div class="line">   <span class="comment">// Call a function that accepts UniformScaleMaps.</span></div><div class="line">   dofoo(*usm)</div><div class="line">}</div></div><!-- fragment --><p>To simplify this process, the function <a class="el" href="namespaceopenvdb_1_1v8__1_1_1math.html#a837303adeabe103cd8664384971e696d">processTypedMap</a> has been provided. It accepts a transform and a functor templated on the map type.</p>
<h2><a class="anchor" id="sGradientAndMaps"></a>
Maps and Mathematical Operations</h2>
<p>In addition to supporting the mapping of a point from one space to another, maps also support mapping of local gradients. This results from use of the chain rule of calculus in computing the Jacobian of the map. Essentially, the gradient calculated in the domain of a map can be converted to the gradient in the range of the map, allowing one to compute a gradient in index space and then transform it to a gradient in world space. </p><div class="fragment"><div class="line"><span class="comment">// Compute the gradient at a point in index space in a</span></div><div class="line"><span class="comment">// floating-point grid using the second-order central difference.</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::FloatGrid</a> grid = ...;</div><div class="line">openvdb::Coord ijk(2,3,5)</div><div class="line"><a class="code" href="namespaceopenvdb.html">openvdb</a>::math::<a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a> isGrad =</div><div class="line">    <a class="code" href="namespaceopenvdb.html">openvdb</a>::math::ISGradient&lt;CD_2D&gt;::result(grid, ijk);</div><div class="line"></div><div class="line"><span class="comment">// Apply the inverse Jacobian transform to convert the result to the</span></div><div class="line"><span class="comment">// gradient in the world space defined by a map that scales index space</span></div><div class="line"><span class="comment">// to create voxels of size 0.1 x 0.2 x 0.1</span></div><div class="line"><a class="code" href="namespaceopenvdb.html">openvdb</a>::math::ScaleMap scalemap(0.1, 0.2, 0.1);</div><div class="line"><a class="code" href="namespaceopenvdb.html">openvdb</a>::math::<a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">Vec3d</a> wsGrad = scalemap.applyIJT(isGrad);</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
