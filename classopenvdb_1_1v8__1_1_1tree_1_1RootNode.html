<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: RootNode&lt; ChildType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__1.html">v8_1</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1tree.html">tree</a></li><li class="navelem"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RootNode&lt; ChildType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="RootNode_8h_source.html">RootNode.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1RootNode_1_1SameConfiguration.html">SameConfiguration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1RootNode_1_1SameConfiguration.html#a11ddd051208250c32dc4985abcafa86d">SameConfiguration&lt;OtherNodeType&gt;::value</a> is <code>true</code> if and only if OtherNodeType is the type of a <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> whose ChildNodeType has the same configuration as this node's ChildNodeType.  <a href="structopenvdb_1_1v8__1_1_1tree_1_1RootNode_1_1SameConfiguration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1RootNode_1_1ValueConverter.html">ValueConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1RootNode_1_1ValueConverter.html#a2662538b02a333f5673a6d34c42e466b">ValueConverter&lt;T&gt;::Type</a> is the type of a <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> having the same child hierarchy as this node but a different value type, T.  <a href="structopenvdb_1_1v8__1_1_1tree_1_1RootNode_1_1ValueConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:add0b43407ef7279a458b5b63c604ae73"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> = ChildType</td></tr>
<tr class="separator:add0b43407ef7279a458b5b63c604ae73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b1764141687712562480c3cdd74c1b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> = typename ChildType::LeafNodeType</td></tr>
<tr class="separator:a47b1764141687712562480c3cdd74c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ab9062c358edc408d37deac2eb8538"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> = typename ChildType::ValueType</td></tr>
<tr class="separator:a89ab9062c358edc408d37deac2eb8538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab723abdcfd580fb1fc5eebf5da5d9660"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ab723abdcfd580fb1fc5eebf5da5d9660">BuildType</a> = typename ChildType::BuildType</td></tr>
<tr class="separator:ab723abdcfd580fb1fc5eebf5da5d9660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476192215f8d4ee389caf42204e3020f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a476192215f8d4ee389caf42204e3020f">NodeChainType</a> = typename <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1NodeChain.html">NodeChain</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a7efd456219bae7db497d009ad92961a7">LEVEL</a> &gt;::Type</td></tr>
<tr class="memdesc:a476192215f8d4ee389caf42204e3020f"><td class="mdescLeft">&#160;</td><td class="mdescRight">NodeChainType is a list of this tree's node types, from LeafNodeType to <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>.  <a href="#a476192215f8d4ee389caf42204e3020f">More...</a><br /></td></tr>
<tr class="separator:a476192215f8d4ee389caf42204e3020f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ddfd147d086003e983f40409d651ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a53ddfd147d086003e983f40409d651ff">ChildOnIter</a> = ChildIter&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ChildOnPred, ChildType &gt;</td></tr>
<tr class="separator:a53ddfd147d086003e983f40409d651ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af961e6cbba1568e6b4e3edac87952dbd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af961e6cbba1568e6b4e3edac87952dbd">ChildOnCIter</a> = ChildIter&lt; const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ChildOnPred, const ChildType &gt;</td></tr>
<tr class="separator:af961e6cbba1568e6b4e3edac87952dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70584e8033dbc079fdc0ac57d167eee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad70584e8033dbc079fdc0ac57d167eee">ChildOffIter</a> = ValueIter&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ChildOffPred, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &gt;</td></tr>
<tr class="separator:ad70584e8033dbc079fdc0ac57d167eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629fb04c86fa214750225c9f1d146a36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a629fb04c86fa214750225c9f1d146a36">ChildOffCIter</a> = ValueIter&lt; const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ChildOffPred, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &gt;</td></tr>
<tr class="separator:a629fb04c86fa214750225c9f1d146a36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01bb1bcecd7385c19f214c7dd217fb27"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a01bb1bcecd7385c19f214c7dd217fb27">ChildAllIter</a> = DenseIter&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ChildType, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &gt;</td></tr>
<tr class="separator:a01bb1bcecd7385c19f214c7dd217fb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba3a2d9f84085e3e6b54f4358df5eb28"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aba3a2d9f84085e3e6b54f4358df5eb28">ChildAllCIter</a> = DenseIter&lt; const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, const ChildType, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &gt;</td></tr>
<tr class="separator:aba3a2d9f84085e3e6b54f4358df5eb28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eb611c9fc0de11faa69c866d88f680a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a4eb611c9fc0de11faa69c866d88f680a">ValueOnIter</a> = ValueIter&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ValueOnPred, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &gt;</td></tr>
<tr class="separator:a4eb611c9fc0de11faa69c866d88f680a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fddbb02f413af01b4b839e82f5e49f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a15fddbb02f413af01b4b839e82f5e49f">ValueOnCIter</a> = ValueIter&lt; const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ValueOnPred, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &gt;</td></tr>
<tr class="separator:a15fddbb02f413af01b4b839e82f5e49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cc6b3daa5baf71df51fb8426470d8c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a3cc6b3daa5baf71df51fb8426470d8c7">ValueOffIter</a> = ValueIter&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ValueOffPred, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &gt;</td></tr>
<tr class="separator:a3cc6b3daa5baf71df51fb8426470d8c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bce38e91a758eb215875e9ad0c0add"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a04bce38e91a758eb215875e9ad0c0add">ValueOffCIter</a> = ValueIter&lt; const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ValueOffPred, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &gt;</td></tr>
<tr class="separator:a04bce38e91a758eb215875e9ad0c0add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e96b29bec06304babad73d51b201945"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a3e96b29bec06304babad73d51b201945">ValueAllIter</a> = ValueIter&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ValueAllPred, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &gt;</td></tr>
<tr class="separator:a3e96b29bec06304babad73d51b201945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755eaad7b1dba0812844255cee5c48bf"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a755eaad7b1dba0812844255cee5c48bf">ValueAllCIter</a> = ValueIter&lt; const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ValueAllPred, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &gt;</td></tr>
<tr class="separator:a755eaad7b1dba0812844255cee5c48bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa5dbd319ba70f5491e4326ec341273d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aa5dbd319ba70f5491e4326ec341273d8">RootNode</a> ()</td></tr>
<tr class="memdesc:aa5dbd319ba70f5491e4326ec341273d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new tree with a background value of 0.  <a href="#aa5dbd319ba70f5491e4326ec341273d8">More...</a><br /></td></tr>
<tr class="separator:aa5dbd319ba70f5491e4326ec341273d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962d5c3401f8c0a8f60d71b141e7fb3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a962d5c3401f8c0a8f60d71b141e7fb3b">RootNode</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#acccdab5ee066678e77d16f516d527d33">background</a>)</td></tr>
<tr class="memdesc:a962d5c3401f8c0a8f60d71b141e7fb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new tree with the given background value.  <a href="#a962d5c3401f8c0a8f60d71b141e7fb3b">More...</a><br /></td></tr>
<tr class="separator:a962d5c3401f8c0a8f60d71b141e7fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08562b54850ff29ef167b7a1d1cfadd4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a08562b54850ff29ef167b7a1d1cfadd4">RootNode</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> &amp;other)</td></tr>
<tr class="separator:a08562b54850ff29ef167b7a1d1cfadd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4048d463e26625beb9e08adbd50528e"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType &gt; </td></tr>
<tr class="memitem:ad4048d463e26625beb9e08adbd50528e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad4048d463e26625beb9e08adbd50528e">RootNode</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="memdesc:ad4048d463e26625beb9e08adbd50528e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new tree that reproduces the topology and active states of a tree of a different ValueType but the same configuration (levels, node dimensions and branching factors). Cast the other tree's values to this tree's ValueType.  <a href="#ad4048d463e26625beb9e08adbd50528e">More...</a><br /></td></tr>
<tr class="separator:ad4048d463e26625beb9e08adbd50528e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6e523d80a6b90c3b63ef1c40939c7d5"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType &gt; </td></tr>
<tr class="memitem:ab6e523d80a6b90c3b63ef1c40939c7d5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ab6e523d80a6b90c3b63ef1c40939c7d5">RootNode</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#acccdab5ee066678e77d16f516d527d33">background</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;foreground, <a class="el" href="classopenvdb_1_1v8__1_1_1TopologyCopy.html">TopologyCopy</a>)</td></tr>
<tr class="memdesc:ab6e523d80a6b90c3b63ef1c40939c7d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new tree that reproduces the topology and active states of another tree (which may have a different ValueType), but not the other tree's values.  <a href="#ab6e523d80a6b90c3b63ef1c40939c7d5">More...</a><br /></td></tr>
<tr class="separator:ab6e523d80a6b90c3b63ef1c40939c7d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1376f67d16d5de9a4d152a45f863f0cf"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType &gt; </td></tr>
<tr class="memitem:a1376f67d16d5de9a4d152a45f863f0cf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a1376f67d16d5de9a4d152a45f863f0cf">RootNode</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#acccdab5ee066678e77d16f516d527d33">background</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1TopologyCopy.html">TopologyCopy</a>)</td></tr>
<tr class="memdesc:a1376f67d16d5de9a4d152a45f863f0cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new tree that reproduces the topology and active states of another tree (which may have a different ValueType), but not the other tree's values. All tiles and voxels in the new tree are set to <em>background</em> regardless of their active states in the other tree.  <a href="#a1376f67d16d5de9a4d152a45f863f0cf">More...</a><br /></td></tr>
<tr class="separator:a1376f67d16d5de9a4d152a45f863f0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b775efb979e2d7445d43aaf7cb900d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a1b775efb979e2d7445d43aaf7cb900d0">operator=</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> &amp;other)</td></tr>
<tr class="memdesc:a1b775efb979e2d7445d43aaf7cb900d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a root node of the same type as this node.  <a href="#a1b775efb979e2d7445d43aaf7cb900d0">More...</a><br /></td></tr>
<tr class="separator:a1b775efb979e2d7445d43aaf7cb900d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0447467224f7c21ad0e3926279ab7eb9"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType &gt; </td></tr>
<tr class="memitem:a0447467224f7c21ad0e3926279ab7eb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a0447467224f7c21ad0e3926279ab7eb9">operator=</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="memdesc:a0447467224f7c21ad0e3926279ab7eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy a root node of the same tree configuration as this node but a different ValueType.  <a href="#a0447467224f7c21ad0e3926279ab7eb9">More...</a><br /></td></tr>
<tr class="separator:a0447467224f7c21ad0e3926279ab7eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf38ff0107dcb0e50c0f4e5783146459"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aaf38ff0107dcb0e50c0f4e5783146459">~RootNode</a> ()</td></tr>
<tr class="separator:aaf38ff0107dcb0e50c0f4e5783146459"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e9bf1256874f802e2dbbc7db56f8ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af961e6cbba1568e6b4e3edac87952dbd">ChildOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a63e9bf1256874f802e2dbbc7db56f8ee">cbeginChildOn</a> () const </td></tr>
<tr class="separator:a63e9bf1256874f802e2dbbc7db56f8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8169dc13d3aad941b6490f27a4bbb839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a629fb04c86fa214750225c9f1d146a36">ChildOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a8169dc13d3aad941b6490f27a4bbb839">cbeginChildOff</a> () const </td></tr>
<tr class="separator:a8169dc13d3aad941b6490f27a4bbb839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c7824607dbdc3c1165e0b0daea8bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aba3a2d9f84085e3e6b54f4358df5eb28">ChildAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ae5c7824607dbdc3c1165e0b0daea8bcd">cbeginChildAll</a> () const </td></tr>
<tr class="separator:ae5c7824607dbdc3c1165e0b0daea8bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c7157dee0e08c357e6a3ed6415a00e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af961e6cbba1568e6b4e3edac87952dbd">ChildOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a31c7157dee0e08c357e6a3ed6415a00e">beginChildOn</a> () const </td></tr>
<tr class="separator:a31c7157dee0e08c357e6a3ed6415a00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8438e994f130eacf9f40014a97514bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a629fb04c86fa214750225c9f1d146a36">ChildOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a8438e994f130eacf9f40014a97514bcd">beginChildOff</a> () const </td></tr>
<tr class="separator:a8438e994f130eacf9f40014a97514bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599e840b09098cf3437a3c4bd366ee79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aba3a2d9f84085e3e6b54f4358df5eb28">ChildAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a599e840b09098cf3437a3c4bd366ee79">beginChildAll</a> () const </td></tr>
<tr class="separator:a599e840b09098cf3437a3c4bd366ee79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f712beff77da092dd726a59e1104cf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a53ddfd147d086003e983f40409d651ff">ChildOnIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a0f712beff77da092dd726a59e1104cf0">beginChildOn</a> ()</td></tr>
<tr class="separator:a0f712beff77da092dd726a59e1104cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845985fcf5013cc3fe15865b05b3abd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad70584e8033dbc079fdc0ac57d167eee">ChildOffIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a845985fcf5013cc3fe15865b05b3abd5">beginChildOff</a> ()</td></tr>
<tr class="separator:a845985fcf5013cc3fe15865b05b3abd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7000148c6f1dc8bfbb0139a3606e188e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a01bb1bcecd7385c19f214c7dd217fb27">ChildAllIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a7000148c6f1dc8bfbb0139a3606e188e">beginChildAll</a> ()</td></tr>
<tr class="separator:a7000148c6f1dc8bfbb0139a3606e188e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad554801c644ee82931281a11f801bf5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a15fddbb02f413af01b4b839e82f5e49f">ValueOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad554801c644ee82931281a11f801bf5c">cbeginValueOn</a> () const </td></tr>
<tr class="separator:ad554801c644ee82931281a11f801bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16c1191cb1a539a7cc0cdee5803d860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a04bce38e91a758eb215875e9ad0c0add">ValueOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ae16c1191cb1a539a7cc0cdee5803d860">cbeginValueOff</a> () const </td></tr>
<tr class="separator:ae16c1191cb1a539a7cc0cdee5803d860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b296755b1634e77e5fff9c4c48ea3c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a755eaad7b1dba0812844255cee5c48bf">ValueAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a8b296755b1634e77e5fff9c4c48ea3c8">cbeginValueAll</a> () const </td></tr>
<tr class="separator:a8b296755b1634e77e5fff9c4c48ea3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f82a16370621f762a097f27122e51db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a15fddbb02f413af01b4b839e82f5e49f">ValueOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a0f82a16370621f762a097f27122e51db">beginValueOn</a> () const </td></tr>
<tr class="separator:a0f82a16370621f762a097f27122e51db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17282c62bdf7cdd25be3b773b39907b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a04bce38e91a758eb215875e9ad0c0add">ValueOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a17282c62bdf7cdd25be3b773b39907b0">beginValueOff</a> () const </td></tr>
<tr class="separator:a17282c62bdf7cdd25be3b773b39907b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ec03c783bc71e824837c826dd6531c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a755eaad7b1dba0812844255cee5c48bf">ValueAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a18ec03c783bc71e824837c826dd6531c">beginValueAll</a> () const </td></tr>
<tr class="separator:a18ec03c783bc71e824837c826dd6531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8568cb11eacfedf042fa1eda680a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a4eb611c9fc0de11faa69c866d88f680a">ValueOnIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a7b8568cb11eacfedf042fa1eda680a45">beginValueOn</a> ()</td></tr>
<tr class="separator:a7b8568cb11eacfedf042fa1eda680a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad555f92c70739496805fb480c3b38f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a3cc6b3daa5baf71df51fb8426470d8c7">ValueOffIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad555f92c70739496805fb480c3b38f85">beginValueOff</a> ()</td></tr>
<tr class="separator:ad555f92c70739496805fb480c3b38f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf6fa279da1f6839a3ca381828220df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a3e96b29bec06304babad73d51b201945">ValueAllIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#afdf6fa279da1f6839a3ca381828220df">beginValueAll</a> ()</td></tr>
<tr class="separator:afdf6fa279da1f6839a3ca381828220df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8443805eb98462d37d9c3f7b549ede0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a8443805eb98462d37d9c3f7b549ede0f">memUsage</a> () const </td></tr>
<tr class="memdesc:a8443805eb98462d37d9c3f7b549ede0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total amount of memory in bytes occupied by this node and its children.  <a href="#a8443805eb98462d37d9c3f7b549ede0f">More...</a><br /></td></tr>
<tr class="separator:a8443805eb98462d37d9c3f7b549ede0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f72230ae8ade2c0a5e712708c36fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aa4f72230ae8ade2c0a5e712708c36fa6">evalActiveBoundingBox</a> (CoordBBox &amp;bbox, bool visitVoxels=true) const </td></tr>
<tr class="memdesc:aa4f72230ae8ade2c0a5e712708c36fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the specified bbox so it includes the active tiles of this root node as well as all the active values in its child nodes. If visitVoxels is false LeafNodes will be approximated as dense, i.e. with all voxels active. Else the individual active voxels are visited to produce a tight bbox.  <a href="#aa4f72230ae8ade2c0a5e712708c36fa6">More...</a><br /></td></tr>
<tr class="separator:aa4f72230ae8ade2c0a5e712708c36fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a9be183fae028c2479dd20163a52ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ab9a9be183fae028c2479dd20163a52ee">setBackground</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool updateChildNodes)</td></tr>
<tr class="memdesc:ab9a9be183fae028c2479dd20163a52ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change inactive tiles or voxels with a value equal to +/- the old background to the specified value (with the same sign). Active values are unchanged.  <a href="#ab9a9be183fae028c2479dd20163a52ee">More...</a><br /></td></tr>
<tr class="separator:ab9a9be183fae028c2479dd20163a52ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acccdab5ee066678e77d16f516d527d33"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#acccdab5ee066678e77d16f516d527d33">background</a> () const </td></tr>
<tr class="memdesc:acccdab5ee066678e77d16f516d527d33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return this node's background value.  <a href="#acccdab5ee066678e77d16f516d527d33">More...</a><br /></td></tr>
<tr class="separator:acccdab5ee066678e77d16f516d527d33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275e55e8c343dad4159b8ada32f99cde"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a275e55e8c343dad4159b8ada32f99cde">isBackgroundTile</a> (const Tile &amp;) const </td></tr>
<tr class="memdesc:a275e55e8c343dad4159b8ada32f99cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given tile is inactive and has the background value.  <a href="#a275e55e8c343dad4159b8ada32f99cde">More...</a><br /></td></tr>
<tr class="separator:a275e55e8c343dad4159b8ada32f99cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca78cbf1bae9694422702b2f3fb81950"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aca78cbf1bae9694422702b2f3fb81950">numBackgroundTiles</a> () const </td></tr>
<tr class="memdesc:aca78cbf1bae9694422702b2f3fb81950"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of background tiles.  <a href="#aca78cbf1bae9694422702b2f3fb81950">More...</a><br /></td></tr>
<tr class="separator:aca78cbf1bae9694422702b2f3fb81950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48dc4a8d53d718280d347a867cd6704b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a48dc4a8d53d718280d347a867cd6704b">eraseBackgroundTiles</a> ()</td></tr>
<tr class="memdesc:a48dc4a8d53d718280d347a867cd6704b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all background tiles.  <a href="#a48dc4a8d53d718280d347a867cd6704b">More...</a><br /></td></tr>
<tr class="separator:a48dc4a8d53d718280d347a867cd6704b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e61de369e994009e36f344f99c15ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ac6e61de369e994009e36f344f99c15ad">empty</a> () const </td></tr>
<tr class="memdesc:ac6e61de369e994009e36f344f99c15ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if this node's table is either empty or contains only background tiles.  <a href="#ac6e61de369e994009e36f344f99c15ad">More...</a><br /></td></tr>
<tr class="separator:ac6e61de369e994009e36f344f99c15ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5bfeb2da24cc37e6561b3cd0f5f1f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aed5bfeb2da24cc37e6561b3cd0f5f1f3">expand</a> (const Coord &amp;xyz)</td></tr>
<tr class="memdesc:aed5bfeb2da24cc37e6561b3cd0f5f1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand this node's table so that (x, y, z) is included in the index range.  <a href="#aed5bfeb2da24cc37e6561b3cd0f5f1f3">More...</a><br /></td></tr>
<tr class="separator:aed5bfeb2da24cc37e6561b3cd0f5f1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090c046211c122ce4bba72d102f578e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a090c046211c122ce4bba72d102f578e7">getTableSize</a> () const </td></tr>
<tr class="memdesc:a090c046211c122ce4bba72d102f578e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of entries in this node's table.  <a href="#a090c046211c122ce4bba72d102f578e7">More...</a><br /></td></tr>
<tr class="separator:a090c046211c122ce4bba72d102f578e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5917a5c4d6b84e2f083a5db8c004277"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad5917a5c4d6b84e2f083a5db8c004277">getWidth</a> () const </td></tr>
<tr class="separator:ad5917a5c4d6b84e2f083a5db8c004277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8a1436aa153d08fa6e73f59f871976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#acb8a1436aa153d08fa6e73f59f871976">getHeight</a> () const </td></tr>
<tr class="separator:acb8a1436aa153d08fa6e73f59f871976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c602c12ff468865a25ce83ff7fb8c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ae9c602c12ff468865a25ce83ff7fb8c1">getDepth</a> () const </td></tr>
<tr class="separator:ae9c602c12ff468865a25ce83ff7fb8c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad45f83af7980f8e2b181ab62a39dec"><td class="memItemLeft" align="right" valign="top">Coord&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a4ad45f83af7980f8e2b181ab62a39dec">getMinIndex</a> () const </td></tr>
<tr class="memdesc:a4ad45f83af7980f8e2b181ab62a39dec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the smallest index of the current tree.  <a href="#a4ad45f83af7980f8e2b181ab62a39dec">More...</a><br /></td></tr>
<tr class="separator:a4ad45f83af7980f8e2b181ab62a39dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2abbf438654aa1950e0c58ec7a717615"><td class="memItemLeft" align="right" valign="top">Coord&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a2abbf438654aa1950e0c58ec7a717615">getMaxIndex</a> () const </td></tr>
<tr class="memdesc:a2abbf438654aa1950e0c58ec7a717615"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the largest index of the current tree.  <a href="#a2abbf438654aa1950e0c58ec7a717615">More...</a><br /></td></tr>
<tr class="separator:a2abbf438654aa1950e0c58ec7a717615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c5c77b8e79b139e3da5e4f16ed00f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a79c5c77b8e79b139e3da5e4f16ed00f6">getIndexRange</a> (CoordBBox &amp;bbox) const </td></tr>
<tr class="memdesc:a79c5c77b8e79b139e3da5e4f16ed00f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current index range. Both min and max are inclusive.  <a href="#a79c5c77b8e79b139e3da5e4f16ed00f6">More...</a><br /></td></tr>
<tr class="separator:a79c5c77b8e79b139e3da5e4f16ed00f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2290c7162c015d83e057eca2dd23dc1"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType &gt; </td></tr>
<tr class="memitem:ad2290c7162c015d83e057eca2dd23dc1"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad2290c7162c015d83e057eca2dd23dc1">hasSameTopology</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other) const </td></tr>
<tr class="memdesc:ad2290c7162c015d83e057eca2dd23dc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given tree has the same node and active value topology as this tree (but possibly a different <code>ValueType</code>).  <a href="#ad2290c7162c015d83e057eca2dd23dc1">More...</a><br /></td></tr>
<tr class="separator:ad2290c7162c015d83e057eca2dd23dc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0667d468064aa044670a06a84b9c48ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a0667d468064aa044670a06a84b9c48ed">leafCount</a> () const </td></tr>
<tr class="separator:a0667d468064aa044670a06a84b9c48ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d22ef34f6459bcffc00f6eb8f747b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad8d22ef34f6459bcffc00f6eb8f747b9">nonLeafCount</a> () const </td></tr>
<tr class="separator:ad8d22ef34f6459bcffc00f6eb8f747b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8732f8cd6e4c4dc8ae7b338343d082"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aaf8732f8cd6e4c4dc8ae7b338343d082">childCount</a> () const </td></tr>
<tr class="separator:aaf8732f8cd6e4c4dc8ae7b338343d082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41639979a334066f76633037c605a77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ae41639979a334066f76633037c605a77">onVoxelCount</a> () const </td></tr>
<tr class="separator:ae41639979a334066f76633037c605a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22486b1420a67aaf492e7e4ca2ca6fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a22486b1420a67aaf492e7e4ca2ca6fb6">offVoxelCount</a> () const </td></tr>
<tr class="separator:a22486b1420a67aaf492e7e4ca2ca6fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2ccd641ba4842769eb649c856d05b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#abe2ccd641ba4842769eb649c856d05b9">onLeafVoxelCount</a> () const </td></tr>
<tr class="separator:abe2ccd641ba4842769eb649c856d05b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ac72edbf61ebf466b06f6bb4f1ffc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a78ac72edbf61ebf466b06f6bb4f1ffc6">offLeafVoxelCount</a> () const </td></tr>
<tr class="separator:a78ac72edbf61ebf466b06f6bb4f1ffc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c7f5922acf9662196a81ec4470aedd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad8c7f5922acf9662196a81ec4470aedd">onTileCount</a> () const </td></tr>
<tr class="separator:ad8c7f5922acf9662196a81ec4470aedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ac16944cc943e8a524cc80824182ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aa4ac16944cc943e8a524cc80824182ef">nodeCount</a> (std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> &gt; &amp;vec) const </td></tr>
<tr class="separator:aa4ac16944cc943e8a524cc80824182ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc695b4cc2c115afbdb51d4997b69747"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#afc695b4cc2c115afbdb51d4997b69747">isValueOn</a> (const Coord &amp;xyz) const </td></tr>
<tr class="separator:afc695b4cc2c115afbdb51d4997b69747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1a133192d9d344c482d4aa83f6da33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a1e1a133192d9d344c482d4aa83f6da33">hasActiveTiles</a> () const </td></tr>
<tr class="memdesc:a1e1a133192d9d344c482d4aa83f6da33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if this root node, or any of its child nodes, have active tiles.  <a href="#a1e1a133192d9d344c482d4aa83f6da33">More...</a><br /></td></tr>
<tr class="separator:a1e1a133192d9d344c482d4aa83f6da33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce49c1d01fb40115f7253b65dd98a38"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a8ce49c1d01fb40115f7253b65dd98a38">getValue</a> (const Coord &amp;xyz) const </td></tr>
<tr class="separator:a8ce49c1d01fb40115f7253b65dd98a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0535ed999c1364a5bc5f31e668e5ef7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a0535ed999c1364a5bc5f31e668e5ef7c">probeValue</a> (const Coord &amp;xyz, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value) const </td></tr>
<tr class="separator:a0535ed999c1364a5bc5f31e668e5ef7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adabe21e6eb918bee1d29c161c6ce03ae"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#adabe21e6eb918bee1d29c161c6ce03ae">getValueDepth</a> (const Coord &amp;xyz) const </td></tr>
<tr class="memdesc:adabe21e6eb918bee1d29c161c6ce03ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the tree depth (0 = root) at which the value of voxel (x, y, z) resides.  <a href="#adabe21e6eb918bee1d29c161c6ce03ae">More...</a><br /></td></tr>
<tr class="separator:adabe21e6eb918bee1d29c161c6ce03ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3e82eb582914ac6f31f32fea77292f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a7b3e82eb582914ac6f31f32fea77292f">setActiveState</a> (const Coord &amp;xyz, bool on)</td></tr>
<tr class="memdesc:a7b3e82eb582914ac6f31f32fea77292f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the active state of the voxel at the given coordinates but don't change its value.  <a href="#a7b3e82eb582914ac6f31f32fea77292f">More...</a><br /></td></tr>
<tr class="separator:a7b3e82eb582914ac6f31f32fea77292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ff695beda11ed9ef625a28ce8a5faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a63ff695beda11ed9ef625a28ce8a5faf">setValueOnly</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a63ff695beda11ed9ef625a28ce8a5faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates but don't change its active state.  <a href="#a63ff695beda11ed9ef625a28ce8a5faf">More...</a><br /></td></tr>
<tr class="separator:a63ff695beda11ed9ef625a28ce8a5faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95653046c85afb743075f139a26df9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ae95653046c85afb743075f139a26df9d">setValueOn</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:ae95653046c85afb743075f139a26df9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates and mark the voxel as active.  <a href="#ae95653046c85afb743075f139a26df9d">More...</a><br /></td></tr>
<tr class="separator:ae95653046c85afb743075f139a26df9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a91d631df8f64f84a0aad7436cb11f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a8a91d631df8f64f84a0aad7436cb11f3">setValueOff</a> (const Coord &amp;xyz)</td></tr>
<tr class="memdesc:a8a91d631df8f64f84a0aad7436cb11f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the voxel at the given coordinates as inactive but don't change its value.  <a href="#a8a91d631df8f64f84a0aad7436cb11f3">More...</a><br /></td></tr>
<tr class="separator:a8a91d631df8f64f84a0aad7436cb11f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a6e7c85d37e7d677eddc3cce8aa11b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a73a6e7c85d37e7d677eddc3cce8aa11b">setValueOff</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a73a6e7c85d37e7d677eddc3cce8aa11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates and mark the voxel as inactive.  <a href="#a73a6e7c85d37e7d677eddc3cce8aa11b">More...</a><br /></td></tr>
<tr class="separator:a73a6e7c85d37e7d677eddc3cce8aa11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6954a428c0ef18a03431f251f4e7d24"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp &gt; </td></tr>
<tr class="memitem:aa6954a428c0ef18a03431f251f4e7d24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aa6954a428c0ef18a03431f251f4e7d24">modifyValue</a> (const Coord &amp;xyz, const ModifyOp &amp;op)</td></tr>
<tr class="memdesc:aa6954a428c0ef18a03431f251f4e7d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to the value of the voxel at the given coordinates and mark the voxel as active.  <a href="#aa6954a428c0ef18a03431f251f4e7d24">More...</a><br /></td></tr>
<tr class="separator:aa6954a428c0ef18a03431f251f4e7d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp &gt; </td></tr>
<tr class="memitem:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a5cb69af7e17c3a9a6d6dc360c878448c">modifyValueAndActiveState</a> (const Coord &amp;xyz, const ModifyOp &amp;op)</td></tr>
<tr class="memdesc:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to the voxel at the given coordinates.  <a href="#a5cb69af7e17c3a9a6d6dc360c878448c">More...</a><br /></td></tr>
<tr class="separator:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb399cd065108e53e7b65612e74372a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#abb399cd065108e53e7b65612e74372a5">denseFill</a> (const CoordBBox &amp;bbox, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool active=true)</td></tr>
<tr class="memdesc:abb399cd065108e53e7b65612e74372a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels within a given axis-aligned box to a constant value and ensure that those voxels are all represented at the leaf level.  <a href="#abb399cd065108e53e7b65612e74372a5">More...</a><br /></td></tr>
<tr class="separator:abb399cd065108e53e7b65612e74372a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a2211a02fb606e611d3ff5bbd6f50c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a39a2211a02fb606e611d3ff5bbd6f50c">voxelizeActiveTiles</a> (bool threaded=true)</td></tr>
<tr class="memdesc:a39a2211a02fb606e611d3ff5bbd6f50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Densify active tiles, i.e., replace them with leaf-level active voxels.  <a href="#a39a2211a02fb606e611d3ff5bbd6f50c">More...</a><br /></td></tr>
<tr class="separator:a39a2211a02fb606e611d3ff5bbd6f50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb6357bae687189b953c677911834ea"><td class="memTemplParams" colspan="2">template&lt;typename DenseT &gt; </td></tr>
<tr class="memitem:addb6357bae687189b953c677911834ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#addb6357bae687189b953c677911834ea">copyToDense</a> (const CoordBBox &amp;bbox, DenseT &amp;dense) const </td></tr>
<tr class="memdesc:addb6357bae687189b953c677911834ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy into a dense grid the values of all voxels, both active and inactive, that intersect a given bounding box.  <a href="#addb6357bae687189b953c677911834ea">More...</a><br /></td></tr>
<tr class="separator:addb6357bae687189b953c677911834ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06f55fa18912a20bc669cc8ac4c31ec1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a06f55fa18912a20bc669cc8ac4c31ec1">writeTopology</a> (std::ostream &amp;, bool toHalf=false) const </td></tr>
<tr class="separator:a06f55fa18912a20bc669cc8ac4c31ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5537d3d93b7137d3f03007b31077921"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af5537d3d93b7137d3f03007b31077921">readTopology</a> (std::istream &amp;, bool fromHalf=false)</td></tr>
<tr class="separator:af5537d3d93b7137d3f03007b31077921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1517c3788b6d11d5e07a577dd38d7c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a1517c3788b6d11d5e07a577dd38d7c43">writeBuffers</a> (std::ostream &amp;, bool toHalf=false) const </td></tr>
<tr class="separator:a1517c3788b6d11d5e07a577dd38d7c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef270a4e4900e5e0bd24e6664d6a8a82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aef270a4e4900e5e0bd24e6664d6a8a82">readBuffers</a> (std::istream &amp;, bool fromHalf=false)</td></tr>
<tr class="separator:aef270a4e4900e5e0bd24e6664d6a8a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d516efdbb242e00e7c77ae85cc426b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a9d516efdbb242e00e7c77ae85cc426b6">readBuffers</a> (std::istream &amp;, const CoordBBox &amp;, bool fromHalf=false)</td></tr>
<tr class="separator:a9d516efdbb242e00e7c77ae85cc426b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54f367109416043c0ce7d175be04c21"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:ab54f367109416043c0ce7d175be04c21"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ab54f367109416043c0ce7d175be04c21">getValueAndCache</a> (const Coord &amp;xyz, AccessorT &amp;) const </td></tr>
<tr class="separator:ab54f367109416043c0ce7d175be04c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b19bb2b11319fb6eaab50aada9bff01"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a7b19bb2b11319fb6eaab50aada9bff01"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a7b19bb2b11319fb6eaab50aada9bff01">isValueOnAndCache</a> (const Coord &amp;xyz, AccessorT &amp;) const </td></tr>
<tr class="separator:a7b19bb2b11319fb6eaab50aada9bff01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b75fc2aa129aa05ae677971dc1972e"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a01b75fc2aa129aa05ae677971dc1972e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a01b75fc2aa129aa05ae677971dc1972e">setValueAndCache</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, AccessorT &amp;)</td></tr>
<tr class="separator:a01b75fc2aa129aa05ae677971dc1972e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cefbe46cc3180e5394a2f4fc775bfe8"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a5cefbe46cc3180e5394a2f4fc775bfe8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a5cefbe46cc3180e5394a2f4fc775bfe8">setValueOnlyAndCache</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, AccessorT &amp;)</td></tr>
<tr class="separator:a5cefbe46cc3180e5394a2f4fc775bfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bed5c7c0d76cacfb514d9744f754402"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp , typename AccessorT &gt; </td></tr>
<tr class="memitem:a7bed5c7c0d76cacfb514d9744f754402"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a7bed5c7c0d76cacfb514d9744f754402">modifyValueAndCache</a> (const Coord &amp;xyz, const ModifyOp &amp;op, AccessorT &amp;)</td></tr>
<tr class="separator:a7bed5c7c0d76cacfb514d9744f754402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af057648803b9073ce1703dbf061e0d1f"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp , typename AccessorT &gt; </td></tr>
<tr class="memitem:af057648803b9073ce1703dbf061e0d1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af057648803b9073ce1703dbf061e0d1f">modifyValueAndActiveStateAndCache</a> (const Coord &amp;xyz, const ModifyOp &amp;op, AccessorT &amp;)</td></tr>
<tr class="separator:af057648803b9073ce1703dbf061e0d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0c65991a0b3c81933cd944d8fc4267"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a6c0c65991a0b3c81933cd944d8fc4267"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a6c0c65991a0b3c81933cd944d8fc4267">setValueOffAndCache</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, AccessorT &amp;)</td></tr>
<tr class="separator:a6c0c65991a0b3c81933cd944d8fc4267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04db06362bfb5ec0ed6212469eb4ff3"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:ac04db06362bfb5ec0ed6212469eb4ff3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ac04db06362bfb5ec0ed6212469eb4ff3">setActiveStateAndCache</a> (const Coord &amp;xyz, bool on, AccessorT &amp;)</td></tr>
<tr class="separator:ac04db06362bfb5ec0ed6212469eb4ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab682876d96e5d4b4c7bd90ef19638d7c"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:ab682876d96e5d4b4c7bd90ef19638d7c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ab682876d96e5d4b4c7bd90ef19638d7c">probeValueAndCache</a> (const Coord &amp;xyz, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, AccessorT &amp;) const </td></tr>
<tr class="separator:ab682876d96e5d4b4c7bd90ef19638d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df3d050e327bad074c288d65bf7e4d8"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a0df3d050e327bad074c288d65bf7e4d8"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a0df3d050e327bad074c288d65bf7e4d8">getValueDepthAndCache</a> (const Coord &amp;xyz, AccessorT &amp;) const </td></tr>
<tr class="separator:a0df3d050e327bad074c288d65bf7e4d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a409633b422404c1c7df4e0ffdd02eac1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a409633b422404c1c7df4e0ffdd02eac1">clip</a> (const CoordBBox &amp;)</td></tr>
<tr class="memdesc:a409633b422404c1c7df4e0ffdd02eac1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels that lie outside the given axis-aligned box to the background.  <a href="#a409633b422404c1c7df4e0ffdd02eac1">More...</a><br /></td></tr>
<tr class="separator:a409633b422404c1c7df4e0ffdd02eac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462c7056adc55d8da2cc5828934ff859"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a462c7056adc55d8da2cc5828934ff859">prune</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;tolerance=<a class="el" href="namespaceopenvdb_1_1v8__1.html#a9bc9fb4000c5e821a917537e91e21eda">zeroVal</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &gt;())</td></tr>
<tr class="memdesc:a462c7056adc55d8da2cc5828934ff859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the same (optionally to within a tolerance) and have the same active state.  <a href="#a462c7056adc55d8da2cc5828934ff859">More...</a><br /></td></tr>
<tr class="separator:a462c7056adc55d8da2cc5828934ff859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20c22e9a994a30c9640cbe1ec982bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a6c20c22e9a994a30c9640cbe1ec982bc">addLeaf</a> (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *leaf)</td></tr>
<tr class="memdesc:a6c20c22e9a994a30c9640cbe1ec982bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given leaf node to this tree, creating a new branch if necessary. If a leaf node with the same origin already exists, replace it.  <a href="#a6c20c22e9a994a30c9640cbe1ec982bc">More...</a><br /></td></tr>
<tr class="separator:a6c20c22e9a994a30c9640cbe1ec982bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d57da960fd963ab7a02836ebf005b5"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a23d57da960fd963ab7a02836ebf005b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a23d57da960fd963ab7a02836ebf005b5">addLeafAndCache</a> (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *leaf, AccessorT &amp;)</td></tr>
<tr class="memdesc:a23d57da960fd963ab7a02836ebf005b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a6c20c22e9a994a30c9640cbe1ec982bc" title="Add the given leaf node to this tree, creating a new branch if necessary. If a leaf node with the sam...">addLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <a href="#a23d57da960fd963ab7a02836ebf005b5">More...</a><br /></td></tr>
<tr class="separator:a23d57da960fd963ab7a02836ebf005b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a91bb3ba79b24928bc0f68e950c837"><td class="memTemplParams" colspan="2">template&lt;typename NodeT &gt; </td></tr>
<tr class="memitem:a37a91bb3ba79b24928bc0f68e950c837"><td class="memTemplItemLeft" align="right" valign="top">NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a37a91bb3ba79b24928bc0f68e950c837">stealNode</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="memdesc:a37a91bb3ba79b24928bc0f68e950c837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node of type <code>NodeT</code> that contains voxel (x, y, z) and replace it with a tile of the specified value and state. If no such node exists, leave the tree unchanged and return <code>nullptr</code>.  <a href="#a37a91bb3ba79b24928bc0f68e950c837">More...</a><br /></td></tr>
<tr class="separator:a37a91bb3ba79b24928bc0f68e950c837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed56c39d458885f1191405c625e73d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a2ed56c39d458885f1191405c625e73d1">addChild</a> (ChildType *child)</td></tr>
<tr class="memdesc:a2ed56c39d458885f1191405c625e73d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given child node at the root level. If a child node with the same origin already exists, delete the old node and add the new node in its place (i.e. ownership of the new child node is transferred to this <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>).  <a href="#a2ed56c39d458885f1191405c625e73d1">More...</a><br /></td></tr>
<tr class="separator:a2ed56c39d458885f1191405c625e73d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd27c86bf273fa436a0e8c9d41b28af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a6fd27c86bf273fa436a0e8c9d41b28af">addTile</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="memdesc:a6fd27c86bf273fa436a0e8c9d41b28af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a tile containing voxel (x, y, z) at the root level, deleting the existing branch if necessary.  <a href="#a6fd27c86bf273fa436a0e8c9d41b28af">More...</a><br /></td></tr>
<tr class="separator:a6fd27c86bf273fa436a0e8c9d41b28af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ab61f904112334f418ea8a1235cdad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a58ab61f904112334f418ea8a1235cdad">addTile</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> level, const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="memdesc:a58ab61f904112334f418ea8a1235cdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a tile containing voxel (x, y, z) at the specified tree level, creating a new branch if necessary. Delete any existing lower-level nodes that contain (x, y, z).  <a href="#a58ab61f904112334f418ea8a1235cdad">More...</a><br /></td></tr>
<tr class="separator:a58ab61f904112334f418ea8a1235cdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88baa1b1d12b360589dbe49a344be2b6"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a88baa1b1d12b360589dbe49a344be2b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a88baa1b1d12b360589dbe49a344be2b6">addTileAndCache</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> level, const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;, bool state, AccessorT &amp;)</td></tr>
<tr class="memdesc:a88baa1b1d12b360589dbe49a344be2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a6fd27c86bf273fa436a0e8c9d41b28af" title="Add a tile containing voxel (x, y, z) at the root level, deleting the existing branch if necessary...">addTile()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <a href="#a88baa1b1d12b360589dbe49a344be2b6">More...</a><br /></td></tr>
<tr class="separator:a88baa1b1d12b360589dbe49a344be2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67464c0a432fdd5591c830b5589ce42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ab67464c0a432fdd5591c830b5589ce42">touchLeaf</a> (const Coord &amp;xyz)</td></tr>
<tr class="memdesc:ab67464c0a432fdd5591c830b5589ce42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, create one that preserves the values and active states of all voxels.  <a href="#ab67464c0a432fdd5591c830b5589ce42">More...</a><br /></td></tr>
<tr class="separator:ab67464c0a432fdd5591c830b5589ce42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87111eb89261bcfaba2d9863f81c92d6"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a87111eb89261bcfaba2d9863f81c92d6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a87111eb89261bcfaba2d9863f81c92d6">touchLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="memdesc:a87111eb89261bcfaba2d9863f81c92d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ab67464c0a432fdd5591c830b5589ce42" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, create one that preserves the values and active states of all voxels. ">touchLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <a href="#a87111eb89261bcfaba2d9863f81c92d6">More...</a><br /></td></tr>
<tr class="separator:a87111eb89261bcfaba2d9863f81c92d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a7e4a512b1082887098547c2781ed0"><td class="memTemplParams" colspan="2">template&lt;MergePolicy Policy&gt; </td></tr>
<tr class="memitem:a52a7e4a512b1082887098547c2781ed0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a52a7e4a512b1082887098547c2781ed0">merge</a> (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> &amp;other)</td></tr>
<tr class="memdesc:a52a7e4a512b1082887098547c2781ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently merge another tree into this tree using one of several schemes.  <a href="#a52a7e4a512b1082887098547c2781ed0">More...</a><br /></td></tr>
<tr class="separator:a52a7e4a512b1082887098547c2781ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb824077105112bae944f31ad9c2fe0"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType &gt; </td></tr>
<tr class="memitem:a3fb824077105112bae944f31ad9c2fe0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a3fb824077105112bae944f31ad9c2fe0">topologyUnion</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other, const bool preserveTiles=false)</td></tr>
<tr class="memdesc:a3fb824077105112bae944f31ad9c2fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different.  <a href="#a3fb824077105112bae944f31ad9c2fe0">More...</a><br /></td></tr>
<tr class="separator:a3fb824077105112bae944f31ad9c2fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29f98775a4d88dc3163abc979db6060"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType &gt; </td></tr>
<tr class="memitem:ac29f98775a4d88dc3163abc979db6060"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ac29f98775a4d88dc3163abc979db6060">topologyIntersection</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="memdesc:ac29f98775a4d88dc3163abc979db6060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different.  <a href="#ac29f98775a4d88dc3163abc979db6060">More...</a><br /></td></tr>
<tr class="separator:ac29f98775a4d88dc3163abc979db6060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bfa9bd46c8206d75f01c69c05425b5d"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType &gt; </td></tr>
<tr class="memitem:a4bfa9bd46c8206d75f01c69c05425b5d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a4bfa9bd46c8206d75f01c69c05425b5d">topologyDifference</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="memdesc:a4bfa9bd46c8206d75f01c69c05425b5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different. So a resulting voxel will be active only if the original voxel is active in this tree and inactive in the other tree.  <a href="#a4bfa9bd46c8206d75f01c69c05425b5d">More...</a><br /></td></tr>
<tr class="separator:a4bfa9bd46c8206d75f01c69c05425b5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0f6f48c7b53111118bf1a14a8dff03"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp &gt; </td></tr>
<tr class="memitem:a2d0f6f48c7b53111118bf1a14a8dff03"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a2d0f6f48c7b53111118bf1a14a8dff03">combine</a> (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> &amp;other, CombineOp &amp;, bool <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a462c7056adc55d8da2cc5828934ff859">prune</a>=false)</td></tr>
<tr class="separator:a2d0f6f48c7b53111118bf1a14a8dff03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d05166d77d6604823a6e669f3b53f7"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp , typename OtherRootNode &gt; </td></tr>
<tr class="memitem:a59d05166d77d6604823a6e669f3b53f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a59d05166d77d6604823a6e669f3b53f7">combine2</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> &amp;other0, const OtherRootNode &amp;other1, CombineOp &amp;op, bool <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a462c7056adc55d8da2cc5828934ff859">prune</a>=false)</td></tr>
<tr class="separator:a59d05166d77d6604823a6e669f3b53f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973ced84fe7b684d6be0acb5cef74c33"><td class="memTemplParams" colspan="2">template&lt;typename BBoxOp &gt; </td></tr>
<tr class="memitem:a973ced84fe7b684d6be0acb5cef74c33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a973ced84fe7b684d6be0acb5cef74c33">visitActiveBBox</a> (BBoxOp &amp;) const </td></tr>
<tr class="memdesc:a973ced84fe7b684d6be0acb5cef74c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the templated functor BBoxOp with bounding box information for all active tiles and leaf nodes in the tree. An additional level argument is provided for each callback.  <a href="#a973ced84fe7b684d6be0acb5cef74c33">More...</a><br /></td></tr>
<tr class="separator:a973ced84fe7b684d6be0acb5cef74c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028a58e937882a91e9c1470fb6e73b42"><td class="memTemplParams" colspan="2">template&lt;typename VisitorOp &gt; </td></tr>
<tr class="memitem:a028a58e937882a91e9c1470fb6e73b42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a028a58e937882a91e9c1470fb6e73b42">visit</a> (VisitorOp &amp;)</td></tr>
<tr class="separator:a028a58e937882a91e9c1470fb6e73b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e62589958cedae5c2cd4b356f6ba7a"><td class="memTemplParams" colspan="2">template&lt;typename VisitorOp &gt; </td></tr>
<tr class="memitem:ac6e62589958cedae5c2cd4b356f6ba7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ac6e62589958cedae5c2cd4b356f6ba7a">visit</a> (VisitorOp &amp;) const </td></tr>
<tr class="separator:ac6e62589958cedae5c2cd4b356f6ba7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5dff97dd17f56a711d483615450d73"><td class="memTemplParams" colspan="2">template&lt;typename OtherRootNodeType , typename VisitorOp &gt; </td></tr>
<tr class="memitem:a7c5dff97dd17f56a711d483615450d73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a7c5dff97dd17f56a711d483615450d73">visit2</a> (OtherRootNodeType &amp;other, VisitorOp &amp;)</td></tr>
<tr class="separator:a7c5dff97dd17f56a711d483615450d73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d81485014bea7517cbbf9e22a31d57e"><td class="memTemplParams" colspan="2">template&lt;typename OtherRootNodeType , typename VisitorOp &gt; </td></tr>
<tr class="memitem:a1d81485014bea7517cbbf9e22a31d57e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a1d81485014bea7517cbbf9e22a31d57e">visit2</a> (OtherRootNodeType &amp;other, VisitorOp &amp;) const </td></tr>
<tr class="separator:a1d81485014bea7517cbbf9e22a31d57e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef2b73375c068f1a01a7ee5b4f55d8b1"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType &gt; </td></tr>
<tr class="memitem:aef2b73375c068f1a01a7ee5b4f55d8b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildT &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aef2b73375c068f1a01a7ee5b4f55d8b1">operator=</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="separator:aef2b73375c068f1a01a7ee5b4f55d8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c08c3d36ba7fe64cc4861fe4b4cae0"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a21c08c3d36ba7fe64cc4861fe4b4cae0"><td class="memTemplItemLeft" align="right" valign="top">const ChildT::ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a21c08c3d36ba7fe64cc4861fe4b4cae0">getValueAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc) const </td></tr>
<tr class="separator:a21c08c3d36ba7fe64cc4861fe4b4cae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b529733f0b52eb639833f197ca747ed"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a1b529733f0b52eb639833f197ca747ed"><td class="memTemplItemLeft" align="right" valign="top">ChildT::LeafNodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a1b529733f0b52eb639833f197ca747ed">touchLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="separator:a1b529733f0b52eb639833f197ca747ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3337cf5ee7f6e4190d74a28320d226e3"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a3337cf5ee7f6e4190d74a28320d226e3"><td class="memTemplItemLeft" align="right" valign="top">ChildT::LeafNodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a3337cf5ee7f6e4190d74a28320d226e3">probeLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="separator:a3337cf5ee7f6e4190d74a28320d226e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df78afa72de28b8ffe278e4b40554f9"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a6df78afa72de28b8ffe278e4b40554f9"><td class="memTemplItemLeft" align="right" valign="top">const ChildT::LeafNodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a6df78afa72de28b8ffe278e4b40554f9">probeConstLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc) const </td></tr>
<tr class="separator:a6df78afa72de28b8ffe278e4b40554f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19109c78ded455aa6750cf943d70a96e"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a19109c78ded455aa6750cf943d70a96e"><td class="memTemplItemLeft" align="right" valign="top">const ChildT::LeafNodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a19109c78ded455aa6750cf943d70a96e">probeLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc) const </td></tr>
<tr class="separator:a19109c78ded455aa6750cf943d70a96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac259caaa98b8de89120f4cdc20926ad3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ac259caaa98b8de89120f4cdc20926ad3">isBackgroundTile</a> (const MapIter &amp;) const </td></tr>
<tr class="memdesc:ac259caaa98b8de89120f4cdc20926ad3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given iterator points to an inactive tile with the background value.  <a href="#ac259caaa98b8de89120f4cdc20926ad3">More...</a><br /></td></tr>
<tr class="separator:ac259caaa98b8de89120f4cdc20926ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13d1d88614ecad7b27e54b48e9e1b647"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a13d1d88614ecad7b27e54b48e9e1b647">isBackgroundTile</a> (const MapCIter &amp;) const </td></tr>
<tr class="memdesc:a13d1d88614ecad7b27e54b48e9e1b647"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given iterator points to an inactive tile with the background value.  <a href="#a13d1d88614ecad7b27e54b48e9e1b647">More...</a><br /></td></tr>
<tr class="separator:a13d1d88614ecad7b27e54b48e9e1b647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a69bd60c87fb75e3bb7a9b5099f3a4bdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a69bd60c87fb75e3bb7a9b5099f3a4bdf">fill</a> (const CoordBBox &amp;bbox, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool active=true)</td></tr>
<tr class="memdesc:a69bd60c87fb75e3bb7a9b5099f3a4bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels within a given axis-aligned box to a constant value.  <a href="#a69bd60c87fb75e3bb7a9b5099f3a4bdf">More...</a><br /></td></tr>
<tr class="separator:a69bd60c87fb75e3bb7a9b5099f3a4bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad87de532e553a73bd6e3b55337eff1d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad87de532e553a73bd6e3b55337eff1d5">sparseFill</a> (const CoordBBox &amp;bbox, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool active=true)</td></tr>
<tr class="memdesc:ad87de532e553a73bd6e3b55337eff1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels within a given axis-aligned box to a constant value.  <a href="#ad87de532e553a73bd6e3b55337eff1d5">More...</a><br /></td></tr>
<tr class="separator:ad87de532e553a73bd6e3b55337eff1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af4aba8013df108be4d7eb3f58dd72cc6"><td class="memTemplParams" colspan="2">template&lt;typename NodeT &gt; </td></tr>
<tr class="memitem:af4aba8013df108be4d7eb3f58dd72cc6"><td class="memTemplItemLeft" align="right" valign="top">NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af4aba8013df108be4d7eb3f58dd72cc6">probeNode</a> (const Coord &amp;xyz)</td></tr>
<tr class="memdesc:af4aba8013df108be4d7eb3f58dd72cc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#af4aba8013df108be4d7eb3f58dd72cc6">More...</a><br /></td></tr>
<tr class="separator:af4aba8013df108be4d7eb3f58dd72cc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae193824374c84407959836af2b954d24"><td class="memTemplParams" colspan="2">template&lt;typename NodeT &gt; </td></tr>
<tr class="memitem:ae193824374c84407959836af2b954d24"><td class="memTemplItemLeft" align="right" valign="top">const NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ae193824374c84407959836af2b954d24">probeConstNode</a> (const Coord &amp;xyz) const </td></tr>
<tr class="memdesc:ae193824374c84407959836af2b954d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#ae193824374c84407959836af2b954d24">More...</a><br /></td></tr>
<tr class="separator:ae193824374c84407959836af2b954d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a4603c14d21fce223c55c03783fb7a8b2"><td class="memTemplParams" colspan="2">template&lt;typename NodeT , typename AccessorT &gt; </td></tr>
<tr class="memitem:a4603c14d21fce223c55c03783fb7a8b2"><td class="memTemplItemLeft" align="right" valign="top">NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a4603c14d21fce223c55c03783fb7a8b2">probeNodeAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="memdesc:a4603c14d21fce223c55c03783fb7a8b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af4aba8013df108be4d7eb3f58dd72cc6" title="Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeNode()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <a href="#a4603c14d21fce223c55c03783fb7a8b2">More...</a><br /></td></tr>
<tr class="separator:a4603c14d21fce223c55c03783fb7a8b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5343004e67df99c4720888555351b29"><td class="memTemplParams" colspan="2">template&lt;typename NodeT , typename AccessorT &gt; </td></tr>
<tr class="memitem:aa5343004e67df99c4720888555351b29"><td class="memTemplItemLeft" align="right" valign="top">const NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aa5343004e67df99c4720888555351b29">probeConstNodeAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc) const </td></tr>
<tr class="memdesc:aa5343004e67df99c4720888555351b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af4aba8013df108be4d7eb3f58dd72cc6" title="Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeNode()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <a href="#aa5343004e67df99c4720888555351b29">More...</a><br /></td></tr>
<tr class="separator:aa5343004e67df99c4720888555351b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a416387666c1bf211debea718d27e5e2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a416387666c1bf211debea718d27e5e2f">probeLeaf</a> (const Coord &amp;xyz)</td></tr>
<tr class="memdesc:a416387666c1bf211debea718d27e5e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#a416387666c1bf211debea718d27e5e2f">More...</a><br /></td></tr>
<tr class="separator:a416387666c1bf211debea718d27e5e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e736a8c396807bd2643176d6e7beee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ab0e736a8c396807bd2643176d6e7beee">probeConstLeaf</a> (const Coord &amp;xyz) const </td></tr>
<tr class="memdesc:ab0e736a8c396807bd2643176d6e7beee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#ab0e736a8c396807bd2643176d6e7beee">More...</a><br /></td></tr>
<tr class="separator:ab0e736a8c396807bd2643176d6e7beee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0565d3c3e0bd185197352b63e4d7a1e7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a0565d3c3e0bd185197352b63e4d7a1e7">probeLeaf</a> (const Coord &amp;xyz) const </td></tr>
<tr class="memdesc:a0565d3c3e0bd185197352b63e4d7a1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#a0565d3c3e0bd185197352b63e4d7a1e7">More...</a><br /></td></tr>
<tr class="separator:a0565d3c3e0bd185197352b63e4d7a1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a69eaa58a07109bba3487f514bc5d03bf"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a69eaa58a07109bba3487f514bc5d03bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a69eaa58a07109bba3487f514bc5d03bf">probeLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="memdesc:a69eaa58a07109bba3487f514bc5d03bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <a href="#a69eaa58a07109bba3487f514bc5d03bf">More...</a><br /></td></tr>
<tr class="separator:a69eaa58a07109bba3487f514bc5d03bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df4d3142810d501c9a24a329e838536"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a1df4d3142810d501c9a24a329e838536"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a1df4d3142810d501c9a24a329e838536">probeConstLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc) const </td></tr>
<tr class="memdesc:a1df4d3142810d501c9a24a329e838536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <a href="#a1df4d3142810d501c9a24a329e838536">More...</a><br /></td></tr>
<tr class="separator:a1df4d3142810d501c9a24a329e838536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52a4f527e2f7c37f9cacb2e12676628"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:ac52a4f527e2f7c37f9cacb2e12676628"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ac52a4f527e2f7c37f9cacb2e12676628">probeLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc) const </td></tr>
<tr class="memdesc:ac52a4f527e2f7c37f9cacb2e12676628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <a href="#ac52a4f527e2f7c37f9cacb2e12676628">More...</a><br /></td></tr>
<tr class="separator:ac52a4f527e2f7c37f9cacb2e12676628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a33a3cd99c0b9c78e1f6da3d9a36fdaff">getNodes</a> (ArrayT &amp;array)</td></tr>
<tr class="memdesc:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all nodes of a certain type to a container with the following API:  <a href="#a33a3cd99c0b9c78e1f6da3d9a36fdaff">More...</a><br /></td></tr>
<tr class="separator:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dda98f1a46783cb8638ef4a17462c0"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:ab4dda98f1a46783cb8638ef4a17462c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ab4dda98f1a46783cb8638ef4a17462c0">getNodes</a> (ArrayT &amp;array) const </td></tr>
<tr class="memdesc:ab4dda98f1a46783cb8638ef4a17462c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all nodes of a certain type to a container with the following API:  <a href="#ab4dda98f1a46783cb8638ef4a17462c0">More...</a><br /></td></tr>
<tr class="separator:ab4dda98f1a46783cb8638ef4a17462c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac4a8fd1479bd7b61a23884680d5d49e0"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:ac4a8fd1479bd7b61a23884680d5d49e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ac4a8fd1479bd7b61a23884680d5d49e0">stealNodes</a> (ArrayT &amp;array, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="memdesc:ac4a8fd1479bd7b61a23884680d5d49e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steals all nodes of a certain type from the tree and adds them to a container with the following API:  <a href="#ac4a8fd1479bd7b61a23884680d5d49e0">More...</a><br /></td></tr>
<tr class="separator:ac4a8fd1479bd7b61a23884680d5d49e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9865f5a8eabf75fc2ad06581e22edcd"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:ae9865f5a8eabf75fc2ad06581e22edcd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ae9865f5a8eabf75fc2ad06581e22edcd">stealNodes</a> (ArrayT &amp;array)</td></tr>
<tr class="memdesc:ae9865f5a8eabf75fc2ad06581e22edcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steals all nodes of a certain type from the tree and adds them to a container with the following API:  <a href="#ae9865f5a8eabf75fc2ad06581e22edcd">More...</a><br /></td></tr>
<tr class="separator:ae9865f5a8eabf75fc2ad06581e22edcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a00265a6f2e4bb7edf268ce430744f410"><td class="memItemLeft" align="right" valign="top">static CoordBBox&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a00265a6f2e4bb7edf268ce430744f410">getNodeBoundingBox</a> ()</td></tr>
<tr class="memdesc:a00265a6f2e4bb7edf268ce430744f410"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounding box of this <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, i.e., an infinite bounding box.  <a href="#a00265a6f2e4bb7edf268ce430744f410">More...</a><br /></td></tr>
<tr class="separator:a00265a6f2e4bb7edf268ce430744f410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7364ceedc39ddbd16d4f61f89dda4883"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a7364ceedc39ddbd16d4f61f89dda4883">getLevel</a> ()</td></tr>
<tr class="separator:a7364ceedc39ddbd16d4f61f89dda4883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b91d6e713861046431c86630d23ae2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad3b91d6e713861046431c86630d23ae2">getNodeLog2Dims</a> (std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &gt; &amp;dims)</td></tr>
<tr class="separator:ad3b91d6e713861046431c86630d23ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252a41011fe13e50c8d49b5ca14a979b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a252a41011fe13e50c8d49b5ca14a979b">getChildDim</a> ()</td></tr>
<tr class="separator:a252a41011fe13e50c8d49b5ca14a979b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0332904c042d4dc9e88136294e048ed0"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType &gt; </td></tr>
<tr class="memitem:a0332904c042d4dc9e88136294e048ed0"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a0332904c042d4dc9e88136294e048ed0">hasSameConfiguration</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="memdesc:a0332904c042d4dc9e88136294e048ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>false</code> if the other node's dimensions don't match this node's.  <a href="#a0332904c042d4dc9e88136294e048ed0">More...</a><br /></td></tr>
<tr class="separator:a0332904c042d4dc9e88136294e048ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44152640d1b71b1a5eaf192b9018bd53"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildType &gt; </td></tr>
<tr class="memitem:a44152640d1b71b1a5eaf192b9018bd53"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a44152640d1b71b1a5eaf192b9018bd53">hasCompatibleValueType</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;other)</td></tr>
<tr class="separator:a44152640d1b71b1a5eaf192b9018bd53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7efd456219bae7db497d009ad92961a7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a7efd456219bae7db497d009ad92961a7">LEVEL</a> = 1 + ChildType::LEVEL</td></tr>
<tr class="separator:a7efd456219bae7db497d009ad92961a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aff4f5e7209d5ad66394519639bd989f8"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:aff4f5e7209d5ad66394519639bd989f8"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aff4f5e7209d5ad66394519639bd989f8">RootNode</a></td></tr>
<tr class="separator:aff4f5e7209d5ad66394519639bd989f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac3b94dde9b204ff858644761361a95"><td class="memTemplParams" colspan="2">template&lt;typename , typename , bool &gt; </td></tr>
<tr class="memitem:adac3b94dde9b204ff858644761361a95"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#adac3b94dde9b204ff858644761361a95">RootNodeCopyHelper</a></td></tr>
<tr class="separator:adac3b94dde9b204ff858644761361a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733720747a659027d37f72bd461207eb"><td class="memTemplParams" colspan="2">template&lt;typename , typename , typename , bool &gt; </td></tr>
<tr class="memitem:a733720747a659027d37f72bd461207eb"><td class="memTemplItemLeft" align="right" valign="top">struct&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a733720747a659027d37f72bd461207eb">RootNodeCombineHelper</a></td></tr>
<tr class="separator:a733720747a659027d37f72bd461207eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ab723abdcfd580fb1fc5eebf5da5d9660"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ab723abdcfd580fb1fc5eebf5da5d9660">BuildType</a> =  typename ChildType::BuildType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aba3a2d9f84085e3e6b54f4358df5eb28"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aba3a2d9f84085e3e6b54f4358df5eb28">ChildAllCIter</a> =  DenseIter&lt;const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, const ChildType, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a01bb1bcecd7385c19f214c7dd217fb27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a01bb1bcecd7385c19f214c7dd217fb27">ChildAllIter</a> =  DenseIter&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ChildType, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add0b43407ef7279a458b5b63c604ae73"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#add0b43407ef7279a458b5b63c604ae73">ChildNodeType</a> =  ChildType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a629fb04c86fa214750225c9f1d146a36"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a629fb04c86fa214750225c9f1d146a36">ChildOffCIter</a> =  ValueIter&lt;const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ChildOffPred, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad70584e8033dbc079fdc0ac57d167eee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad70584e8033dbc079fdc0ac57d167eee">ChildOffIter</a> =  ValueIter&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ChildOffPred, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af961e6cbba1568e6b4e3edac87952dbd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af961e6cbba1568e6b4e3edac87952dbd">ChildOnCIter</a> =  ChildIter&lt;const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ChildOnPred, const ChildType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a53ddfd147d086003e983f40409d651ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a53ddfd147d086003e983f40409d651ff">ChildOnIter</a> =  ChildIter&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ChildOnPred, ChildType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a47b1764141687712562480c3cdd74c1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> =  typename ChildType::LeafNodeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a476192215f8d4ee389caf42204e3020f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a476192215f8d4ee389caf42204e3020f">NodeChainType</a> =  typename <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1NodeChain.html">NodeChain</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a7efd456219bae7db497d009ad92961a7">LEVEL</a>&gt;::Type</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NodeChainType is a list of this tree's node types, from LeafNodeType to <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>. </p>

</div>
</div>
<a class="anchor" id="a755eaad7b1dba0812844255cee5c48bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a755eaad7b1dba0812844255cee5c48bf">ValueAllCIter</a> =  ValueIter&lt;const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ValueAllPred, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3e96b29bec06304babad73d51b201945"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a3e96b29bec06304babad73d51b201945">ValueAllIter</a> =  ValueIter&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ValueAllPred, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a04bce38e91a758eb215875e9ad0c0add"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a04bce38e91a758eb215875e9ad0c0add">ValueOffCIter</a> =  ValueIter&lt;const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ValueOffPred, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3cc6b3daa5baf71df51fb8426470d8c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a3cc6b3daa5baf71df51fb8426470d8c7">ValueOffIter</a> =  ValueIter&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ValueOffPred, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a15fddbb02f413af01b4b839e82f5e49f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a15fddbb02f413af01b4b839e82f5e49f">ValueOnCIter</a> =  ValueIter&lt;const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapCIter, ValueOnPred, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4eb611c9fc0de11faa69c866d88f680a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a4eb611c9fc0de11faa69c866d88f680a">ValueOnIter</a> =  ValueIter&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, MapIter, ValueOnPred, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a89ab9062c358edc408d37deac2eb8538"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> =  typename ChildType::ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aa5dbd319ba70f5491e4326ec341273d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new tree with a background value of 0. </p>

</div>
</div>
<a class="anchor" id="a962d5c3401f8c0a8f60d71b141e7fb3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>background</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new tree with the given background value. </p>

</div>
</div>
<a class="anchor" id="a08562b54850ff29ef167b7a1d1cfadd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4048d463e26625beb9e08adbd50528e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new tree that reproduces the topology and active states of a tree of a different ValueType but the same configuration (levels, node dimensions and branching factors). Cast the other tree's values to this tree's ValueType. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__1_1_1TypeError.html">TypeError</a></td><td>if the other tree's configuration doesn't match this tree's or if this tree's ValueType is not constructible from the other tree's ValueType. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab6e523d80a6b90c3b63ef1c40939c7d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>foreground</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1TopologyCopy.html">TopologyCopy</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new tree that reproduces the topology and active states of another tree (which may have a different ValueType), but not the other tree's values. </p>
<p>All tiles and voxels that are active in the other tree are set to <em>foreground</em> in the new tree, and all inactive tiles and voxels are set to <em>background</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the root node of a tree having (possibly) a different ValueType </td></tr>
    <tr><td class="paramname">background</td><td>the value to which inactive tiles and voxels are initialized </td></tr>
    <tr><td class="paramname">foreground</td><td>the value to which active tiles and voxels are initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__1_1_1TypeError.html">TypeError</a></td><td>if the other tree's configuration doesn't match this tree's. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1376f67d16d5de9a4d152a45f863f0cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1TopologyCopy.html">TopologyCopy</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new tree that reproduces the topology and active states of another tree (which may have a different ValueType), but not the other tree's values. All tiles and voxels in the new tree are set to <em>background</em> regardless of their active states in the other tree. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>the root node of a tree having (possibly) a different ValueType </td></tr>
    <tr><td class="paramname">background</td><td>the value to which inactive tiles and voxels are initialized </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This copy constructor is generally faster than the one that takes both a foreground and a background value. Its main application is in multithreaded operations where the topology of the output tree exactly matches the input tree. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__1_1_1TypeError.html">TypeError</a></td><td>if the other tree's configuration doesn't match this tree's. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aaf38ff0107dcb0e50c0f4e5783146459"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a2ed56c39d458885f1191405c625e73d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool addChild </td>
          <td>(</td>
          <td class="paramtype">ChildType *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given child node at the root level. If a child node with the same origin already exists, delete the old node and add the new node in its place (i.e. ownership of the new child node is transferred to this <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> (for consistency with <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#accdef4f30a36c0687e67f0e5f467ad2e" title="Add the given child node at this level deducing the offset from it&#39;s origin. If a child node with thi...">InternalNode::addChild</a>) </dd></dl>

</div>
</div>
<a class="anchor" id="a6c20c22e9a994a30c9640cbe1ec982bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td>
          <td class="paramname"><em>leaf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given leaf node to this tree, creating a new branch if necessary. If a leaf node with the same origin already exists, replace it. </p>

</div>
</div>
<a class="anchor" id="a23d57da960fd963ab7a02836ebf005b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addLeafAndCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a> *&#160;</td>
          <td class="paramname"><em>leaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a6c20c22e9a994a30c9640cbe1ec982bc" title="Add the given leaf node to this tree, creating a new branch if necessary. If a leaf node with the sam...">addLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a class="anchor" id="a6fd27c86bf273fa436a0e8c9d41b28af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addTile </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a tile containing voxel (x, y, z) at the root level, deleting the existing branch if necessary. </p>

</div>
</div>
<a class="anchor" id="a58ab61f904112334f418ea8a1235cdad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addTile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a tile containing voxel (x, y, z) at the specified tree level, creating a new branch if necessary. Delete any existing lower-level nodes that contain (x, y, z). </p>

</div>
</div>
<a class="anchor" id="a88baa1b1d12b360589dbe49a344be2b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addTileAndCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a6fd27c86bf273fa436a0e8c9d41b28af" title="Add a tile containing voxel (x, y, z) at the root level, deleting the existing branch if necessary...">addTile()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a class="anchor" id="acccdab5ee066678e77d16f516d527d33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&amp; background </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return this node's background value. </p>

</div>
</div>
<a class="anchor" id="a599e840b09098cf3437a3c4bd366ee79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aba3a2d9f84085e3e6b54f4358df5eb28">ChildAllCIter</a> beginChildAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7000148c6f1dc8bfbb0139a3606e188e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a01bb1bcecd7385c19f214c7dd217fb27">ChildAllIter</a> beginChildAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8438e994f130eacf9f40014a97514bcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a629fb04c86fa214750225c9f1d146a36">ChildOffCIter</a> beginChildOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a845985fcf5013cc3fe15865b05b3abd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ad70584e8033dbc079fdc0ac57d167eee">ChildOffIter</a> beginChildOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a31c7157dee0e08c357e6a3ed6415a00e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af961e6cbba1568e6b4e3edac87952dbd">ChildOnCIter</a> beginChildOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f712beff77da092dd726a59e1104cf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a53ddfd147d086003e983f40409d651ff">ChildOnIter</a> beginChildOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a18ec03c783bc71e824837c826dd6531c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a755eaad7b1dba0812844255cee5c48bf">ValueAllCIter</a> beginValueAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afdf6fa279da1f6839a3ca381828220df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a3e96b29bec06304babad73d51b201945">ValueAllIter</a> beginValueAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a17282c62bdf7cdd25be3b773b39907b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a04bce38e91a758eb215875e9ad0c0add">ValueOffCIter</a> beginValueOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad555f92c70739496805fb480c3b38f85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a3cc6b3daa5baf71df51fb8426470d8c7">ValueOffIter</a> beginValueOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f82a16370621f762a097f27122e51db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a15fddbb02f413af01b4b839e82f5e49f">ValueOnCIter</a> beginValueOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b8568cb11eacfedf042fa1eda680a45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a4eb611c9fc0de11faa69c866d88f680a">ValueOnIter</a> beginValueOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae5c7824607dbdc3c1165e0b0daea8bcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#aba3a2d9f84085e3e6b54f4358df5eb28">ChildAllCIter</a> cbeginChildAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8169dc13d3aad941b6490f27a4bbb839"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a629fb04c86fa214750225c9f1d146a36">ChildOffCIter</a> cbeginChildOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a63e9bf1256874f802e2dbbc7db56f8ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af961e6cbba1568e6b4e3edac87952dbd">ChildOnCIter</a> cbeginChildOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b296755b1634e77e5fff9c4c48ea3c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a755eaad7b1dba0812844255cee5c48bf">ValueAllCIter</a> cbeginValueAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae16c1191cb1a539a7cc0cdee5803d860"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a04bce38e91a758eb215875e9ad0c0add">ValueOffCIter</a> cbeginValueOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad554801c644ee82931281a11f801bf5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a15fddbb02f413af01b4b839e82f5e49f">ValueOnCIter</a> cbeginValueOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf8732f8cd6e4c4dc8ae7b338343d082"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> childCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac8bb3912a3ce86b15842e79d0b421204"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a409633b422404c1c7df4e0ffdd02eac1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clip </td>
          <td>(</td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>clipBBox</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels that lie outside the given axis-aligned box to the background. </p>

</div>
</div>
<a class="anchor" id="a2d0f6f48c7b53111118bf1a14a8dff03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a59d05166d77d6604823a6e669f3b53f7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherRootNode&lt; ChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prune</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="addb6357bae687189b953c677911834ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void copyToDense </td>
          <td>(</td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseT &amp;&#160;</td>
          <td class="paramname"><em>dense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy into a dense grid the values of all voxels, both active and inactive, that intersect a given bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive bounding box of the voxels to be copied into the dense grid </td></tr>
    <tr><td class="paramname">dense</td><td>dense grid with a stride in <em>z</em> of one (see <a class="el" href="classopenvdb_1_1v8__1_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below...">tools::Dense</a> in <a class="el" href="Dense_8h.html" title="This file defines a simple dense grid and efficient converters to and from VDB grids. ">tools/Dense.h</a> for the required API) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb399cd065108e53e7b65612e74372a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void denseFill </td>
          <td>(</td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels within a given axis-aligned box to a constant value and ensure that those voxels are all represented at the leaf level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive coordinates of opposite corners of an axis-aligned box. </td></tr>
    <tr><td class="paramname">value</td><td>the value to which to set voxels within the box. </td></tr>
    <tr><td class="paramname">active</td><td>if true, mark voxels within the box as active, otherwise mark them as inactive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a39a2211a02fb606e611d3ff5bbd6f50c" title="Densify active tiles, i.e., replace them with leaf-level active voxels. ">voxelizeActiveTiles()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac6e61de369e994009e36f344f99c15ad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if this node's table is either empty or contains only background tiles. </p>

</div>
</div>
<a class="anchor" id="a48dc4a8d53d718280d347a867cd6704b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t eraseBackgroundTiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all background tiles. </p>
<dl class="section return"><dt>Returns</dt><dd>the number of tiles removed. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4f72230ae8ade2c0a5e712708c36fa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evalActiveBoundingBox </td>
          <td>(</td>
          <td class="paramtype">CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visitVoxels</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand the specified bbox so it includes the active tiles of this root node as well as all the active values in its child nodes. If visitVoxels is false LeafNodes will be approximated as dense, i.e. with all voxels active. Else the individual active voxels are visited to produce a tight bbox. </p>

</div>
</div>
<a class="anchor" id="aed5bfeb2da24cc37e6561b3cd0f5f1f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool expand </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand this node's table so that (x, y, z) is included in the index range. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an expansion was performed (i.e., if (x, y, z) was not already included in the index range). </dd></dl>

</div>
</div>
<a class="anchor" id="a69bd60c87fb75e3bb7a9b5099f3a4bdf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fill </td>
          <td>(</td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels within a given axis-aligned box to a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive coordinates of opposite corners of an axis-aligned box </td></tr>
    <tr><td class="paramname">value</td><td>the value to which to set voxels within the box </td></tr>
    <tr><td class="paramname">active</td><td>if true, mark voxels within the box as active, otherwise mark them as inactive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation generates a sparse, but not always optimally sparse, representation of the filled box. Follow fill operations with a <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a462c7056adc55d8da2cc5828934ff859" title="Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the s...">prune()</a> operation for optimal sparseness. </dd></dl>

</div>
</div>
<a class="anchor" id="a252a41011fe13e50c8d49b5ca14a979b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getChildDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9c602c12ff468865a25ce83ff7fb8c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getDepth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acb8a1436aa153d08fa6e73f59f871976"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getHeight </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a79c5c77b8e79b139e3da5e4f16ed00f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getIndexRange </td>
          <td>(</td>
          <td class="paramtype">CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current index range. Both min and max are inclusive. </p>

</div>
</div>
<a class="anchor" id="a7364ceedc39ddbd16d4f61f89dda4883"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2abbf438654aa1950e0c58ec7a717615"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Coord getMaxIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the largest index of the current tree. </p>

</div>
</div>
<a class="anchor" id="a4ad45f83af7980f8e2b181ab62a39dec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Coord getMinIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the smallest index of the current tree. </p>

</div>
</div>
<a class="anchor" id="a00265a6f2e4bb7edf268ce430744f410"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CoordBBox getNodeBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bounding box of this <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>, i.e., an infinite bounding box. </p>

</div>
</div>
<a class="anchor" id="ad3b91d6e713861046431c86630d23ae2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodeLog2Dims </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a33a3cd99c0b9c78e1f6da3d9a36fdaff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all nodes of a certain type to a container with the following API: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayT {</div><div class="line">   <span class="keyword">using</span> value_type = ...;<span class="comment">// defines the type of nodes to be added to the array</span></div><div class="line">   <span class="keywordtype">void</span> push_back(value_type nodePtr);<span class="comment">// method that add nodes to the array</span></div><div class="line">};</div></div><!-- fragment --><p>An example of a wrapper around a c-style array is: </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>MyArray {</div><div class="line">    <span class="keyword">using</span> value_type = LeafType*;</div><div class="line">    value_type* ptr;</div><div class="line">    MyArray(value_type* array) : ptr(array) {}</div><div class="line">    <span class="keywordtype">void</span> push_back(value_type leaf) { *ptr++ = leaf; }</div><div class="line">};</div></div><!-- fragment --><p>An example that constructs a list of pointer to all leaf nodes is: </p><div class="fragment"><div class="line">std::vector&lt;const LeafNodeType*&gt; array;<span class="comment">//most std contains have the required API</span></div><div class="line">array.reserve(tree.leafCount());<span class="comment">//this is a fast preallocation.</span></div><div class="line">tree.getNodes(array);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab4dda98f1a46783cb8638ef4a17462c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all nodes of a certain type to a container with the following API: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayT {</div><div class="line">   <span class="keyword">using</span> value_type = ...;<span class="comment">// defines the type of nodes to be added to the array</span></div><div class="line">   <span class="keywordtype">void</span> push_back(value_type nodePtr);<span class="comment">// method that add nodes to the array</span></div><div class="line">};</div></div><!-- fragment --><p>An example of a wrapper around a c-style array is: </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>MyArray {</div><div class="line">    <span class="keyword">using</span> value_type = LeafType*;</div><div class="line">    value_type* ptr;</div><div class="line">    MyArray(value_type* array) : ptr(array) {}</div><div class="line">    <span class="keywordtype">void</span> push_back(value_type leaf) { *ptr++ = leaf; }</div><div class="line">};</div></div><!-- fragment --><p>An example that constructs a list of pointer to all leaf nodes is: </p><div class="fragment"><div class="line">std::vector&lt;const LeafNodeType*&gt; array;<span class="comment">//most std contains have the required API</span></div><div class="line">array.reserve(tree.leafCount());<span class="comment">//this is a fast preallocation.</span></div><div class="line">tree.getNodes(array);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a090c046211c122ce4bba72d102f578e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getTableSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of entries in this node's table. </p>

</div>
</div>
<a class="anchor" id="a8ce49c1d01fb40115f7253b65dd98a38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::ValueType &amp; getValue </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab54f367109416043c0ce7d175be04c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&amp; getValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the voxel at the given coordinates and, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a21c08c3d36ba7fe64cc4861fe4b4cae0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::ValueType&amp; getValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adabe21e6eb918bee1d29c161c6ce03ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getValueDepth </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the tree depth (0 = root) at which the value of voxel (x, y, z) resides. </p>
<p>If (x, y, z) isn't explicitly represented in the tree (i.e., it is implicitly a background voxel), return -1. </p>

</div>
</div>
<a class="anchor" id="a0df3d050e327bad074c288d65bf7e4d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int getValueDepthAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tree depth (0 = root) at which the value of voxel (x, y, z) resides. If (x, y, z) isn't explicitly represented in the tree (i.e., it is implicitly a background voxel), return -1. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5917a5c4d6b84e2f083a5db8c004277"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getWidth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e1a133192d9d344c482d4aa83f6da33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasActiveTiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if this root node, or any of its child nodes, have active tiles. </p>

</div>
</div>
<a class="anchor" id="a44152640d1b71b1a5eaf192b9018bd53"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasCompatibleValueType </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if values of the other node's ValueType can be converted to values of this node's ValueType. </p>

</div>
</div>
<a class="anchor" id="a0332904c042d4dc9e88136294e048ed0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasSameConfiguration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>false</code> if the other node's dimensions don't match this node's. </p>

</div>
</div>
<a class="anchor" id="ad2290c7162c015d83e057eca2dd23dc1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasSameTopology </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given tree has the same node and active value topology as this tree (but possibly a different <code>ValueType</code>). </p>

</div>
</div>
<a class="anchor" id="a275e55e8c343dad4159b8ada32f99cde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isBackgroundTile </td>
          <td>(</td>
          <td class="paramtype">const Tile &amp;&#160;</td>
          <td class="paramname"><em>tile</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given tile is inactive and has the background value. </p>

</div>
</div>
<a class="anchor" id="ac259caaa98b8de89120f4cdc20926ad3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isBackgroundTile </td>
          <td>(</td>
          <td class="paramtype">const MapIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given iterator points to an inactive tile with the background value. </p>

</div>
</div>
<a class="anchor" id="a13d1d88614ecad7b27e54b48e9e1b647"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isBackgroundTile </td>
          <td>(</td>
          <td class="paramtype">const MapCIter &amp;&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given iterator points to an inactive tile with the background value. </p>

</div>
</div>
<a class="anchor" id="afc695b4cc2c115afbdb51d4997b69747"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueOn </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b19bb2b11319fb6eaab50aada9bff01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueOnAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if the voxel at the given coordinates is active and, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0667d468064aa044670a06a84b9c48ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> leafCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8443805eb98462d37d9c3f7b549ede0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> memUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total amount of memory in bytes occupied by this node and its children. </p>

</div>
</div>
<a class="anchor" id="a52a7e4a512b1082887098547c2781ed0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficiently merge another tree into this tree using one of several schemes. </p>
<p>This operation is primarily intended to combine trees that are mostly non-overlapping (for example, intermediate trees from computations that are parallelized across disjoint regions of space). </p><dl class="section note"><dt>Note</dt><dd>This operation is not guaranteed to produce an optimally sparse tree. Follow <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a52a7e4a512b1082887098547c2781ed0" title="Efficiently merge another tree into this tree using one of several schemes. ">merge()</a> with <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a462c7056adc55d8da2cc5828934ff859" title="Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the s...">prune()</a> for optimal sparseness. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This operation always empties the other tree. </dd></dl>

</div>
</div>
<a class="anchor" id="aa6954a428c0ef18a03431f251f4e7d24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValue </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor to the value of the voxel at the given coordinates and mark the voxel as active. </p>

</div>
</div>
<a class="anchor" id="a5cb69af7e17c3a9a6d6dc360c878448c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValueAndActiveState </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor to the voxel at the given coordinates. </p>

</div>
</div>
<a class="anchor" id="af057648803b9073ce1703dbf061e0d1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValueAndActiveStateAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a functor to the voxel at the given coordinates. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bed5c7c0d76cacfb514d9744f754402"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a functor to the value of the voxel at the given coordinates and mark the voxel as active. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aa4ac16944cc943e8a524cc80824182ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nodeCount </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8d22ef34f6459bcffc00f6eb8f747b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> nonLeafCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aca78cbf1bae9694422702b2f3fb81950"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t numBackgroundTiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of background tiles. </p>

</div>
</div>
<a class="anchor" id="a78ac72edbf61ebf466b06f6bb4f1ffc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> offLeafVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a22486b1420a67aaf492e7e4ca2ca6fb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> offVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe2ccd641ba4842769eb649c856d05b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> onLeafVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8c7f5922acf9662196a81ec4470aedd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> onTileCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae41639979a334066f76633037c605a77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> onVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1b775efb979e2d7445d43aaf7cb900d0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildT &gt; &amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; ChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy a root node of the same type as this node. </p>

</div>
</div>
<a class="anchor" id="a0447467224f7c21ad0e3926279ab7eb9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy a root node of the same tree configuration as this node but a different ValueType. </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classopenvdb_1_1v8__1_1_1TypeError.html">TypeError</a></td><td>if the other tree's configuration doesn't match this tree's. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This node's ValueType must be constructible from the other node's ValueType. For example, a root node with values of type float can be assigned to a root node with values of type Vec3s, because a Vec3s can be constructed from a float. But a Vec3s root node cannot be assigned to a float root node. </dd></dl>

</div>
</div>
<a class="anchor" id="aef2b73375c068f1a01a7ee5b4f55d8b1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt;ChildT&gt;&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab0e736a8c396807bd2643176d6e7beee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::LeafNodeType * probeConstLeaf </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a class="anchor" id="a1df4d3142810d501c9a24a329e838536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a>* probeConstLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a class="anchor" id="a6df78afa72de28b8ffe278e4b40554f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::LeafNodeType* probeConstLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae193824374c84407959836af2b954d24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const NodeT * probeConstNode </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a class="anchor" id="aa5343004e67df99c4720888555351b29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const NodeT * probeConstNodeAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af4aba8013df108be4d7eb3f58dd72cc6" title="Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeNode()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a class="anchor" id="a416387666c1bf211debea718d27e5e2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT::LeafNodeType * probeLeaf </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a class="anchor" id="a0565d3c3e0bd185197352b63e4d7a1e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a>* probeLeaf </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a class="anchor" id="a69eaa58a07109bba3487f514bc5d03bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a>* probeLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a class="anchor" id="ac52a4f527e2f7c37f9cacb2e12676628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a>* probeLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a class="anchor" id="a3337cf5ee7f6e4190d74a28320d226e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT::LeafNodeType* probeLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a19109c78ded455aa6750cf943d70a96e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::LeafNodeType* probeLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af4aba8013df108be4d7eb3f58dd72cc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeT * probeNode </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a class="anchor" id="a4603c14d21fce223c55c03783fb7a8b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeT * probeNodeAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#af4aba8013df108be4d7eb3f58dd72cc6" title="Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeNode()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a class="anchor" id="a0535ed999c1364a5bc5f31e668e5ef7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool probeValue </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab682876d96e5d4b4c7bd90ef19638d7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool probeValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return, in <em>value</em>, the value of the voxel at the given coordinates and, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the voxel at the given coordinates is active </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a462c7056adc55d8da2cc5828934ff859"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prune </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__1.html#a9bc9fb4000c5e821a917537e91e21eda">zeroVal</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the same (optionally to within a tolerance) and have the same active state. </p>
<dl class="section note"><dt>Note</dt><dd>Consider instead using <a class="el" href="namespaceopenvdb_1_1v8__1_1_1tools.html#a8057e1165c928a37703f90eb9496083c" title="Reduce the memory footprint of a tree by replacing with tiles any nodes whose values are all the same...">tools::prune</a> which is multi-threaded! </dd></dl>

</div>
</div>
<a class="anchor" id="aef270a4e4900e5e0bd24e6664d6a8a82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readBuffers </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d516efdbb242e00e7c77ae85cc426b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readBuffers </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>clipBBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af5537d3d93b7137d3f03007b31077921"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool readTopology </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b3e82eb582914ac6f31f32fea77292f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setActiveState </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the active state of the voxel at the given coordinates but don't change its value. </p>

</div>
</div>
<a class="anchor" id="ac04db06362bfb5ec0ed6212469eb4ff3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setActiveStateAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the active state of the voxel at the given coordinates without changing its value. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9a9be183fae028c2479dd20163a52ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setBackground </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>updateChildNodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change inactive tiles or voxels with a value equal to +/- the old background to the specified value (with the same sign). Active values are unchanged. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>The new background value </td></tr>
    <tr><td class="paramname">updateChildNodes</td><td>If true the background values of the child nodes is also updated. Else only the background value stored in the <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a> itself is changed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Instead of setting <em>updateChildNodes</em> to true, consider using <a class="el" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ad795f2f3910144753a5e03d12f4703de" title="Replace the background value in all the nodes of a tree. ">tools::changeBackground</a> or <a class="el" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ae9b9e9c02f534160f2571613f2d67ef5" title="Replace the background value in all the nodes of a floating-point tree containing a symmetric narrow-...">tools::changeLevelSetBackground</a> which are multi-threaded! </dd></dl>

</div>
</div>
<a class="anchor" id="a01b75fc2aa129aa05ae677971dc1972e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value of the voxel at the given coordinates and mark it as active. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a8a91d631df8f64f84a0aad7436cb11f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOff </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the voxel at the given coordinates as inactive but don't change its value. </p>

</div>
</div>
<a class="anchor" id="a73a6e7c85d37e7d677eddc3cce8aa11b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOff </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates and mark the voxel as inactive. </p>

</div>
</div>
<a class="anchor" id="a6c0c65991a0b3c81933cd944d8fc4267"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOffAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value of the voxel at the given coordinates and mark it as inactive. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ae95653046c85afb743075f139a26df9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOn </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates and mark the voxel as active. </p>

</div>
</div>
<a class="anchor" id="a63ff695beda11ed9ef625a28ce8a5faf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnly </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates but don't change its active state. </p>

</div>
</div>
<a class="anchor" id="a5cefbe46cc3180e5394a2f4fc775bfe8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnlyAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the value of the voxel at the given coordinates without changing its active state. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad87de532e553a73bd6e3b55337eff1d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sparseFill </td>
          <td>(</td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels within a given axis-aligned box to a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive coordinates of opposite corners of an axis-aligned box </td></tr>
    <tr><td class="paramname">value</td><td>the value to which to set voxels within the box </td></tr>
    <tr><td class="paramname">active</td><td>if true, mark voxels within the box as active, otherwise mark them as inactive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation generates a sparse, but not always optimally sparse, representation of the filled box. Follow fill operations with a <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a462c7056adc55d8da2cc5828934ff859" title="Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the s...">prune()</a> operation for optimal sparseness. </dd></dl>

</div>
</div>
<a class="anchor" id="a37a91bb3ba79b24928bc0f68e950c837"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeT * stealNode </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the node of type <code>NodeT</code> that contains voxel (x, y, z) and replace it with a tile of the specified value and state. If no such node exists, leave the tree unchanged and return <code>nullptr</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The caller takes ownership of the node and is responsible for deleting it.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Since this method potentially removes nodes and branches of the tree, it is important to clear the caches of all ValueAccessors associated with this tree. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4a8fd1479bd7b61a23884680d5d49e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stealNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a89ab9062c358edc408d37deac2eb8538">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Steals all nodes of a certain type from the tree and adds them to a container with the following API: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayT {</div><div class="line">   <span class="keyword">using</span> value_type = ...;<span class="comment">// defines the type of nodes to be added to the array</span></div><div class="line">   <span class="keywordtype">void</span> push_back(value_type nodePtr);<span class="comment">// method that add nodes to the array</span></div><div class="line">};</div></div><!-- fragment --><p>An example of a wrapper around a c-style array is: </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>MyArray {</div><div class="line">    <span class="keyword">using</span> value_type = LeafType*;</div><div class="line">    value_type* ptr;</div><div class="line">    MyArray(value_type* array) : ptr(array) {}</div><div class="line">    <span class="keywordtype">void</span> push_back(value_type leaf) { *ptr++ = leaf; }</div><div class="line">};</div></div><!-- fragment --><p>An example that constructs a list of pointer to all leaf nodes is: </p><div class="fragment"><div class="line">std::vector&lt;const LeafNodeType*&gt; array;<span class="comment">//most std contains have the required API</span></div><div class="line">array.reserve(tree.leafCount());<span class="comment">//this is a fast preallocation.</span></div><div class="line">tree.stealNodes(array);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ae9865f5a8eabf75fc2ad06581e22edcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stealNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Steals all nodes of a certain type from the tree and adds them to a container with the following API: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayT {</div><div class="line">   <span class="keyword">using</span> value_type = ...;<span class="comment">// defines the type of nodes to be added to the array</span></div><div class="line">   <span class="keywordtype">void</span> push_back(value_type nodePtr);<span class="comment">// method that add nodes to the array</span></div><div class="line">};</div></div><!-- fragment --><p>An example of a wrapper around a c-style array is: </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>MyArray {</div><div class="line">    <span class="keyword">using</span> value_type = LeafType*;</div><div class="line">    value_type* ptr;</div><div class="line">    MyArray(value_type* array) : ptr(array) {}</div><div class="line">    <span class="keywordtype">void</span> push_back(value_type leaf) { *ptr++ = leaf; }</div><div class="line">};</div></div><!-- fragment --><p>An example that constructs a list of pointer to all leaf nodes is: </p><div class="fragment"><div class="line">std::vector&lt;const LeafNodeType*&gt; array;<span class="comment">//most std contains have the required API</span></div><div class="line">array.reserve(tree.leafCount());<span class="comment">//this is a fast preallocation.</span></div><div class="line">tree.stealNodes(array);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a4bfa9bd46c8206d75f01c69c05425b5d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void topologyDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Difference this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different. So a resulting voxel will be active only if the original voxel is active in this tree and inactive in the other tree. </p>
<dl class="section note"><dt>Note</dt><dd>This operation can delete branches in this grid if they overlap with active tiles in the other grid. Likewise active voxels can be turned into inactive voxels resulting in leaf nodes with no active values. Thus, it is recommended to subsequently call prune. </dd></dl>

</div>
</div>
<a class="anchor" id="ac29f98775a4d88dc3163abc979db6060"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void topologyIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Intersects this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different. </p>
<p>The resulting state of a value is active only if the corresponding value was already active AND if it is active in the other tree. Also, a resulting value maps to a voxel if the corresponding value already mapped to an active voxel in either of the two grids and it maps to an active tile or voxel in the other grid.</p>
<dl class="section note"><dt>Note</dt><dd>This operation can delete branches in this grid if they overlap with inactive tiles in the other grid. Likewise active voxels can be turned into inactive voxels resulting in leaf nodes with no active values. Thus, it is recommended to subsequently call prune. </dd></dl>

</div>
</div>
<a class="anchor" id="a3fb824077105112bae944f31ad9c2fe0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void topologyUnion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a>&lt; OtherChildType &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>preserveTiles</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Union this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different. </p>
<p>The resulting state of a value is active if the corresponding value was already active OR if it is active in the other tree. Also, a resulting value maps to a voxel if the corresponding value already mapped to a voxel OR if it is a voxel in the other tree. Thus, a resulting value can only map to a tile if the corresponding value already mapped to a tile AND if it is a tile value in other tree.</p>
<dl class="section note"><dt>Note</dt><dd>This operation modifies only active states, not values. Specifically, active tiles and voxels in this tree are not changed, and tiles or voxels that were inactive in this tree but active in the other tree are marked as active in this tree but left with their original values.</dd>
<dd>
If preserveTiles is true, any active tile in this topology will not be densified by overlapping child topology. </dd></dl>

</div>
</div>
<a class="anchor" id="ab67464c0a432fdd5591c830b5589ce42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT::LeafNodeType * touchLeaf </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, create one that preserves the values and active states of all voxels. </p>
<p>Use this method to preallocate a static tree topology over which to safely perform multithreaded processing. </p>

</div>
</div>
<a class="anchor" id="a87111eb89261bcfaba2d9863f81c92d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#a47b1764141687712562480c3cdd74c1b">LeafNodeType</a>* touchLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#ab67464c0a432fdd5591c830b5589ce42" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, create one that preserves the values and active states of all voxels. ">touchLeaf()</a> but, if necessary, update the given accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a class="anchor" id="a1b529733f0b52eb639833f197ca747ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT::LeafNodeType* touchLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a028a58e937882a91e9c1470fb6e73b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit </td>
          <td>(</td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6e62589958cedae5c2cd4b356f6ba7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit </td>
          <td>(</td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7c5dff97dd17f56a711d483615450d73"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit2 </td>
          <td>(</td>
          <td class="paramtype">OtherRootNodeType &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1d81485014bea7517cbbf9e22a31d57e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit2 </td>
          <td>(</td>
          <td class="paramtype">OtherRootNodeType &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a973ced84fe7b684d6be0acb5cef74c33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visitActiveBBox </td>
          <td>(</td>
          <td class="paramtype">BBoxOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Call the templated functor BBoxOp with bounding box information for all active tiles and leaf nodes in the tree. An additional level argument is provided for each callback. </p>
<dl class="section note"><dt>Note</dt><dd>The bounding boxes are guaranteed to be non-overlapping. </dd></dl>

</div>
</div>
<a class="anchor" id="a39a2211a02fb606e611d3ff5bbd6f50c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void voxelizeActiveTiles </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Densify active tiles, i.e., replace them with leaf-level active voxels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threaded</td><td>if true, this operation is multi-threaded (over the internal nodes).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This method can explode the tree's memory footprint, especially if it contains active tiles at the upper levels (in particular the root level)!</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html#abb399cd065108e53e7b65612e74372a5" title="Set all voxels within a given axis-aligned box to a constant value and ensure that those voxels are a...">denseFill()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1517c3788b6d11d5e07a577dd38d7c43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeBuffers </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a06f55fa18912a20bc669cc8ac4c31ec1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool writeTopology </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="aff4f5e7209d5ad66394519639bd989f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1RootNode.html">RootNode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>During topology-only construction, access is needed to protected/private members of other template instances. </p>

</div>
</div>
<a class="anchor" id="a733720747a659027d37f72bd461207eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1RootNodeCombineHelper.html">RootNodeCombineHelper</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adac3b94dde9b204ff858644761361a95"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1RootNodeCopyHelper.html">RootNodeCopyHelper</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7efd456219bae7db497d009ad92961a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> LEVEL = 1 + ChildType::LEVEL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="RootNode_8h_source.html">RootNode.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
