<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: InternalNode&lt; _ChildNodeType, Log2Dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceopenvdb.html">openvdb</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__1.html">v8_1</a></li><li class="navelem"><a class="el" href="namespaceopenvdb_1_1v8__1_1_1tree.html">tree</a></li><li class="navelem"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">InternalNode&lt; _ChildNodeType, Log2Dim &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="InternalNode_8h_source.html">InternalNode.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildAll.html">ChildAll</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildIter.html">ChildIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildOff.html">ChildOff</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildOn.html">ChildOn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1DeepCopy.html">DeepCopy</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1DenseIter.html">DenseIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1SameConfiguration.html">SameConfiguration</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1SameConfiguration.html#a11ddd051208250c32dc4985abcafa86d">SameConfiguration&lt;OtherNodeType&gt;::value</a> is <code>true</code> if and only if OtherNodeType is the type of an <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> with the same dimensions as this node and whose ChildNodeType has the same configuration as this node's ChildNodeType.  <a href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1SameConfiguration.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1TopologyCopy1.html">TopologyCopy1</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1TopologyCopy2.html">TopologyCopy2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1TopologyDifference.html">TopologyDifference</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1TopologyIntersection.html">TopologyIntersection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1TopologyUnion.html">TopologyUnion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueAll.html">ValueAll</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueConverter.html">ValueConverter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueConverter.html#a50ef0e3811555bb11ebe96cb4c37022a">ValueConverter&lt;T&gt;::Type</a> is the type of an <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> having the same child hierarchy and dimensions as this node but a different value type, T.  <a href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueConverter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueOff.html">ValueOff</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueOn.html">ValueOn</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1VoxelizeActiveTiles.html">VoxelizeActiveTiles</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:add8e24322cfd0d1561ae0014fc6634e4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a> = _ChildNodeType</td></tr>
<tr class="separator:add8e24322cfd0d1561ae0014fc6634e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895c61b706c696dee8703fefa057cd8e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> = typename ChildNodeType::LeafNodeType</td></tr>
<tr class="separator:a895c61b706c696dee8703fefa057cd8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955a64733ac9d1edca761e573e0efc80"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> = typename ChildNodeType::ValueType</td></tr>
<tr class="separator:a955a64733ac9d1edca761e573e0efc80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac386aed578c229195776a00b6ba7bcfe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac386aed578c229195776a00b6ba7bcfe">BuildType</a> = typename ChildNodeType::BuildType</td></tr>
<tr class="separator:ac386aed578c229195776a00b6ba7bcfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bccf19ee074e170944b394221e62e7f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a2bccf19ee074e170944b394221e62e7f">UnionType</a> = <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1NodeUnion.html">NodeUnion</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a> &gt;</td></tr>
<tr class="separator:a2bccf19ee074e170944b394221e62e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18d90eb4c641fe81f2f17f7e2f7f1fda"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18d90eb4c641fe81f2f17f7e2f7f1fda">NodeMaskType</a> = <a class="el" href="classopenvdb_1_1v8__1_1_1util_1_1NodeMask.html">util::NodeMask</a>&lt; Log2Dim &gt;</td></tr>
<tr class="separator:a18d90eb4c641fe81f2f17f7e2f7f1fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a856425ed62a966846f6da3a794bfe9a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a856425ed62a966846f6da3a794bfe9a8">ChildOnIter</a> = <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildIter.html">ChildIter</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac919430bc16a7a1183a79efe490159d6">MaskOnIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildOn.html">ChildOn</a> &gt;</td></tr>
<tr class="separator:a856425ed62a966846f6da3a794bfe9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5eac0b6986ef0dfe4c246bf054c3054"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab5eac0b6986ef0dfe4c246bf054c3054">ChildOnCIter</a> = <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildIter.html">ChildIter</a>&lt; const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac919430bc16a7a1183a79efe490159d6">MaskOnIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildOn.html">ChildOn</a> &gt;</td></tr>
<tr class="separator:ab5eac0b6986ef0dfe4c246bf054c3054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc48cf2fefa05ebff4ada5ccd7dbc7eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abc48cf2fefa05ebff4ada5ccd7dbc7eb">ChildOffIter</a> = <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildOff.html">ChildOff</a> &gt;</td></tr>
<tr class="separator:abc48cf2fefa05ebff4ada5ccd7dbc7eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdccd1d5773efe94cd27c445cbebcb25"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abdccd1d5773efe94cd27c445cbebcb25">ChildOffCIter</a> = <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt; const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildOff.html">ChildOff</a> &gt;</td></tr>
<tr class="separator:abdccd1d5773efe94cd27c445cbebcb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace35dd5a583a8891d972fab967cf3d57"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ace35dd5a583a8891d972fab967cf3d57">ChildAllIter</a> = <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1DenseIter.html">DenseIter</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildAll.html">ChildAll</a> &gt;</td></tr>
<tr class="separator:ace35dd5a583a8891d972fab967cf3d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08445224256785ccda0b3c3f8d6ffa3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aa08445224256785ccda0b3c3f8d6ffa3">ChildAllCIter</a> = <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1DenseIter.html">DenseIter</a>&lt; const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildAll.html">ChildAll</a> &gt;</td></tr>
<tr class="separator:aa08445224256785ccda0b3c3f8d6ffa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a725a2857ea71d09356ca17c97745a2e3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a725a2857ea71d09356ca17c97745a2e3">ValueOnIter</a> = <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac919430bc16a7a1183a79efe490159d6">MaskOnIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueOn.html">ValueOn</a> &gt;</td></tr>
<tr class="separator:a725a2857ea71d09356ca17c97745a2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace79c80fb5419252ee75059be909cbfa"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ace79c80fb5419252ee75059be909cbfa">ValueOnCIter</a> = <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt; const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac919430bc16a7a1183a79efe490159d6">MaskOnIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueOn.html">ValueOn</a> &gt;</td></tr>
<tr class="separator:ace79c80fb5419252ee75059be909cbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7eb56d25d3f1a0e75e36d72ed820fcd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad7eb56d25d3f1a0e75e36d72ed820fcd">ValueOffIter</a> = <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueOff.html">ValueOff</a> &gt;</td></tr>
<tr class="separator:ad7eb56d25d3f1a0e75e36d72ed820fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a063d45da2bb80d7990d52c30dc0743"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0a063d45da2bb80d7990d52c30dc0743">ValueOffCIter</a> = <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt; const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueOff.html">ValueOff</a> &gt;</td></tr>
<tr class="separator:a0a063d45da2bb80d7990d52c30dc0743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e980796cc1df16ebbc17e4a0d534941"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0e980796cc1df16ebbc17e4a0d534941">ValueAllIter</a> = <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueAll.html">ValueAll</a> &gt;</td></tr>
<tr class="separator:a0e980796cc1df16ebbc17e4a0d534941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfa921c38831682ab9b5bfc0b2524eb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a4cfa921c38831682ab9b5bfc0b2524eb">ValueAllCIter</a> = <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt; const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueAll.html">ValueAll</a> &gt;</td></tr>
<tr class="separator:a4cfa921c38831682ab9b5bfc0b2524eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3c7d5a1827fefa3ff6cad83cb6a04998"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a3c7d5a1827fefa3ff6cad83cb6a04998">InternalNode</a> ()</td></tr>
<tr class="memdesc:a3c7d5a1827fefa3ff6cad83cb6a04998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#a3c7d5a1827fefa3ff6cad83cb6a04998">More...</a><br /></td></tr>
<tr class="separator:a3c7d5a1827fefa3ff6cad83cb6a04998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bc92d242649f28a8d9215cd99f968e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad1bc92d242649f28a8d9215cd99f968e">InternalNode</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;offValue)</td></tr>
<tr class="memdesc:ad1bc92d242649f28a8d9215cd99f968e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of an <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> with dense inactive tiles of the specified value.  <a href="#ad1bc92d242649f28a8d9215cd99f968e">More...</a><br /></td></tr>
<tr class="separator:ad1bc92d242649f28a8d9215cd99f968e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223e61ee2063b94cd0327c22bb2ebf20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a223e61ee2063b94cd0327c22bb2ebf20">InternalNode</a> (const Coord &amp;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a605928767da2cb90e6ad6b5021f49592">origin</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;fillValue, bool active=false)</td></tr>
<tr class="memdesc:a223e61ee2063b94cd0327c22bb2ebf20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> with dense tiles.  <a href="#a223e61ee2063b94cd0327c22bb2ebf20">More...</a><br /></td></tr>
<tr class="separator:a223e61ee2063b94cd0327c22bb2ebf20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c69f6e0dfc71e346694e3ef90e8708"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#af7c69f6e0dfc71e346694e3ef90e8708">InternalNode</a> (<a class="el" href="classopenvdb_1_1v8__1_1_1PartialCreate.html">PartialCreate</a>, const Coord &amp;, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;fillValue, bool active=false)</td></tr>
<tr class="separator:af7c69f6e0dfc71e346694e3ef90e8708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae345664c5a28b29a81286eb7419e293b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ae345664c5a28b29a81286eb7419e293b">InternalNode</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> &amp;)</td></tr>
<tr class="memdesc:ae345664c5a28b29a81286eb7419e293b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deep copy constructor.  <a href="#ae345664c5a28b29a81286eb7419e293b">More...</a><br /></td></tr>
<tr class="separator:ae345664c5a28b29a81286eb7419e293b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210d885537e470d3c48b4471ee3c0f50"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildNodeType &gt; </td></tr>
<tr class="memitem:a210d885537e470d3c48b4471ee3c0f50"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a210d885537e470d3c48b4471ee3c0f50">InternalNode</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, Log2Dim &gt; &amp;other)</td></tr>
<tr class="memdesc:a210d885537e470d3c48b4471ee3c0f50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value conversion copy constructor.  <a href="#a210d885537e470d3c48b4471ee3c0f50">More...</a><br /></td></tr>
<tr class="separator:a210d885537e470d3c48b4471ee3c0f50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce3601644287a8bb0a1361ea4795c8c"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildNodeType &gt; </td></tr>
<tr class="memitem:a6ce3601644287a8bb0a1361ea4795c8c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a6ce3601644287a8bb0a1361ea4795c8c">InternalNode</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, Log2Dim &gt; &amp;other, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;background, <a class="el" href="classopenvdb_1_1v8__1_1_1TopologyCopy.html">TopologyCopy</a>)</td></tr>
<tr class="memdesc:a6ce3601644287a8bb0a1361ea4795c8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topology copy constructor.  <a href="#a6ce3601644287a8bb0a1361ea4795c8c">More...</a><br /></td></tr>
<tr class="separator:a6ce3601644287a8bb0a1361ea4795c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301b2a28b08db3370ed667cac46992fd"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildNodeType &gt; </td></tr>
<tr class="memitem:a301b2a28b08db3370ed667cac46992fd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a301b2a28b08db3370ed667cac46992fd">InternalNode</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, Log2Dim &gt; &amp;other, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;offValue, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;onValue, <a class="el" href="classopenvdb_1_1v8__1_1_1TopologyCopy.html">TopologyCopy</a>)</td></tr>
<tr class="memdesc:a301b2a28b08db3370ed667cac46992fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Topology copy constructor.  <a href="#a301b2a28b08db3370ed667cac46992fd">More...</a><br /></td></tr>
<tr class="separator:a301b2a28b08db3370ed667cac46992fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ebfad50db33120e5f5827022c035166"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a3ebfad50db33120e5f5827022c035166">~InternalNode</a> ()</td></tr>
<tr class="separator:a3ebfad50db33120e5f5827022c035166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e9bf1256874f802e2dbbc7db56f8ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab5eac0b6986ef0dfe4c246bf054c3054">ChildOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a63e9bf1256874f802e2dbbc7db56f8ee">cbeginChildOn</a> () const </td></tr>
<tr class="separator:a63e9bf1256874f802e2dbbc7db56f8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8169dc13d3aad941b6490f27a4bbb839"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abdccd1d5773efe94cd27c445cbebcb25">ChildOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a8169dc13d3aad941b6490f27a4bbb839">cbeginChildOff</a> () const </td></tr>
<tr class="separator:a8169dc13d3aad941b6490f27a4bbb839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c7824607dbdc3c1165e0b0daea8bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aa08445224256785ccda0b3c3f8d6ffa3">ChildAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ae5c7824607dbdc3c1165e0b0daea8bcd">cbeginChildAll</a> () const </td></tr>
<tr class="separator:ae5c7824607dbdc3c1165e0b0daea8bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c7157dee0e08c357e6a3ed6415a00e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab5eac0b6986ef0dfe4c246bf054c3054">ChildOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a31c7157dee0e08c357e6a3ed6415a00e">beginChildOn</a> () const </td></tr>
<tr class="separator:a31c7157dee0e08c357e6a3ed6415a00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8438e994f130eacf9f40014a97514bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abdccd1d5773efe94cd27c445cbebcb25">ChildOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a8438e994f130eacf9f40014a97514bcd">beginChildOff</a> () const </td></tr>
<tr class="separator:a8438e994f130eacf9f40014a97514bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599e840b09098cf3437a3c4bd366ee79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aa08445224256785ccda0b3c3f8d6ffa3">ChildAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a599e840b09098cf3437a3c4bd366ee79">beginChildAll</a> () const </td></tr>
<tr class="separator:a599e840b09098cf3437a3c4bd366ee79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f712beff77da092dd726a59e1104cf0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a856425ed62a966846f6da3a794bfe9a8">ChildOnIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0f712beff77da092dd726a59e1104cf0">beginChildOn</a> ()</td></tr>
<tr class="separator:a0f712beff77da092dd726a59e1104cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845985fcf5013cc3fe15865b05b3abd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abc48cf2fefa05ebff4ada5ccd7dbc7eb">ChildOffIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a845985fcf5013cc3fe15865b05b3abd5">beginChildOff</a> ()</td></tr>
<tr class="separator:a845985fcf5013cc3fe15865b05b3abd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7000148c6f1dc8bfbb0139a3606e188e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ace35dd5a583a8891d972fab967cf3d57">ChildAllIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a7000148c6f1dc8bfbb0139a3606e188e">beginChildAll</a> ()</td></tr>
<tr class="separator:a7000148c6f1dc8bfbb0139a3606e188e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad554801c644ee82931281a11f801bf5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ace79c80fb5419252ee75059be909cbfa">ValueOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad554801c644ee82931281a11f801bf5c">cbeginValueOn</a> () const </td></tr>
<tr class="separator:ad554801c644ee82931281a11f801bf5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16c1191cb1a539a7cc0cdee5803d860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0a063d45da2bb80d7990d52c30dc0743">ValueOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ae16c1191cb1a539a7cc0cdee5803d860">cbeginValueOff</a> () const </td></tr>
<tr class="separator:ae16c1191cb1a539a7cc0cdee5803d860"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b296755b1634e77e5fff9c4c48ea3c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a4cfa921c38831682ab9b5bfc0b2524eb">ValueAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a8b296755b1634e77e5fff9c4c48ea3c8">cbeginValueAll</a> () const </td></tr>
<tr class="separator:a8b296755b1634e77e5fff9c4c48ea3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f82a16370621f762a097f27122e51db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ace79c80fb5419252ee75059be909cbfa">ValueOnCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0f82a16370621f762a097f27122e51db">beginValueOn</a> () const </td></tr>
<tr class="separator:a0f82a16370621f762a097f27122e51db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17282c62bdf7cdd25be3b773b39907b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0a063d45da2bb80d7990d52c30dc0743">ValueOffCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a17282c62bdf7cdd25be3b773b39907b0">beginValueOff</a> () const </td></tr>
<tr class="separator:a17282c62bdf7cdd25be3b773b39907b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ec03c783bc71e824837c826dd6531c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a4cfa921c38831682ab9b5bfc0b2524eb">ValueAllCIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18ec03c783bc71e824837c826dd6531c">beginValueAll</a> () const </td></tr>
<tr class="separator:a18ec03c783bc71e824837c826dd6531c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8568cb11eacfedf042fa1eda680a45"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a725a2857ea71d09356ca17c97745a2e3">ValueOnIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a7b8568cb11eacfedf042fa1eda680a45">beginValueOn</a> ()</td></tr>
<tr class="separator:a7b8568cb11eacfedf042fa1eda680a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad555f92c70739496805fb480c3b38f85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad7eb56d25d3f1a0e75e36d72ed820fcd">ValueOffIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad555f92c70739496805fb480c3b38f85">beginValueOff</a> ()</td></tr>
<tr class="separator:ad555f92c70739496805fb480c3b38f85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf6fa279da1f6839a3ca381828220df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0e980796cc1df16ebbc17e4a0d534941">ValueAllIter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#afdf6fa279da1f6839a3ca381828220df">beginValueAll</a> ()</td></tr>
<tr class="separator:afdf6fa279da1f6839a3ca381828220df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79eb1621afd1bcf8ca45386b04a839bb"><td class="memItemLeft" align="right" valign="top">Coord&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a79eb1621afd1bcf8ca45386b04a839bb">offsetToGlobalCoord</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> n) const </td></tr>
<tr class="memdesc:a79eb1621afd1bcf8ca45386b04a839bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the global coordinates for a linear table offset.  <a href="#a79eb1621afd1bcf8ca45386b04a839bb">More...</a><br /></td></tr>
<tr class="separator:a79eb1621afd1bcf8ca45386b04a839bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605928767da2cb90e6ad6b5021f49592"><td class="memItemLeft" align="right" valign="top">const Coord &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a605928767da2cb90e6ad6b5021f49592">origin</a> () const </td></tr>
<tr class="memdesc:a605928767da2cb90e6ad6b5021f49592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the grid index coordinates of this node's local origin.  <a href="#a605928767da2cb90e6ad6b5021f49592">More...</a><br /></td></tr>
<tr class="separator:a605928767da2cb90e6ad6b5021f49592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a594b25da67e57a3b0f252ce8417bb5e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a594b25da67e57a3b0f252ce8417bb5e1">setOrigin</a> (const Coord &amp;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a605928767da2cb90e6ad6b5021f49592">origin</a>)</td></tr>
<tr class="memdesc:a594b25da67e57a3b0f252ce8417bb5e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the grid index coordinates of this node's local origin.  <a href="#a594b25da67e57a3b0f252ce8417bb5e1">More...</a><br /></td></tr>
<tr class="separator:a594b25da67e57a3b0f252ce8417bb5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0667d468064aa044670a06a84b9c48ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0667d468064aa044670a06a84b9c48ed">leafCount</a> () const </td></tr>
<tr class="separator:a0667d468064aa044670a06a84b9c48ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ac16944cc943e8a524cc80824182ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aa4ac16944cc943e8a524cc80824182ef">nodeCount</a> (std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> &gt; &amp;vec) const </td></tr>
<tr class="separator:aa4ac16944cc943e8a524cc80824182ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d22ef34f6459bcffc00f6eb8f747b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad8d22ef34f6459bcffc00f6eb8f747b9">nonLeafCount</a> () const </td></tr>
<tr class="separator:ad8d22ef34f6459bcffc00f6eb8f747b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf8732f8cd6e4c4dc8ae7b338343d082"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aaf8732f8cd6e4c4dc8ae7b338343d082">childCount</a> () const </td></tr>
<tr class="separator:aaf8732f8cd6e4c4dc8ae7b338343d082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41639979a334066f76633037c605a77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ae41639979a334066f76633037c605a77">onVoxelCount</a> () const </td></tr>
<tr class="separator:ae41639979a334066f76633037c605a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22486b1420a67aaf492e7e4ca2ca6fb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a22486b1420a67aaf492e7e4ca2ca6fb6">offVoxelCount</a> () const </td></tr>
<tr class="separator:a22486b1420a67aaf492e7e4ca2ca6fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe2ccd641ba4842769eb649c856d05b9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abe2ccd641ba4842769eb649c856d05b9">onLeafVoxelCount</a> () const </td></tr>
<tr class="separator:abe2ccd641ba4842769eb649c856d05b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ac72edbf61ebf466b06f6bb4f1ffc6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a78ac72edbf61ebf466b06f6bb4f1ffc6">offLeafVoxelCount</a> () const </td></tr>
<tr class="separator:a78ac72edbf61ebf466b06f6bb4f1ffc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c7f5922acf9662196a81ec4470aedd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad8c7f5922acf9662196a81ec4470aedd">onTileCount</a> () const </td></tr>
<tr class="separator:ad8c7f5922acf9662196a81ec4470aedd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8443805eb98462d37d9c3f7b549ede0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a8443805eb98462d37d9c3f7b549ede0f">memUsage</a> () const </td></tr>
<tr class="memdesc:a8443805eb98462d37d9c3f7b549ede0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total amount of memory in bytes occupied by this node and its children.  <a href="#a8443805eb98462d37d9c3f7b549ede0f">More...</a><br /></td></tr>
<tr class="separator:a8443805eb98462d37d9c3f7b549ede0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f72230ae8ade2c0a5e712708c36fa6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aa4f72230ae8ade2c0a5e712708c36fa6">evalActiveBoundingBox</a> (CoordBBox &amp;bbox, bool visitVoxels=true) const </td></tr>
<tr class="memdesc:aa4f72230ae8ade2c0a5e712708c36fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the specified bounding box so that it includes the active tiles of this internal node as well as all the active values in its child nodes. If visitVoxels is false LeafNodes will be approximated as dense, i.e. with all voxels active. Else the individual active voxels are visited to produce a tight bbox.  <a href="#aa4f72230ae8ade2c0a5e712708c36fa6">More...</a><br /></td></tr>
<tr class="separator:aa4f72230ae8ade2c0a5e712708c36fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6051e4ba75b59a01e4d0e91ba9786070"><td class="memItemLeft" align="right" valign="top">CoordBBox&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a6051e4ba75b59a01e4d0e91ba9786070">getNodeBoundingBox</a> () const </td></tr>
<tr class="memdesc:a6051e4ba75b59a01e4d0e91ba9786070"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the bounding box of this node, i.e., the full index space spanned by the node regardless of its content.  <a href="#a6051e4ba75b59a01e4d0e91ba9786070">More...</a><br /></td></tr>
<tr class="separator:a6051e4ba75b59a01e4d0e91ba9786070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a479432127ee77145cc19d6a2d1590821"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a479432127ee77145cc19d6a2d1590821">isEmpty</a> () const </td></tr>
<tr class="separator:a479432127ee77145cc19d6a2d1590821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbde11b027a056fd5b7b196a1173182c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#afbde11b027a056fd5b7b196a1173182c">isConstant</a> (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;firstValue, bool &amp;state, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;tolerance=<a class="el" href="namespaceopenvdb_1_1v8__1.html#a9bc9fb4000c5e821a917537e91e21eda">zeroVal</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &gt;()) const </td></tr>
<tr class="separator:afbde11b027a056fd5b7b196a1173182c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27932bcbc2413401194bfa313a57dbf9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a27932bcbc2413401194bfa313a57dbf9">isConstant</a> (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;minValue, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;maxValue, bool &amp;state, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;tolerance=<a class="el" href="namespaceopenvdb_1_1v8__1.html#a9bc9fb4000c5e821a917537e91e21eda">zeroVal</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &gt;()) const </td></tr>
<tr class="separator:a27932bcbc2413401194bfa313a57dbf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b7e3231fdb2ff6ee1fb822b2b921eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a44b7e3231fdb2ff6ee1fb822b2b921eb">isInactive</a> () const </td></tr>
<tr class="memdesc:a44b7e3231fdb2ff6ee1fb822b2b921eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if this node has no children and only contains inactive values.  <a href="#a44b7e3231fdb2ff6ee1fb822b2b921eb">More...</a><br /></td></tr>
<tr class="separator:a44b7e3231fdb2ff6ee1fb822b2b921eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc695b4cc2c115afbdb51d4997b69747"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#afc695b4cc2c115afbdb51d4997b69747">isValueOn</a> (const Coord &amp;xyz) const </td></tr>
<tr class="memdesc:afc695b4cc2c115afbdb51d4997b69747"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the voxel at the given coordinates is active.  <a href="#afc695b4cc2c115afbdb51d4997b69747">More...</a><br /></td></tr>
<tr class="separator:afc695b4cc2c115afbdb51d4997b69747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab471165041eb1c9de3c9beb14d1ca7b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab471165041eb1c9de3c9beb14d1ca7b7">isValueOn</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> offset) const </td></tr>
<tr class="memdesc:ab471165041eb1c9de3c9beb14d1ca7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the voxel at the given offset is active.  <a href="#ab471165041eb1c9de3c9beb14d1ca7b7">More...</a><br /></td></tr>
<tr class="separator:ab471165041eb1c9de3c9beb14d1ca7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e1a133192d9d344c482d4aa83f6da33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a1e1a133192d9d344c482d4aa83f6da33">hasActiveTiles</a> () const </td></tr>
<tr class="memdesc:a1e1a133192d9d344c482d4aa83f6da33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if this node or any of its child nodes have any active tiles.  <a href="#a1e1a133192d9d344c482d4aa83f6da33">More...</a><br /></td></tr>
<tr class="separator:a1e1a133192d9d344c482d4aa83f6da33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce49c1d01fb40115f7253b65dd98a38"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a8ce49c1d01fb40115f7253b65dd98a38">getValue</a> (const Coord &amp;xyz) const </td></tr>
<tr class="separator:a8ce49c1d01fb40115f7253b65dd98a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0535ed999c1364a5bc5f31e668e5ef7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0535ed999c1364a5bc5f31e668e5ef7c">probeValue</a> (const Coord &amp;xyz, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value) const </td></tr>
<tr class="separator:a0535ed999c1364a5bc5f31e668e5ef7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619e96c166b4b5e8528f70d03318b940"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a619e96c166b4b5e8528f70d03318b940">getValueLevel</a> (const Coord &amp;xyz) const </td></tr>
<tr class="memdesc:a619e96c166b4b5e8528f70d03318b940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the level of the tree (0 = leaf) at which the value at the given coordinates resides.  <a href="#a619e96c166b4b5e8528f70d03318b940">More...</a><br /></td></tr>
<tr class="separator:a619e96c166b4b5e8528f70d03318b940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b11672e5be2e242c1748af8985e6cdd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a5b11672e5be2e242c1748af8985e6cdd">getFirstValue</a> () const </td></tr>
<tr class="memdesc:a5b11672e5be2e242c1748af8985e6cdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the first entry in this node's table is a tile, return the tile's value. Otherwise, return the result of calling <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a5b11672e5be2e242c1748af8985e6cdd" title="If the first entry in this node&#39;s table is a tile, return the tile&#39;s value. Otherwise, return the result of calling getFirstValue() on the child. ">getFirstValue()</a> on the child.  <a href="#a5b11672e5be2e242c1748af8985e6cdd">More...</a><br /></td></tr>
<tr class="separator:a5b11672e5be2e242c1748af8985e6cdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1278796f9dc4866a9a9f222d8f448c90"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a1278796f9dc4866a9a9f222d8f448c90">getLastValue</a> () const </td></tr>
<tr class="memdesc:a1278796f9dc4866a9a9f222d8f448c90"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the last entry in this node's table is a tile, return the tile's value. Otherwise, return the result of calling <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a1278796f9dc4866a9a9f222d8f448c90" title="If the last entry in this node&#39;s table is a tile, return the tile&#39;s value. Otherwise, return the result of calling getLastValue() on the child. ">getLastValue()</a> on the child.  <a href="#a1278796f9dc4866a9a9f222d8f448c90">More...</a><br /></td></tr>
<tr class="separator:a1278796f9dc4866a9a9f222d8f448c90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3e82eb582914ac6f31f32fea77292f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a7b3e82eb582914ac6f31f32fea77292f">setActiveState</a> (const Coord &amp;xyz, bool on)</td></tr>
<tr class="memdesc:a7b3e82eb582914ac6f31f32fea77292f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the active state of the voxel at the given coordinates but don't change its value.  <a href="#a7b3e82eb582914ac6f31f32fea77292f">More...</a><br /></td></tr>
<tr class="separator:a7b3e82eb582914ac6f31f32fea77292f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ff695beda11ed9ef625a28ce8a5faf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a63ff695beda11ed9ef625a28ce8a5faf">setValueOnly</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a63ff695beda11ed9ef625a28ce8a5faf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates but don't change its active state.  <a href="#a63ff695beda11ed9ef625a28ce8a5faf">More...</a><br /></td></tr>
<tr class="separator:a63ff695beda11ed9ef625a28ce8a5faf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6cf12f28a771762327ba1578bc48e9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad6cf12f28a771762327ba1578bc48e9c">setValueOn</a> (const Coord &amp;xyz)</td></tr>
<tr class="memdesc:ad6cf12f28a771762327ba1578bc48e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the voxel at the given coordinates as active but don't change its value.  <a href="#ad6cf12f28a771762327ba1578bc48e9c">More...</a><br /></td></tr>
<tr class="separator:ad6cf12f28a771762327ba1578bc48e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95653046c85afb743075f139a26df9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ae95653046c85afb743075f139a26df9d">setValueOn</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:ae95653046c85afb743075f139a26df9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates and mark the voxel as active.  <a href="#ae95653046c85afb743075f139a26df9d">More...</a><br /></td></tr>
<tr class="separator:ae95653046c85afb743075f139a26df9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a91d631df8f64f84a0aad7436cb11f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a8a91d631df8f64f84a0aad7436cb11f3">setValueOff</a> (const Coord &amp;xyz)</td></tr>
<tr class="memdesc:a8a91d631df8f64f84a0aad7436cb11f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the voxel at the given coordinates as inactive but don't change its value.  <a href="#a8a91d631df8f64f84a0aad7436cb11f3">More...</a><br /></td></tr>
<tr class="separator:a8a91d631df8f64f84a0aad7436cb11f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73a6e7c85d37e7d677eddc3cce8aa11b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a73a6e7c85d37e7d677eddc3cce8aa11b">setValueOff</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value)</td></tr>
<tr class="memdesc:a73a6e7c85d37e7d677eddc3cce8aa11b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the value of the voxel at the given coordinates and mark the voxel as inactive.  <a href="#a73a6e7c85d37e7d677eddc3cce8aa11b">More...</a><br /></td></tr>
<tr class="separator:a73a6e7c85d37e7d677eddc3cce8aa11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6954a428c0ef18a03431f251f4e7d24"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp &gt; </td></tr>
<tr class="memitem:aa6954a428c0ef18a03431f251f4e7d24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aa6954a428c0ef18a03431f251f4e7d24">modifyValue</a> (const Coord &amp;xyz, const ModifyOp &amp;op)</td></tr>
<tr class="memdesc:aa6954a428c0ef18a03431f251f4e7d24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to the value of the voxel at the given coordinates and mark the voxel as active.  <a href="#aa6954a428c0ef18a03431f251f4e7d24">More...</a><br /></td></tr>
<tr class="separator:aa6954a428c0ef18a03431f251f4e7d24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp &gt; </td></tr>
<tr class="memitem:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a5cb69af7e17c3a9a6d6dc360c878448c">modifyValueAndActiveState</a> (const Coord &amp;xyz, const ModifyOp &amp;op)</td></tr>
<tr class="memdesc:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to the voxel at the given coordinates.  <a href="#a5cb69af7e17c3a9a6d6dc360c878448c">More...</a><br /></td></tr>
<tr class="separator:a5cb69af7e17c3a9a6d6dc360c878448c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54f367109416043c0ce7d175be04c21"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:ab54f367109416043c0ce7d175be04c21"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab54f367109416043c0ce7d175be04c21">getValueAndCache</a> (const Coord &amp;xyz, AccessorT &amp;) const </td></tr>
<tr class="separator:ab54f367109416043c0ce7d175be04c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b19bb2b11319fb6eaab50aada9bff01"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a7b19bb2b11319fb6eaab50aada9bff01"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a7b19bb2b11319fb6eaab50aada9bff01">isValueOnAndCache</a> (const Coord &amp;xyz, AccessorT &amp;) const </td></tr>
<tr class="separator:a7b19bb2b11319fb6eaab50aada9bff01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b75fc2aa129aa05ae677971dc1972e"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a01b75fc2aa129aa05ae677971dc1972e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a01b75fc2aa129aa05ae677971dc1972e">setValueAndCache</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value, AccessorT &amp;)</td></tr>
<tr class="separator:a01b75fc2aa129aa05ae677971dc1972e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cefbe46cc3180e5394a2f4fc775bfe8"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a5cefbe46cc3180e5394a2f4fc775bfe8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a5cefbe46cc3180e5394a2f4fc775bfe8">setValueOnlyAndCache</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value, AccessorT &amp;)</td></tr>
<tr class="separator:a5cefbe46cc3180e5394a2f4fc775bfe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bed5c7c0d76cacfb514d9744f754402"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp , typename AccessorT &gt; </td></tr>
<tr class="memitem:a7bed5c7c0d76cacfb514d9744f754402"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a7bed5c7c0d76cacfb514d9744f754402">modifyValueAndCache</a> (const Coord &amp;xyz, const ModifyOp &amp;op, AccessorT &amp;)</td></tr>
<tr class="memdesc:a7bed5c7c0d76cacfb514d9744f754402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a functor to the value of the voxel at the given coordinates and mark the voxel as active. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel.  <a href="#a7bed5c7c0d76cacfb514d9744f754402">More...</a><br /></td></tr>
<tr class="separator:a7bed5c7c0d76cacfb514d9744f754402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af057648803b9073ce1703dbf061e0d1f"><td class="memTemplParams" colspan="2">template&lt;typename ModifyOp , typename AccessorT &gt; </td></tr>
<tr class="memitem:af057648803b9073ce1703dbf061e0d1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#af057648803b9073ce1703dbf061e0d1f">modifyValueAndActiveStateAndCache</a> (const Coord &amp;xyz, const ModifyOp &amp;op, AccessorT &amp;)</td></tr>
<tr class="separator:af057648803b9073ce1703dbf061e0d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0c65991a0b3c81933cd944d8fc4267"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a6c0c65991a0b3c81933cd944d8fc4267"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a6c0c65991a0b3c81933cd944d8fc4267">setValueOffAndCache</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value, AccessorT &amp;)</td></tr>
<tr class="separator:a6c0c65991a0b3c81933cd944d8fc4267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04db06362bfb5ec0ed6212469eb4ff3"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:ac04db06362bfb5ec0ed6212469eb4ff3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac04db06362bfb5ec0ed6212469eb4ff3">setActiveStateAndCache</a> (const Coord &amp;xyz, bool on, AccessorT &amp;)</td></tr>
<tr class="separator:ac04db06362bfb5ec0ed6212469eb4ff3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab682876d96e5d4b4c7bd90ef19638d7c"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:ab682876d96e5d4b4c7bd90ef19638d7c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab682876d96e5d4b4c7bd90ef19638d7c">probeValueAndCache</a> (const Coord &amp;xyz, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value, AccessorT &amp;) const </td></tr>
<tr class="separator:ab682876d96e5d4b4c7bd90ef19638d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6b11a975fc78c2ea13585256b5b720"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a7d6b11a975fc78c2ea13585256b5b720"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a7d6b11a975fc78c2ea13585256b5b720">getValueLevelAndCache</a> (const Coord &amp;xyz, AccessorT &amp;) const </td></tr>
<tr class="memdesc:a7d6b11a975fc78c2ea13585256b5b720"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the level of the tree (0 = leaf) at which the value at the given coordinates resides.  <a href="#a7d6b11a975fc78c2ea13585256b5b720">More...</a><br /></td></tr>
<tr class="separator:a7d6b11a975fc78c2ea13585256b5b720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac155d78b56e45b4d18aad6b18d957d5a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac155d78b56e45b4d18aad6b18d957d5a">setValuesOn</a> ()</td></tr>
<tr class="memdesc:ac155d78b56e45b4d18aad6b18d957d5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark all values (both tiles and voxels) as active.  <a href="#ac155d78b56e45b4d18aad6b18d957d5a">More...</a><br /></td></tr>
<tr class="separator:ac155d78b56e45b4d18aad6b18d957d5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d547afeb73396804509f85ec7043e7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a72d547afeb73396804509f85ec7043e7">writeTopology</a> (std::ostream &amp;, bool toHalf=false) const </td></tr>
<tr class="separator:a72d547afeb73396804509f85ec7043e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdf345c3364a34a9b0e3ba2883960e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abcdf345c3364a34a9b0e3ba2883960e2">readTopology</a> (std::istream &amp;, bool fromHalf=false)</td></tr>
<tr class="separator:abcdf345c3364a34a9b0e3ba2883960e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1517c3788b6d11d5e07a577dd38d7c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a1517c3788b6d11d5e07a577dd38d7c43">writeBuffers</a> (std::ostream &amp;, bool toHalf=false) const </td></tr>
<tr class="separator:a1517c3788b6d11d5e07a577dd38d7c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef270a4e4900e5e0bd24e6664d6a8a82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aef270a4e4900e5e0bd24e6664d6a8a82">readBuffers</a> (std::istream &amp;, bool fromHalf=false)</td></tr>
<tr class="separator:aef270a4e4900e5e0bd24e6664d6a8a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d516efdbb242e00e7c77ae85cc426b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a9d516efdbb242e00e7c77ae85cc426b6">readBuffers</a> (std::istream &amp;, const CoordBBox &amp;, bool fromHalf=false)</td></tr>
<tr class="separator:a9d516efdbb242e00e7c77ae85cc426b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcdb1512395327f8236a4f4a4d4ff648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abcdb1512395327f8236a4f4a4d4ff648">negate</a> ()</td></tr>
<tr class="memdesc:abcdb1512395327f8236a4f4a4d4ff648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the sign of all the values represented in this node and its child nodes.  <a href="#abcdb1512395327f8236a4f4a4d4ff648">More...</a><br /></td></tr>
<tr class="separator:abcdb1512395327f8236a4f4a4d4ff648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bd60c87fb75e3bb7a9b5099f3a4bdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a69bd60c87fb75e3bb7a9b5099f3a4bdf">fill</a> (const CoordBBox &amp;bbox, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value, bool active=true)</td></tr>
<tr class="memdesc:a69bd60c87fb75e3bb7a9b5099f3a4bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels within a given axis-aligned box to a constant value.  <a href="#a69bd60c87fb75e3bb7a9b5099f3a4bdf">More...</a><br /></td></tr>
<tr class="separator:a69bd60c87fb75e3bb7a9b5099f3a4bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb399cd065108e53e7b65612e74372a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abb399cd065108e53e7b65612e74372a5">denseFill</a> (const CoordBBox &amp;bbox, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value, bool active=true)</td></tr>
<tr class="memdesc:abb399cd065108e53e7b65612e74372a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels within a given axis-aligned box to a constant value and ensure that those voxels are all represented at the leaf level.  <a href="#abb399cd065108e53e7b65612e74372a5">More...</a><br /></td></tr>
<tr class="separator:abb399cd065108e53e7b65612e74372a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39a2211a02fb606e611d3ff5bbd6f50c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a39a2211a02fb606e611d3ff5bbd6f50c">voxelizeActiveTiles</a> (bool threaded=true)</td></tr>
<tr class="memdesc:a39a2211a02fb606e611d3ff5bbd6f50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Densify active tiles, i.e., replace them with leaf-level active voxels.  <a href="#a39a2211a02fb606e611d3ff5bbd6f50c">More...</a><br /></td></tr>
<tr class="separator:a39a2211a02fb606e611d3ff5bbd6f50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb6357bae687189b953c677911834ea"><td class="memTemplParams" colspan="2">template&lt;typename DenseT &gt; </td></tr>
<tr class="memitem:addb6357bae687189b953c677911834ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#addb6357bae687189b953c677911834ea">copyToDense</a> (const CoordBBox &amp;bbox, DenseT &amp;dense) const </td></tr>
<tr class="memdesc:addb6357bae687189b953c677911834ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy into a dense grid the values of the voxels that lie within a given bounding box.  <a href="#addb6357bae687189b953c677911834ea">More...</a><br /></td></tr>
<tr class="separator:addb6357bae687189b953c677911834ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0678918b353a7fa416685a3a5ba6c3fb"><td class="memTemplParams" colspan="2">template&lt;MergePolicy Policy&gt; </td></tr>
<tr class="memitem:a0678918b353a7fa416685a3a5ba6c3fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0678918b353a7fa416685a3a5ba6c3fb">merge</a> (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> &amp;other, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;background, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;otherBackground)</td></tr>
<tr class="memdesc:a0678918b353a7fa416685a3a5ba6c3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Efficiently merge another tree into this tree using one of several schemes.  <a href="#a0678918b353a7fa416685a3a5ba6c3fb">More...</a><br /></td></tr>
<tr class="separator:a0678918b353a7fa416685a3a5ba6c3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4119e466f0aaba9e53ef8b8d97af8a18"><td class="memTemplParams" colspan="2">template&lt;MergePolicy Policy&gt; </td></tr>
<tr class="memitem:a4119e466f0aaba9e53ef8b8d97af8a18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a4119e466f0aaba9e53ef8b8d97af8a18">merge</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;tileValue, bool tileActive)</td></tr>
<tr class="memdesc:a4119e466f0aaba9e53ef8b8d97af8a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge, using one of several schemes, this node (and its descendants) with a tile of the same dimensions and the given value and active state.  <a href="#a4119e466f0aaba9e53ef8b8d97af8a18">More...</a><br /></td></tr>
<tr class="separator:a4119e466f0aaba9e53ef8b8d97af8a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81ae377eb1c0cb00c077759d645fd7e4"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildNodeType &gt; </td></tr>
<tr class="memitem:a81ae377eb1c0cb00c077759d645fd7e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a81ae377eb1c0cb00c077759d645fd7e4">topologyUnion</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, Log2Dim &gt; &amp;other, const bool preserveTiles=false)</td></tr>
<tr class="memdesc:a81ae377eb1c0cb00c077759d645fd7e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union this branch's set of active values with the other branch's active values. The value type of the other branch can be different.  <a href="#a81ae377eb1c0cb00c077759d645fd7e4">More...</a><br /></td></tr>
<tr class="separator:a81ae377eb1c0cb00c077759d645fd7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2973e4d0d6266e3e42f1457262164347"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildNodeType &gt; </td></tr>
<tr class="memitem:a2973e4d0d6266e3e42f1457262164347"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a2973e4d0d6266e3e42f1457262164347">topologyIntersection</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, Log2Dim &gt; &amp;other, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;background)</td></tr>
<tr class="memdesc:a2973e4d0d6266e3e42f1457262164347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Intersects this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different.  <a href="#a2973e4d0d6266e3e42f1457262164347">More...</a><br /></td></tr>
<tr class="separator:a2973e4d0d6266e3e42f1457262164347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c47237feeecc609582460c08dbb242"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildNodeType &gt; </td></tr>
<tr class="memitem:a77c47237feeecc609582460c08dbb242"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a77c47237feeecc609582460c08dbb242">topologyDifference</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, Log2Dim &gt; &amp;other, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;background)</td></tr>
<tr class="memdesc:a77c47237feeecc609582460c08dbb242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Difference this node's set of active values with the active values of the other node, whose <code>ValueType</code> may be different. So a resulting voxel will be active only if the original voxel is active in this node and inactive in the other node.  <a href="#a77c47237feeecc609582460c08dbb242">More...</a><br /></td></tr>
<tr class="separator:a77c47237feeecc609582460c08dbb242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ee6db19642244188d2fa4db7df1225"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp &gt; </td></tr>
<tr class="memitem:ae2ee6db19642244188d2fa4db7df1225"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ae2ee6db19642244188d2fa4db7df1225">combine</a> (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> &amp;other, CombineOp &amp;)</td></tr>
<tr class="separator:ae2ee6db19642244188d2fa4db7df1225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff253b22319635ebad8bfcca2719003a"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp &gt; </td></tr>
<tr class="memitem:aff253b22319635ebad8bfcca2719003a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aff253b22319635ebad8bfcca2719003a">combine</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value, bool valueIsActive, CombineOp &amp;)</td></tr>
<tr class="separator:aff253b22319635ebad8bfcca2719003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d4331edaf20f7ae003e5cbf79349bd1"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp , typename OtherNodeType &gt; </td></tr>
<tr class="memitem:a5d4331edaf20f7ae003e5cbf79349bd1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a5d4331edaf20f7ae003e5cbf79349bd1">combine2</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> &amp;other0, const OtherNodeType &amp;other1, CombineOp &amp;)</td></tr>
<tr class="separator:a5d4331edaf20f7ae003e5cbf79349bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58de46634dd65d1fe2e2086accaa9b2d"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp , typename OtherNodeType &gt; </td></tr>
<tr class="memitem:a58de46634dd65d1fe2e2086accaa9b2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a58de46634dd65d1fe2e2086accaa9b2d">combine2</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value, const OtherNodeType &amp;other, bool valIsActive, CombineOp &amp;)</td></tr>
<tr class="separator:a58de46634dd65d1fe2e2086accaa9b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551c0e1b0cbb5ae00eee28bacc8f485a"><td class="memTemplParams" colspan="2">template&lt;typename CombineOp , typename OtherValueType &gt; </td></tr>
<tr class="memitem:a551c0e1b0cbb5ae00eee28bacc8f485a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a551c0e1b0cbb5ae00eee28bacc8f485a">combine2</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> &amp;other, const OtherValueType &amp;, bool valIsActive, CombineOp &amp;)</td></tr>
<tr class="separator:a551c0e1b0cbb5ae00eee28bacc8f485a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973ced84fe7b684d6be0acb5cef74c33"><td class="memTemplParams" colspan="2">template&lt;typename BBoxOp &gt; </td></tr>
<tr class="memitem:a973ced84fe7b684d6be0acb5cef74c33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a973ced84fe7b684d6be0acb5cef74c33">visitActiveBBox</a> (BBoxOp &amp;) const </td></tr>
<tr class="memdesc:a973ced84fe7b684d6be0acb5cef74c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the templated functor BBoxOp with bounding box information for all active tiles and leaf nodes in this node. An additional level argument is provided for each callback.  <a href="#a973ced84fe7b684d6be0acb5cef74c33">More...</a><br /></td></tr>
<tr class="separator:a973ced84fe7b684d6be0acb5cef74c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028a58e937882a91e9c1470fb6e73b42"><td class="memTemplParams" colspan="2">template&lt;typename VisitorOp &gt; </td></tr>
<tr class="memitem:a028a58e937882a91e9c1470fb6e73b42"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a028a58e937882a91e9c1470fb6e73b42">visit</a> (VisitorOp &amp;)</td></tr>
<tr class="separator:a028a58e937882a91e9c1470fb6e73b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6e62589958cedae5c2cd4b356f6ba7a"><td class="memTemplParams" colspan="2">template&lt;typename VisitorOp &gt; </td></tr>
<tr class="memitem:ac6e62589958cedae5c2cd4b356f6ba7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac6e62589958cedae5c2cd4b356f6ba7a">visit</a> (VisitorOp &amp;) const </td></tr>
<tr class="separator:ac6e62589958cedae5c2cd4b356f6ba7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa68756dbd8a216cdc248d4e828927ee"><td class="memTemplParams" colspan="2">template&lt;typename OtherNodeType , typename VisitorOp &gt; </td></tr>
<tr class="memitem:afa68756dbd8a216cdc248d4e828927ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#afa68756dbd8a216cdc248d4e828927ee">visit2Node</a> (OtherNodeType &amp;other, VisitorOp &amp;)</td></tr>
<tr class="separator:afa68756dbd8a216cdc248d4e828927ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2891ea5e9fa708cc8c72bfeddb24eaf4"><td class="memTemplParams" colspan="2">template&lt;typename OtherNodeType , typename VisitorOp &gt; </td></tr>
<tr class="memitem:a2891ea5e9fa708cc8c72bfeddb24eaf4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a2891ea5e9fa708cc8c72bfeddb24eaf4">visit2Node</a> (OtherNodeType &amp;other, VisitorOp &amp;) const </td></tr>
<tr class="separator:a2891ea5e9fa708cc8c72bfeddb24eaf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3595aa225add4df3db17545b9250cd6d"><td class="memTemplParams" colspan="2">template&lt;typename IterT , typename VisitorOp &gt; </td></tr>
<tr class="memitem:a3595aa225add4df3db17545b9250cd6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a3595aa225add4df3db17545b9250cd6d">visit2</a> (IterT &amp;otherIter, VisitorOp &amp;, bool otherIsLHS=false)</td></tr>
<tr class="separator:a3595aa225add4df3db17545b9250cd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7de0cadde4e5ded9ae2fff73126718d7"><td class="memTemplParams" colspan="2">template&lt;typename IterT , typename VisitorOp &gt; </td></tr>
<tr class="memitem:a7de0cadde4e5ded9ae2fff73126718d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a7de0cadde4e5ded9ae2fff73126718d7">visit2</a> (IterT &amp;otherIter, VisitorOp &amp;, bool otherIsLHS=false) const </td></tr>
<tr class="separator:a7de0cadde4e5ded9ae2fff73126718d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f3646d9977051fa33eb17095e736e84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a6f3646d9977051fa33eb17095e736e84">clip</a> (const CoordBBox &amp;, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;background)</td></tr>
<tr class="memdesc:a6f3646d9977051fa33eb17095e736e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all voxels that lie outside the given axis-aligned box to the background.  <a href="#a6f3646d9977051fa33eb17095e736e84">More...</a><br /></td></tr>
<tr class="separator:a6f3646d9977051fa33eb17095e736e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462c7056adc55d8da2cc5828934ff859"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a462c7056adc55d8da2cc5828934ff859">prune</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;tolerance=<a class="el" href="namespaceopenvdb_1_1v8__1.html#a9bc9fb4000c5e821a917537e91e21eda">zeroVal</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &gt;())</td></tr>
<tr class="memdesc:a462c7056adc55d8da2cc5828934ff859"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the same (optionally to within a tolerance) and have the same active state.  <a href="#a462c7056adc55d8da2cc5828934ff859">More...</a><br /></td></tr>
<tr class="separator:a462c7056adc55d8da2cc5828934ff859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20c22e9a994a30c9640cbe1ec982bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a6c20c22e9a994a30c9640cbe1ec982bc">addLeaf</a> (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> *leaf)</td></tr>
<tr class="memdesc:a6c20c22e9a994a30c9640cbe1ec982bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the specified leaf to this node, possibly creating a child branch in the process. If the leaf node already exists, replace it.  <a href="#a6c20c22e9a994a30c9640cbe1ec982bc">More...</a><br /></td></tr>
<tr class="separator:a6c20c22e9a994a30c9640cbe1ec982bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d57da960fd963ab7a02836ebf005b5"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a23d57da960fd963ab7a02836ebf005b5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a23d57da960fd963ab7a02836ebf005b5">addLeafAndCache</a> (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> *leaf, AccessorT &amp;)</td></tr>
<tr class="memdesc:a23d57da960fd963ab7a02836ebf005b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a6c20c22e9a994a30c9640cbe1ec982bc" title="Add the specified leaf to this node, possibly creating a child branch in the process. If the leaf node already exists, replace it. ">addLeaf()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <a href="#a23d57da960fd963ab7a02836ebf005b5">More...</a><br /></td></tr>
<tr class="separator:a23d57da960fd963ab7a02836ebf005b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a91bb3ba79b24928bc0f68e950c837"><td class="memTemplParams" colspan="2">template&lt;typename NodeT &gt; </td></tr>
<tr class="memitem:a37a91bb3ba79b24928bc0f68e950c837"><td class="memTemplItemLeft" align="right" valign="top">NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a37a91bb3ba79b24928bc0f68e950c837">stealNode</a> (const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="memdesc:a37a91bb3ba79b24928bc0f68e950c837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node of type <code>NodeT</code> that contains voxel (x, y, z) and replace it with a tile of the specified value and state. If no such node exists, leave the tree unchanged and return <code>nullptr</code>.  <a href="#a37a91bb3ba79b24928bc0f68e950c837">More...</a><br /></td></tr>
<tr class="separator:a37a91bb3ba79b24928bc0f68e950c837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdef4f30a36c0687e67f0e5f467ad2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#accdef4f30a36c0687e67f0e5f467ad2e">addChild</a> (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a> *child)</td></tr>
<tr class="memdesc:accdef4f30a36c0687e67f0e5f467ad2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given child node at this level deducing the offset from it's origin. If a child node with this offset already exists, delete the old node and add the new node in its place (i.e. ownership of the new child node is transferred to this <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>)  <a href="#accdef4f30a36c0687e67f0e5f467ad2e">More...</a><br /></td></tr>
<tr class="separator:accdef4f30a36c0687e67f0e5f467ad2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ab61f904112334f418ea8a1235cdad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a58ab61f904112334f418ea8a1235cdad">addTile</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> level, const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="memdesc:a58ab61f904112334f418ea8a1235cdad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a tile at the specified tree level that contains voxel (x, y, z), possibly creating a parent branch or deleting a child branch in the process.  <a href="#a58ab61f904112334f418ea8a1235cdad">More...</a><br /></td></tr>
<tr class="separator:a58ab61f904112334f418ea8a1235cdad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8dffc25e9449d959c5db02dc17715ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#af8dffc25e9449d959c5db02dc17715ee">addTile</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> offset, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="memdesc:af8dffc25e9449d959c5db02dc17715ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete any existing child branch at the specified offset and add a tile.  <a href="#af8dffc25e9449d959c5db02dc17715ee">More...</a><br /></td></tr>
<tr class="separator:af8dffc25e9449d959c5db02dc17715ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88baa1b1d12b360589dbe49a344be2b6"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a88baa1b1d12b360589dbe49a344be2b6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a88baa1b1d12b360589dbe49a344be2b6">addTileAndCache</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> level, const Coord &amp;xyz, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;, bool state, AccessorT &amp;)</td></tr>
<tr class="memdesc:a88baa1b1d12b360589dbe49a344be2b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a58ab61f904112334f418ea8a1235cdad" title="Add a tile at the specified tree level that contains voxel (x, y, z), possibly creating a parent bran...">addTile()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing (x, y, z).  <a href="#a88baa1b1d12b360589dbe49a344be2b6">More...</a><br /></td></tr>
<tr class="separator:a88baa1b1d12b360589dbe49a344be2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67464c0a432fdd5591c830b5589ce42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab67464c0a432fdd5591c830b5589ce42">touchLeaf</a> (const Coord &amp;xyz)</td></tr>
<tr class="memdesc:ab67464c0a432fdd5591c830b5589ce42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the leaf node that contains voxel (x, y, z). If no such node exists, create one, but preserve the values and active states of all voxels.  <a href="#ab67464c0a432fdd5591c830b5589ce42">More...</a><br /></td></tr>
<tr class="separator:ab67464c0a432fdd5591c830b5589ce42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9234b49b656ddd73fb2d5368e6088c06"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a9234b49b656ddd73fb2d5368e6088c06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a9234b49b656ddd73fb2d5368e6088c06">touchLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;)</td></tr>
<tr class="memdesc:a9234b49b656ddd73fb2d5368e6088c06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab67464c0a432fdd5591c830b5589ce42" title="Return the leaf node that contains voxel (x, y, z). If no such node exists, create one...">touchLeaf()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the coordinate.  <a href="#a9234b49b656ddd73fb2d5368e6088c06">More...</a><br /></td></tr>
<tr class="separator:a9234b49b656ddd73fb2d5368e6088c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a8fd1479bd7b61a23884680d5d49e0"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:ac4a8fd1479bd7b61a23884680d5d49e0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac4a8fd1479bd7b61a23884680d5d49e0">stealNodes</a> (ArrayT &amp;array, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value, bool state)</td></tr>
<tr class="memdesc:ac4a8fd1479bd7b61a23884680d5d49e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Steals all nodes of a certain type from the tree and adds them to a container with the following API:  <a href="#ac4a8fd1479bd7b61a23884680d5d49e0">More...</a><br /></td></tr>
<tr class="separator:ac4a8fd1479bd7b61a23884680d5d49e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a588b2f18ac756153e26c68159c29ca01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a588b2f18ac756153e26c68159c29ca01">resetBackground</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;oldBackground, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;newBackground)</td></tr>
<tr class="memdesc:a588b2f18ac756153e26c68159c29ca01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change inactive tiles or voxels with value oldBackground to newBackground or -oldBackground to -newBackground. Active values are unchanged.  <a href="#a588b2f18ac756153e26c68159c29ca01">More...</a><br /></td></tr>
<tr class="separator:a588b2f18ac756153e26c68159c29ca01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c323b840e618b6bd5a1e24bc25feeb5"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildNodeType , Index OtherLog2Dim&gt; </td></tr>
<tr class="memitem:a6c323b840e618b6bd5a1e24bc25feeb5"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a6c323b840e618b6bd5a1e24bc25feeb5">hasSameTopology</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, OtherLog2Dim &gt; *other) const </td></tr>
<tr class="memdesc:a6c323b840e618b6bd5a1e24bc25feeb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>true</code> if the given tree branch has the same node and active value topology as this tree branch (but possibly a different <code>ValueType</code>).  <a href="#a6c323b840e618b6bd5a1e24bc25feeb5">More...</a><br /></td></tr>
<tr class="separator:a6c323b840e618b6bd5a1e24bc25feeb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3eea16a51e9b1e79b091f3d79b2ef1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a5f3eea16a51e9b1e79b091f3d79b2ef1">isValueMaskOn</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> n) const </td></tr>
<tr class="separator:a5f3eea16a51e9b1e79b091f3d79b2ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb6db2f511bcdf54777e2402dc59dad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a5fb6db2f511bcdf54777e2402dc59dad">isValueMaskOn</a> () const </td></tr>
<tr class="separator:a5fb6db2f511bcdf54777e2402dc59dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9feb5633222e4f2d32db3d74a7c7d3f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aa9feb5633222e4f2d32db3d74a7c7d3f">isValueMaskOff</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> n) const </td></tr>
<tr class="separator:aa9feb5633222e4f2d32db3d74a7c7d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc5de204db737b967e9e6a298ab7ef7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0cc5de204db737b967e9e6a298ab7ef7">isValueMaskOff</a> () const </td></tr>
<tr class="separator:a0cc5de204db737b967e9e6a298ab7ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78aa9f7537d52f8bb57797469119a38"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac78aa9f7537d52f8bb57797469119a38">isChildMaskOn</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> n) const </td></tr>
<tr class="separator:ac78aa9f7537d52f8bb57797469119a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1e153ed2a24f3a075035f97aef2b467"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#af1e153ed2a24f3a075035f97aef2b467">isChildMaskOff</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> n) const </td></tr>
<tr class="separator:af1e153ed2a24f3a075035f97aef2b467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00e22f49aefc09392060cf5d5c65a8e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a00e22f49aefc09392060cf5d5c65a8e4">isChildMaskOff</a> () const </td></tr>
<tr class="separator:a00e22f49aefc09392060cf5d5c65a8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871b0c9de5a073d114847267e9c22850"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18d90eb4c641fe81f2f17f7e2f7f1fda">NodeMaskType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a871b0c9de5a073d114847267e9c22850">getValueMask</a> () const </td></tr>
<tr class="separator:a871b0c9de5a073d114847267e9c22850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fc0b97da28f1a04b83b9eabd509596"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18d90eb4c641fe81f2f17f7e2f7f1fda">NodeMaskType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a34fc0b97da28f1a04b83b9eabd509596">getChildMask</a> () const </td></tr>
<tr class="separator:a34fc0b97da28f1a04b83b9eabd509596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34978c95b6c2f2975f3fb4d1115001c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18d90eb4c641fe81f2f17f7e2f7f1fda">NodeMaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#af34978c95b6c2f2975f3fb4d1115001c">getValueOffMask</a> () const </td></tr>
<tr class="separator:af34978c95b6c2f2975f3fb4d1115001c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5a55c00aec3e358c7bb3441d575e445"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a2bccf19ee074e170944b394221e62e7f">UnionType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aa5a55c00aec3e358c7bb3441d575e445">getTable</a> () const </td></tr>
<tr class="separator:aa5a55c00aec3e358c7bb3441d575e445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1f0b235067a11fd0a6a03f48573723c"><td class="memTemplParams" colspan="2">template&lt;typename NodeT &gt; </td></tr>
<tr class="memitem:ab1f0b235067a11fd0a6a03f48573723c"><td class="memTemplItemLeft" align="right" valign="top">NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1f0b235067a11fd0a6a03f48573723c">probeNode</a> (const Coord &amp;xyz)</td></tr>
<tr class="separator:ab1f0b235067a11fd0a6a03f48573723c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93451bf57e5716c6f7d5d01c28c611d3"><td class="memTemplParams" colspan="2">template&lt;typename NodeT , typename AccessorT &gt; </td></tr>
<tr class="memitem:a93451bf57e5716c6f7d5d01c28c611d3"><td class="memTemplItemLeft" align="right" valign="top">NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a93451bf57e5716c6f7d5d01c28c611d3">probeNodeAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="separator:a93451bf57e5716c6f7d5d01c28c611d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1db5a3cd9f727c41548cecb5a6c633a"><td class="memTemplParams" colspan="2">template&lt;typename NodeT &gt; </td></tr>
<tr class="memitem:ad1db5a3cd9f727c41548cecb5a6c633a"><td class="memTemplItemLeft" align="right" valign="top">const NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad1db5a3cd9f727c41548cecb5a6c633a">probeConstNode</a> (const Coord &amp;xyz) const </td></tr>
<tr class="separator:ad1db5a3cd9f727c41548cecb5a6c633a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f6136a9adc7cb5bd213a75f9a37ca03"><td class="memTemplParams" colspan="2">template&lt;typename NodeT , typename AccessorT &gt; </td></tr>
<tr class="memitem:a8f6136a9adc7cb5bd213a75f9a37ca03"><td class="memTemplItemLeft" align="right" valign="top">const NodeT *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a8f6136a9adc7cb5bd213a75f9a37ca03">probeConstNodeAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc) const </td></tr>
<tr class="separator:a8f6136a9adc7cb5bd213a75f9a37ca03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3337cf5ee7f6e4190d74a28320d226e3"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a3337cf5ee7f6e4190d74a28320d226e3"><td class="memTemplItemLeft" align="right" valign="top">ChildT::LeafNodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a3337cf5ee7f6e4190d74a28320d226e3">probeLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="separator:a3337cf5ee7f6e4190d74a28320d226e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19109c78ded455aa6750cf943d70a96e"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a19109c78ded455aa6750cf943d70a96e"><td class="memTemplItemLeft" align="right" valign="top">const ChildT::LeafNodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a19109c78ded455aa6750cf943d70a96e">probeLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc) const </td></tr>
<tr class="separator:a19109c78ded455aa6750cf943d70a96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df78afa72de28b8ffe278e4b40554f9"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a6df78afa72de28b8ffe278e4b40554f9"><td class="memTemplItemLeft" align="right" valign="top">const ChildT::LeafNodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a6df78afa72de28b8ffe278e4b40554f9">probeConstLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc) const </td></tr>
<tr class="separator:a6df78afa72de28b8ffe278e4b40554f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b529733f0b52eb639833f197ca747ed"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a1b529733f0b52eb639833f197ca747ed"><td class="memTemplItemLeft" align="right" valign="top">ChildT::LeafNodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a1b529733f0b52eb639833f197ca747ed">touchLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="separator:a1b529733f0b52eb639833f197ca747ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c08c3d36ba7fe64cc4861fe4b4cae0"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a21c08c3d36ba7fe64cc4861fe4b4cae0"><td class="memTemplItemLeft" align="right" valign="top">const ChildT::ValueType &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a21c08c3d36ba7fe64cc4861fe4b4cae0">getValueAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc) const </td></tr>
<tr class="separator:a21c08c3d36ba7fe64cc4861fe4b4cae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a80ad708518280d75afb8f9a96076ae"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildT &gt; </td></tr>
<tr class="memitem:a3a80ad708518280d75afb8f9a96076ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a3a80ad708518280d75afb8f9a96076ae">topologyUnion</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildT, Log2Dim &gt; &amp;other, const bool preserveTiles)</td></tr>
<tr class="separator:a3a80ad708518280d75afb8f9a96076ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3d6186a60c1234b213848bd2405ad9"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildT &gt; </td></tr>
<tr class="memitem:a6a3d6186a60c1234b213848bd2405ad9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a6a3d6186a60c1234b213848bd2405ad9">topologyIntersection</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildT, Log2Dim &gt; &amp;other, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;background)</td></tr>
<tr class="separator:a6a3d6186a60c1234b213848bd2405ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a557187cdfa2028657e046b6b57ff45"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildT &gt; </td></tr>
<tr class="memitem:a1a557187cdfa2028657e046b6b57ff45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a1a557187cdfa2028657e046b6b57ff45">topologyDifference</a> (const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildT, Log2Dim &gt; &amp;other, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;background)</td></tr>
<tr class="separator:a1a557187cdfa2028657e046b6b57ff45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a950584ca06c9d4c5d5b6fede669ccd90"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildAllIterType , typename VisitorOp &gt; </td></tr>
<tr class="memitem:a950584ca06c9d4c5d5b6fede669ccd90"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a950584ca06c9d4c5d5b6fede669ccd90">visit2</a> (OtherChildAllIterType &amp;otherIter, VisitorOp &amp;op, bool otherIsLHS)</td></tr>
<tr class="separator:a950584ca06c9d4c5d5b6fede669ccd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65d1c12fd73ec28ff666e8878ebace5c"><td class="memTemplParams" colspan="2">template&lt;typename OtherChildAllIterType , typename VisitorOp &gt; </td></tr>
<tr class="memitem:a65d1c12fd73ec28ff666e8878ebace5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a65d1c12fd73ec28ff666e8878ebace5c">visit2</a> (OtherChildAllIterType &amp;otherIter, VisitorOp &amp;op, bool otherIsLHS) const </td></tr>
<tr class="separator:a65d1c12fd73ec28ff666e8878ebace5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:af75b5bd4a7cdb2d9472f3327e1c28277"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; </td></tr>
<tr class="memitem:af75b5bd4a7cdb2d9472f3327e1c28277"><td class="memTemplItemLeft" align="right" valign="top">NodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#af75b5bd4a7cdb2d9472f3327e1c28277">probeNode</a> (const Coord &amp;xyz)</td></tr>
<tr class="memdesc:af75b5bd4a7cdb2d9472f3327e1c28277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return nullptr.  <a href="#af75b5bd4a7cdb2d9472f3327e1c28277">More...</a><br /></td></tr>
<tr class="separator:af75b5bd4a7cdb2d9472f3327e1c28277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d69d156fff1dfe3f65db583558c8d52"><td class="memTemplParams" colspan="2">template&lt;typename NodeType &gt; </td></tr>
<tr class="memitem:a5d69d156fff1dfe3f65db583558c8d52"><td class="memTemplItemLeft" align="right" valign="top">const NodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a5d69d156fff1dfe3f65db583558c8d52">probeConstNode</a> (const Coord &amp;xyz) const </td></tr>
<tr class="memdesc:a5d69d156fff1dfe3f65db583558c8d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return nullptr.  <a href="#a5d69d156fff1dfe3f65db583558c8d52">More...</a><br /></td></tr>
<tr class="separator:a5d69d156fff1dfe3f65db583558c8d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ab553194d6f24e37d0486b99f12d5b970"><td class="memTemplParams" colspan="2">template&lt;typename NodeType , typename AccessorT &gt; </td></tr>
<tr class="memitem:ab553194d6f24e37d0486b99f12d5b970"><td class="memTemplItemLeft" align="right" valign="top">NodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab553194d6f24e37d0486b99f12d5b970">probeNodeAndCache</a> (const Coord &amp;xyz, AccessorT &amp;)</td></tr>
<tr class="memdesc:ab553194d6f24e37d0486b99f12d5b970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#af75b5bd4a7cdb2d9472f3327e1c28277" title="Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeNode()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing (x, y, z).  <a href="#ab553194d6f24e37d0486b99f12d5b970">More...</a><br /></td></tr>
<tr class="separator:ab553194d6f24e37d0486b99f12d5b970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add8131519ed759d408a0a4d57563efab"><td class="memTemplParams" colspan="2">template&lt;typename NodeType , typename AccessorT &gt; </td></tr>
<tr class="memitem:add8131519ed759d408a0a4d57563efab"><td class="memTemplItemLeft" align="right" valign="top">const NodeType *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8131519ed759d408a0a4d57563efab">probeConstNodeAndCache</a> (const Coord &amp;xyz, AccessorT &amp;) const </td></tr>
<tr class="memdesc:add8131519ed759d408a0a4d57563efab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#af75b5bd4a7cdb2d9472f3327e1c28277" title="Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeNode()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing (x, y, z).  <a href="#add8131519ed759d408a0a4d57563efab">More...</a><br /></td></tr>
<tr class="separator:add8131519ed759d408a0a4d57563efab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a416387666c1bf211debea718d27e5e2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a416387666c1bf211debea718d27e5e2f">probeLeaf</a> (const Coord &amp;xyz)</td></tr>
<tr class="memdesc:a416387666c1bf211debea718d27e5e2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#a416387666c1bf211debea718d27e5e2f">More...</a><br /></td></tr>
<tr class="separator:a416387666c1bf211debea718d27e5e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0e736a8c396807bd2643176d6e7beee"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab0e736a8c396807bd2643176d6e7beee">probeConstLeaf</a> (const Coord &amp;xyz) const </td></tr>
<tr class="memdesc:ab0e736a8c396807bd2643176d6e7beee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#ab0e736a8c396807bd2643176d6e7beee">More...</a><br /></td></tr>
<tr class="separator:ab0e736a8c396807bd2643176d6e7beee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0565d3c3e0bd185197352b63e4d7a1e7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0565d3c3e0bd185197352b63e4d7a1e7">probeLeaf</a> (const Coord &amp;xyz) const </td></tr>
<tr class="memdesc:a0565d3c3e0bd185197352b63e4d7a1e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>.  <a href="#a0565d3c3e0bd185197352b63e4d7a1e7">More...</a><br /></td></tr>
<tr class="separator:a0565d3c3e0bd185197352b63e4d7a1e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a69eaa58a07109bba3487f514bc5d03bf"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a69eaa58a07109bba3487f514bc5d03bf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a69eaa58a07109bba3487f514bc5d03bf">probeLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc)</td></tr>
<tr class="memdesc:a69eaa58a07109bba3487f514bc5d03bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeLeaf()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing (x, y, z).  <a href="#a69eaa58a07109bba3487f514bc5d03bf">More...</a><br /></td></tr>
<tr class="separator:a69eaa58a07109bba3487f514bc5d03bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df4d3142810d501c9a24a329e838536"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:a1df4d3142810d501c9a24a329e838536"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a1df4d3142810d501c9a24a329e838536">probeConstLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc) const </td></tr>
<tr class="memdesc:a1df4d3142810d501c9a24a329e838536"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeLeaf()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing (x, y, z).  <a href="#a1df4d3142810d501c9a24a329e838536">More...</a><br /></td></tr>
<tr class="separator:a1df4d3142810d501c9a24a329e838536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52a4f527e2f7c37f9cacb2e12676628"><td class="memTemplParams" colspan="2">template&lt;typename AccessorT &gt; </td></tr>
<tr class="memitem:ac52a4f527e2f7c37f9cacb2e12676628"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac52a4f527e2f7c37f9cacb2e12676628">probeLeafAndCache</a> (const Coord &amp;xyz, AccessorT &amp;acc) const </td></tr>
<tr class="memdesc:ac52a4f527e2f7c37f9cacb2e12676628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeLeaf()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing (x, y, z).  <a href="#ac52a4f527e2f7c37f9cacb2e12676628">More...</a><br /></td></tr>
<tr class="separator:ac52a4f527e2f7c37f9cacb2e12676628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a33a3cd99c0b9c78e1f6da3d9a36fdaff">getNodes</a> (ArrayT &amp;array)</td></tr>
<tr class="memdesc:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all nodes of a certain type to a container with the following API:  <a href="#a33a3cd99c0b9c78e1f6da3d9a36fdaff">More...</a><br /></td></tr>
<tr class="separator:a33a3cd99c0b9c78e1f6da3d9a36fdaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4dda98f1a46783cb8638ef4a17462c0"><td class="memTemplParams" colspan="2">template&lt;typename ArrayT &gt; </td></tr>
<tr class="memitem:ab4dda98f1a46783cb8638ef4a17462c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab4dda98f1a46783cb8638ef4a17462c0">getNodes</a> (ArrayT &amp;array) const </td></tr>
<tr class="memdesc:ab4dda98f1a46783cb8638ef4a17462c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds all nodes of a certain type to a container with the following API:  <a href="#ab4dda98f1a46783cb8638ef4a17462c0">More...</a><br /></td></tr>
<tr class="separator:ab4dda98f1a46783cb8638ef4a17462c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af6a9b0f77cb5a3c5df18a9aff3c40089"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#af6a9b0f77cb5a3c5df18a9aff3c40089">dim</a> ()</td></tr>
<tr class="separator:af6a9b0f77cb5a3c5df18a9aff3c40089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7364ceedc39ddbd16d4f61f89dda4883"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a7364ceedc39ddbd16d4f61f89dda4883">getLevel</a> ()</td></tr>
<tr class="separator:a7364ceedc39ddbd16d4f61f89dda4883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b91d6e713861046431c86630d23ae2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad3b91d6e713861046431c86630d23ae2">getNodeLog2Dims</a> (std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &gt; &amp;dims)</td></tr>
<tr class="memdesc:ad3b91d6e713861046431c86630d23ae2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populated an stil::vector with the dimension of all the nodes in the branch starting with this node.  <a href="#ad3b91d6e713861046431c86630d23ae2">More...</a><br /></td></tr>
<tr class="separator:ad3b91d6e713861046431c86630d23ae2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a252a41011fe13e50c8d49b5ca14a979b"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a252a41011fe13e50c8d49b5ca14a979b">getChildDim</a> ()</td></tr>
<tr class="separator:a252a41011fe13e50c8d49b5ca14a979b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e51328d0a2a73ad0bea8ba1a8c4b55"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a87e51328d0a2a73ad0bea8ba1a8c4b55">coordToOffset</a> (const Coord &amp;xyz)</td></tr>
<tr class="memdesc:a87e51328d0a2a73ad0bea8ba1a8c4b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the linear table offset of the given global or local coordinates.  <a href="#a87e51328d0a2a73ad0bea8ba1a8c4b55">More...</a><br /></td></tr>
<tr class="separator:a87e51328d0a2a73ad0bea8ba1a8c4b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addacd0d833277c846d6c519fc3a46c68"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#addacd0d833277c846d6c519fc3a46c68">offsetToLocalCoord</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> n, Coord &amp;xyz)</td></tr>
<tr class="memdesc:addacd0d833277c846d6c519fc3a46c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the local coordinates for a linear table offset, where offset 0 has coordinates (0, 0, 0).  <a href="#addacd0d833277c846d6c519fc3a46c68">More...</a><br /></td></tr>
<tr class="separator:addacd0d833277c846d6c519fc3a46c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:acbde5e0147479268c2f56863eb0c2775"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#acbde5e0147479268c2f56863eb0c2775">LOG2DIM</a> = Log2Dim</td></tr>
<tr class="separator:acbde5e0147479268c2f56863eb0c2775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff5839c640682a9a122640e11486eaf"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#adff5839c640682a9a122640e11486eaf">TOTAL</a> = Log2Dim + ChildNodeType::TOTAL</td></tr>
<tr class="separator:adff5839c640682a9a122640e11486eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785cb9180680cc5b0dcb6efac36579c7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a785cb9180680cc5b0dcb6efac36579c7">DIM</a> = 1 &lt;&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#adff5839c640682a9a122640e11486eaf">TOTAL</a></td></tr>
<tr class="separator:a785cb9180680cc5b0dcb6efac36579c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb8a8fff522a3cd8472b242f22ce8cde"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abb8a8fff522a3cd8472b242f22ce8cde">NUM_VALUES</a> = 1 &lt;&lt; (3 * Log2Dim)</td></tr>
<tr class="separator:abb8a8fff522a3cd8472b242f22ce8cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7efd456219bae7db497d009ad92961a7"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a7efd456219bae7db497d009ad92961a7">LEVEL</a> = 1 + ChildNodeType::LEVEL</td></tr>
<tr class="separator:a7efd456219bae7db497d009ad92961a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea8547ecf74d52579ee34a5ac62d6c0e"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aea8547ecf74d52579ee34a5ac62d6c0e">NUM_VOXELS</a> = uint64_t(1) &lt;&lt; (3 * <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#adff5839c640682a9a122640e11486eaf">TOTAL</a>)</td></tr>
<tr class="separator:aea8547ecf74d52579ee34a5ac62d6c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ac919430bc16a7a1183a79efe490159d6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac919430bc16a7a1183a79efe490159d6">MaskOnIterator</a> = typename <a class="el" href="classopenvdb_1_1v8__1_1_1util_1_1NodeMask.html#a77472f1a86bffbb333b660b3a9769bc3">NodeMaskType::OnIterator</a></td></tr>
<tr class="separator:ac919430bc16a7a1183a79efe490159d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ebb112a0c19e228bb5c9bdf5a7ea47"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a> = typename <a class="el" href="classopenvdb_1_1v8__1_1_1util_1_1NodeMask.html#ae266046e9d8f3c886747ab1a8f7730d4">NodeMaskType::OffIterator</a></td></tr>
<tr class="separator:ab1ebb112a0c19e228bb5c9bdf5a7ea47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef8f8dabcd2e6ecc94b7ef598c2308b2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aef8f8dabcd2e6ecc94b7ef598c2308b2">MaskDenseIterator</a> = typename <a class="el" href="classopenvdb_1_1v8__1_1_1util_1_1NodeMask.html#a4d482f8080d370247e901bf27dcf73ed">NodeMaskType::DenseIterator</a></td></tr>
<tr class="separator:aef8f8dabcd2e6ecc94b7ef598c2308b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ac20b5f81858f56ea4d5b86106434e8bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac20b5f81858f56ea4d5b86106434e8bb">makeChildNodeEmpty</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> n, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value)</td></tr>
<tr class="separator:ac20b5f81858f56ea4d5b86106434e8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19c8be044c364a09575e4c25e8c269ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a19c8be044c364a09575e4c25e8c269ab">setChildNode</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> i, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a> *child)</td></tr>
<tr class="separator:a19c8be044c364a09575e4c25e8c269ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb78998d4df933b8c845657ce5ab06e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a9bb78998d4df933b8c845657ce5ab06e">resetChildNode</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> i, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a> *child)</td></tr>
<tr class="separator:a9bb78998d4df933b8c845657ce5ab06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7c1f8ba3b65cdaeb6030d5c8b5011f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aec7c1f8ba3b65cdaeb6030d5c8b5011f">unsetChildNode</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> i, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;value)</td></tr>
<tr class="separator:aec7c1f8ba3b65cdaeb6030d5c8b5011f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aac35a428ae112efe59a8f01d22056dcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aac35a428ae112efe59a8f01d22056dcd">setValueMask</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> n, bool on)</td></tr>
<tr class="separator:aac35a428ae112efe59a8f01d22056dcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac6e48ad8fd6eed08e7bdcb7eed3ccdb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac6e48ad8fd6eed08e7bdcb7eed3ccdb8">getChildNode</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> n)</td></tr>
<tr class="memdesc:ac6e48ad8fd6eed08e7bdcb7eed3ccdb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the child node at the linear offset n.  <a href="#ac6e48ad8fd6eed08e7bdcb7eed3ccdb8">More...</a><br /></td></tr>
<tr class="separator:ac6e48ad8fd6eed08e7bdcb7eed3ccdb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0006c869fa4e54859a74610142f76ec8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0006c869fa4e54859a74610142f76ec8">getChildNode</a> (<a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> n) const </td></tr>
<tr class="memdesc:a0006c869fa4e54859a74610142f76ec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a pointer to the child node at the linear offset n.  <a href="#a0006c869fa4e54859a74610142f76ec8">More...</a><br /></td></tr>
<tr class="separator:a0006c869fa4e54859a74610142f76ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a44c977db48a2d200aaaa6134393af37d"><td class="memTemplParams" colspan="2">template&lt;typename NodeT , typename VisitorOp , typename ChildAllIterT &gt; </td></tr>
<tr class="memitem:a44c977db48a2d200aaaa6134393af37d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a44c977db48a2d200aaaa6134393af37d">doVisit</a> (NodeT &amp;, VisitorOp &amp;)</td></tr>
<tr class="separator:a44c977db48a2d200aaaa6134393af37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca81ce706150daab4ad31ff65a339d3"><td class="memTemplParams" colspan="2">template&lt;typename NodeT , typename OtherNodeT , typename VisitorOp , typename ChildAllIterT , typename OtherChildAllIterT &gt; </td></tr>
<tr class="memitem:a5ca81ce706150daab4ad31ff65a339d3"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a5ca81ce706150daab4ad31ff65a339d3">doVisit2Node</a> (NodeT &amp;, OtherNodeT &amp;, VisitorOp &amp;)</td></tr>
<tr class="separator:a5ca81ce706150daab4ad31ff65a339d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7ba3f1bd8e72a6fe15f9225270b42d"><td class="memTemplParams" colspan="2">template&lt;typename NodeT , typename VisitorOp , typename ChildAllIterT , typename OtherChildAllIterT &gt; </td></tr>
<tr class="memitem:aca7ba3f1bd8e72a6fe15f9225270b42d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aca7ba3f1bd8e72a6fe15f9225270b42d">doVisit2</a> (NodeT &amp;, OtherChildAllIterT &amp;, VisitorOp &amp;, bool otherIsLHS)</td></tr>
<tr class="separator:aca7ba3f1bd8e72a6fe15f9225270b42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abc5bd21eaa8b0c9fefa604d87a2487ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a2bccf19ee074e170944b394221e62e7f">UnionType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abc5bd21eaa8b0c9fefa604d87a2487ee">mNodes</a> [<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abb8a8fff522a3cd8472b242f22ce8cde">NUM_VALUES</a>]</td></tr>
<tr class="separator:abc5bd21eaa8b0c9fefa604d87a2487ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d63b70c1831dd29d599480c447d8015"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18d90eb4c641fe81f2f17f7e2f7f1fda">NodeMaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a2d63b70c1831dd29d599480c447d8015">mChildMask</a></td></tr>
<tr class="separator:a2d63b70c1831dd29d599480c447d8015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3afa0e552b2ab6c5f3236e98d56b8903"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18d90eb4c641fe81f2f17f7e2f7f1fda">NodeMaskType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a3afa0e552b2ab6c5f3236e98d56b8903">mValueMask</a></td></tr>
<tr class="separator:a3afa0e552b2ab6c5f3236e98d56b8903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af414bde19eeac7a19348e1c7c795217b"><td class="memItemLeft" align="right" valign="top">Coord&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#af414bde19eeac7a19348e1c7c795217b">mOrigin</a></td></tr>
<tr class="memdesc:af414bde19eeac7a19348e1c7c795217b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Global grid index coordinates (x,y,z) of the local origin of this node.  <a href="#af414bde19eeac7a19348e1c7c795217b">More...</a><br /></td></tr>
<tr class="separator:af414bde19eeac7a19348e1c7c795217b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a5fc7cbf1929731e78733e1b476142b8a"><td class="memTemplParams" colspan="2">template&lt;typename , Index &gt; </td></tr>
<tr class="memitem:a5fc7cbf1929731e78733e1b476142b8a"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a5fc7cbf1929731e78733e1b476142b8a">InternalNode</a></td></tr>
<tr class="memdesc:a5fc7cbf1929731e78733e1b476142b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">During topology-only construction, access is needed to protected/private members of other template instances.  <a href="#a5fc7cbf1929731e78733e1b476142b8a">More...</a><br /></td></tr>
<tr class="separator:a5fc7cbf1929731e78733e1b476142b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a3600507f55f3f4a1e38b481435756f5b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a3600507f55f3f4a1e38b481435756f5b">IteratorBase&lt; MaskOnIterator, InternalNode &gt;</a></td></tr>
<tr class="separator:a3600507f55f3f4a1e38b481435756f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf55bfd617c2997e7f10c7ae61e112d4"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#acf55bfd617c2997e7f10c7ae61e112d4">IteratorBase&lt; MaskOffIterator, InternalNode &gt;</a></td></tr>
<tr class="separator:acf55bfd617c2997e7f10c7ae61e112d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4f85768c6ab3bd7b0cc76eb825f5042"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad4f85768c6ab3bd7b0cc76eb825f5042">IteratorBase&lt; MaskDenseIterator, InternalNode &gt;</a></td></tr>
<tr class="separator:ad4f85768c6ab3bd7b0cc76eb825f5042"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="ac386aed578c229195776a00b6ba7bcfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac386aed578c229195776a00b6ba7bcfe">BuildType</a> =  typename ChildNodeType::BuildType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa08445224256785ccda0b3c3f8d6ffa3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aa08445224256785ccda0b3c3f8d6ffa3">ChildAllCIter</a> =  <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1DenseIter.html">DenseIter</a>&lt;const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>,const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildAll.html">ChildAll</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ace35dd5a583a8891d972fab967cf3d57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ace35dd5a583a8891d972fab967cf3d57">ChildAllIter</a> =  <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1DenseIter.html">DenseIter</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildAll.html">ChildAll</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add8e24322cfd0d1561ae0014fc6634e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a> =  _ChildNodeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abdccd1d5773efe94cd27c445cbebcb25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abdccd1d5773efe94cd27c445cbebcb25">ChildOffCIter</a> =  <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt;const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>,const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>,<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>,<a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildOff.html">ChildOff</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abc48cf2fefa05ebff4ada5ccd7dbc7eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abc48cf2fefa05ebff4ada5ccd7dbc7eb">ChildOffIter</a> =  <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildOff.html">ChildOff</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5eac0b6986ef0dfe4c246bf054c3054"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab5eac0b6986ef0dfe4c246bf054c3054">ChildOnCIter</a> =  <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildIter.html">ChildIter</a>&lt;const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>,const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a>,<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac919430bc16a7a1183a79efe490159d6">MaskOnIterator</a>,<a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildOn.html">ChildOn</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a856425ed62a966846f6da3a794bfe9a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a856425ed62a966846f6da3a794bfe9a8">ChildOnIter</a> =  <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildIter.html">ChildIter</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac919430bc16a7a1183a79efe490159d6">MaskOnIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ChildOn.html">ChildOn</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a895c61b706c696dee8703fefa057cd8e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> =  typename ChildNodeType::LeafNodeType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aef8f8dabcd2e6ecc94b7ef598c2308b2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aef8f8dabcd2e6ecc94b7ef598c2308b2">MaskDenseIterator</a> =  typename <a class="el" href="classopenvdb_1_1v8__1_1_1util_1_1NodeMask.html#a4d482f8080d370247e901bf27dcf73ed">NodeMaskType::DenseIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab1ebb112a0c19e228bb5c9bdf5a7ea47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a> =  typename <a class="el" href="classopenvdb_1_1v8__1_1_1util_1_1NodeMask.html#ae266046e9d8f3c886747ab1a8f7730d4">NodeMaskType::OffIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac919430bc16a7a1183a79efe490159d6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac919430bc16a7a1183a79efe490159d6">MaskOnIterator</a> =  typename <a class="el" href="classopenvdb_1_1v8__1_1_1util_1_1NodeMask.html#a77472f1a86bffbb333b660b3a9769bc3">NodeMaskType::OnIterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a18d90eb4c641fe81f2f17f7e2f7f1fda"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18d90eb4c641fe81f2f17f7e2f7f1fda">NodeMaskType</a> =  <a class="el" href="classopenvdb_1_1v8__1_1_1util_1_1NodeMask.html">util::NodeMask</a>&lt;Log2Dim&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2bccf19ee074e170944b394221e62e7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a2bccf19ee074e170944b394221e62e7f">UnionType</a> =  <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1NodeUnion.html">NodeUnion</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4cfa921c38831682ab9b5bfc0b2524eb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a4cfa921c38831682ab9b5bfc0b2524eb">ValueAllCIter</a> =  <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt;const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>,const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>,<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>,<a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueAll.html">ValueAll</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0e980796cc1df16ebbc17e4a0d534941"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0e980796cc1df16ebbc17e4a0d534941">ValueAllIter</a> =  <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueAll.html">ValueAll</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0a063d45da2bb80d7990d52c30dc0743"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0a063d45da2bb80d7990d52c30dc0743">ValueOffCIter</a> =  <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt;const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>,const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>,<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>,<a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueOff.html">ValueOff</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad7eb56d25d3f1a0e75e36d72ed820fcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad7eb56d25d3f1a0e75e36d72ed820fcd">ValueOffIter</a> =  <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueOff.html">ValueOff</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ace79c80fb5419252ee75059be909cbfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ace79c80fb5419252ee75059be909cbfa">ValueOnCIter</a> =  <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt;const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac919430bc16a7a1183a79efe490159d6">MaskOnIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueOn.html">ValueOn</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a725a2857ea71d09356ca17c97745a2e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a725a2857ea71d09356ca17c97745a2e3">ValueOnIter</a> =  <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueIter.html">ValueIter</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>, const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac919430bc16a7a1183a79efe490159d6">MaskOnIterator</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tree_1_1InternalNode_1_1ValueOn.html">ValueOn</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a955a64733ac9d1edca761e573e0efc80"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> =  typename ChildNodeType::ValueType</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a3c7d5a1827fefa3ff6cad83cb6a04998"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>
<dl class="section warning"><dt>Warning</dt><dd>The resulting <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> is uninitialized </dd></dl>

</div>
</div>
<a class="anchor" id="ad1bc92d242649f28a8d9215cd99f968e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>offValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor of an <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> with dense inactive tiles of the specified value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offValue</td><td>Background value used for inactive values </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a223e61ee2063b94cd0327c22bb2ebf20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs an <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> with dense tiles. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin</td><td>The location in index space of the fist tile value </td></tr>
    <tr><td class="paramname">fillValue</td><td>Value assigned to all the tiles </td></tr>
    <tr><td class="paramname">active</td><td>State assigned to all the tiles </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af7c69f6e0dfc71e346694e3ef90e8708"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1PartialCreate.html">PartialCreate</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>fillValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae345664c5a28b29a81286eb7419e293b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; _ChildNodeType, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deep copy constructor. </p>
<dl class="section note"><dt>Note</dt><dd>This method is multi-threaded! </dd></dl>

</div>
</div>
<a class="anchor" id="a210d885537e470d3c48b4471ee3c0f50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Value conversion copy constructor. </p>
<dl class="section note"><dt>Note</dt><dd>This method is multi-threaded! </dd></dl>

</div>
</div>
<a class="anchor" id="a6ce3601644287a8bb0a1361ea4795c8c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1TopologyCopy.html">TopologyCopy</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Topology copy constructor. </p>
<dl class="section note"><dt>Note</dt><dd>This method is multi-threaded! </dd></dl>

</div>
</div>
<a class="anchor" id="a301b2a28b08db3370ed667cac46992fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>offValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>onValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1TopologyCopy.html">TopologyCopy</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Topology copy constructor. </p>
<dl class="section note"><dt>Note</dt><dd>This method is multi-threaded! </dd></dl>

</div>
</div>
<a class="anchor" id="a3ebfad50db33120e5f5827022c035166"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="accdef4f30a36c0687e67f0e5f467ad2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool addChild </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a> *&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given child node at this level deducing the offset from it's origin. If a child node with this offset already exists, delete the old node and add the new node in its place (i.e. ownership of the new child node is transferred to this <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>) </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if inserting the child has been successful, otherwise the caller retains ownership of the node and is responsible for deleting it. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c20c22e9a994a30c9640cbe1ec982bc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addLeaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> *&#160;</td>
          <td class="paramname"><em>leaf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the specified leaf to this node, possibly creating a child branch in the process. If the leaf node already exists, replace it. </p>

</div>
</div>
<a class="anchor" id="a23d57da960fd963ab7a02836ebf005b5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addLeafAndCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a> *&#160;</td>
          <td class="paramname"><em>leaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a6c20c22e9a994a30c9640cbe1ec982bc" title="Add the specified leaf to this node, possibly creating a child branch in the process. If the leaf node already exists, replace it. ">addLeaf()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a class="anchor" id="a58ab61f904112334f418ea8a1235cdad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addTile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a tile at the specified tree level that contains voxel (x, y, z), possibly creating a parent branch or deleting a child branch in the process. </p>

</div>
</div>
<a class="anchor" id="af8dffc25e9449d959c5db02dc17715ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addTile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete any existing child branch at the specified offset and add a tile. </p>

</div>
</div>
<a class="anchor" id="a88baa1b1d12b360589dbe49a344be2b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void addTileAndCache </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a58ab61f904112334f418ea8a1235cdad" title="Add a tile at the specified tree level that contains voxel (x, y, z), possibly creating a parent bran...">addTile()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing (x, y, z). </p>

</div>
</div>
<a class="anchor" id="a599e840b09098cf3437a3c4bd366ee79"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aa08445224256785ccda0b3c3f8d6ffa3">ChildAllCIter</a> beginChildAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7000148c6f1dc8bfbb0139a3606e188e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ace35dd5a583a8891d972fab967cf3d57">ChildAllIter</a> beginChildAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8438e994f130eacf9f40014a97514bcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abdccd1d5773efe94cd27c445cbebcb25">ChildOffCIter</a> beginChildOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a845985fcf5013cc3fe15865b05b3abd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abc48cf2fefa05ebff4ada5ccd7dbc7eb">ChildOffIter</a> beginChildOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a31c7157dee0e08c357e6a3ed6415a00e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab5eac0b6986ef0dfe4c246bf054c3054">ChildOnCIter</a> beginChildOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f712beff77da092dd726a59e1104cf0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a856425ed62a966846f6da3a794bfe9a8">ChildOnIter</a> beginChildOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a18ec03c783bc71e824837c826dd6531c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a4cfa921c38831682ab9b5bfc0b2524eb">ValueAllCIter</a> beginValueAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afdf6fa279da1f6839a3ca381828220df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0e980796cc1df16ebbc17e4a0d534941">ValueAllIter</a> beginValueAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a17282c62bdf7cdd25be3b773b39907b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0a063d45da2bb80d7990d52c30dc0743">ValueOffCIter</a> beginValueOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This iterator will also visit child nodes so use isChildMaskOn to skip them! </dd></dl>

</div>
</div>
<a class="anchor" id="ad555f92c70739496805fb480c3b38f85"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ad7eb56d25d3f1a0e75e36d72ed820fcd">ValueOffIter</a> beginValueOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This iterator will also visit child nodes so use isChildMaskOn to skip them! </dd></dl>

</div>
</div>
<a class="anchor" id="a0f82a16370621f762a097f27122e51db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ace79c80fb5419252ee75059be909cbfa">ValueOnCIter</a> beginValueOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b8568cb11eacfedf042fa1eda680a45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a725a2857ea71d09356ca17c97745a2e3">ValueOnIter</a> beginValueOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae5c7824607dbdc3c1165e0b0daea8bcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aa08445224256785ccda0b3c3f8d6ffa3">ChildAllCIter</a> cbeginChildAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8169dc13d3aad941b6490f27a4bbb839"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abdccd1d5773efe94cd27c445cbebcb25">ChildOffCIter</a> cbeginChildOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a63e9bf1256874f802e2dbbc7db56f8ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab5eac0b6986ef0dfe4c246bf054c3054">ChildOnCIter</a> cbeginChildOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8b296755b1634e77e5fff9c4c48ea3c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a4cfa921c38831682ab9b5bfc0b2524eb">ValueAllCIter</a> cbeginValueAll </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae16c1191cb1a539a7cc0cdee5803d860"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a0a063d45da2bb80d7990d52c30dc0743">ValueOffCIter</a> cbeginValueOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>This iterator will also visit child nodes so use isChildMaskOn to skip them! </dd></dl>

</div>
</div>
<a class="anchor" id="ad554801c644ee82931281a11f801bf5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ace79c80fb5419252ee75059be909cbfa">ValueOnCIter</a> cbeginValueOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf8732f8cd6e4c4dc8ae7b338343d082"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> childCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6f3646d9977051fa33eb17095e736e84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clip </td>
          <td>(</td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>clipBBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>background</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels that lie outside the given axis-aligned box to the background. </p>

</div>
</div>
<a class="anchor" id="ae2ee6db19642244188d2fa4db7df1225"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; _ChildNodeType, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aff253b22319635ebad8bfcca2719003a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valueIsActive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d4331edaf20f7ae003e5cbf79349bd1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; _ChildNodeType, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNodeType &amp;&#160;</td>
          <td class="paramname"><em>other1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a58de46634dd65d1fe2e2086accaa9b2d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNodeType &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valIsActive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a551c0e1b0cbb5ae00eee28bacc8f485a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void combine2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; _ChildNodeType, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherValueType &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>valIsActive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CombineOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a87e51328d0a2a73ad0bea8ba1a8c4b55"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> coordToOffset </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the linear table offset of the given global or local coordinates. </p>

</div>
</div>
<a class="anchor" id="addb6357bae687189b953c677911834ea"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void copyToDense </td>
          <td>(</td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DenseT &amp;&#160;</td>
          <td class="paramname"><em>dense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy into a dense grid the values of the voxels that lie within a given bounding box. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive bounding box of the voxels to be copied into the dense grid </td></tr>
    <tr><td class="paramname">dense</td><td>dense grid with a stride in <em>z</em> of one (see <a class="el" href="classopenvdb_1_1v8__1_1_1tools_1_1Dense.html" title="Dense is a simple dense grid API used by the CopyToDense and CopyFromDense classes defined below...">tools::Dense</a> in <a class="el" href="Dense_8h.html" title="This file defines a simple dense grid and efficient converters to and from VDB grids. ">tools/Dense.h</a> for the required API) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><em>bbox</em> is assumed to be identical to or contained in the coordinate domains of both the dense grid and this node, i.e., no bounds checking is performed. </dd></dl>

</div>
</div>
<a class="anchor" id="abb399cd065108e53e7b65612e74372a5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void denseFill </td>
          <td>(</td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels within a given axis-aligned box to a constant value and ensure that those voxels are all represented at the leaf level. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive coordinates of opposite corners of an axis-aligned box. </td></tr>
    <tr><td class="paramname">value</td><td>the value to which to set voxels within the box. </td></tr>
    <tr><td class="paramname">active</td><td>if true, mark voxels within the box as active, otherwise mark them as inactive. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a39a2211a02fb606e611d3ff5bbd6f50c" title="Densify active tiles, i.e., replace them with leaf-level active voxels. ">voxelizeActiveTiles()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af6a9b0f77cb5a3c5df18a9aff3c40089"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> dim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The dimension of this <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a></dd></dl>
<p>The number of voxels in one coordinate direction covered by this node </p>

</div>
</div>
<a class="anchor" id="a44c977db48a2d200aaaa6134393af37d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void doVisit </td>
          <td>(</td>
          <td class="paramtype">NodeT &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aca7ba3f1bd8e72a6fe15f9225270b42d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void doVisit2 </td>
          <td>(</td>
          <td class="paramtype">NodeT &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OtherChildAllIterT &amp;&#160;</td>
          <td class="paramname"><em>otherIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>otherIsLHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ca81ce706150daab4ad31ff65a339d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void doVisit2Node </td>
          <td>(</td>
          <td class="paramtype">NodeT &amp;&#160;</td>
          <td class="paramname"><em>self</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OtherNodeT &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa4f72230ae8ade2c0a5e712708c36fa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void evalActiveBoundingBox </td>
          <td>(</td>
          <td class="paramtype">CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>visitVoxels</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Expand the specified bounding box so that it includes the active tiles of this internal node as well as all the active values in its child nodes. If visitVoxels is false LeafNodes will be approximated as dense, i.e. with all voxels active. Else the individual active voxels are visited to produce a tight bbox. </p>

</div>
</div>
<a class="anchor" id="a69bd60c87fb75e3bb7a9b5099f3a4bdf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void fill </td>
          <td>(</td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>bbox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>active</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set all voxels within a given axis-aligned box to a constant value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bbox</td><td>inclusive coordinates of opposite corners of an axis-aligned box </td></tr>
    <tr><td class="paramname">value</td><td>the value to which to set voxels within the box </td></tr>
    <tr><td class="paramname">active</td><td>if true, mark voxels within the box as active, otherwise mark them as inactive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This operation generates a sparse, but not always optimally sparse, representation of the filled box. Follow fill operations with a <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a462c7056adc55d8da2cc5828934ff859" title="Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the s...">prune()</a> operation for optimal sparseness. </dd></dl>

</div>
</div>
<a class="anchor" id="a252a41011fe13e50c8d49b5ca14a979b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getChildDim </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The dimension of the child nodes of this node.</dd></dl>
<p>The number of voxels in one coordinate direction covered by a child node of this node. </p>

</div>
</div>
<a class="anchor" id="a34fc0b97da28f1a04b83b9eabd509596"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18d90eb4c641fe81f2f17f7e2f7f1fda">NodeMaskType</a>&amp; getChildMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6e48ad8fd6eed08e7bdcb7eed3ccdb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT * getChildNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the child node at the linear offset n. </p>
<dl class="section warning"><dt>Warning</dt><dd>This protected method assumes that a child node exists at the specified linear offset! </dd></dl>

</div>
</div>
<a class="anchor" id="a0006c869fa4e54859a74610142f76ec8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT * getChildNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a pointer to the child node at the linear offset n. </p>
<dl class="section warning"><dt>Warning</dt><dd>This protected method assumes that a child node exists at the specified linear offset! </dd></dl>

</div>
</div>
<a class="anchor" id="a5b11672e5be2e242c1748af8985e6cdd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::ValueType &amp; getFirstValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the first entry in this node's table is a tile, return the tile's value. Otherwise, return the result of calling <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a5b11672e5be2e242c1748af8985e6cdd" title="If the first entry in this node&#39;s table is a tile, return the tile&#39;s value. Otherwise, return the result of calling getFirstValue() on the child. ">getFirstValue()</a> on the child. </p>

</div>
</div>
<a class="anchor" id="a1278796f9dc4866a9a9f222d8f448c90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::ValueType &amp; getLastValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the last entry in this node's table is a tile, return the tile's value. Otherwise, return the result of calling <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a1278796f9dc4866a9a9f222d8f448c90" title="If the last entry in this node&#39;s table is a tile, return the tile&#39;s value. Otherwise, return the result of calling getLastValue() on the child. ">getLastValue()</a> on the child. </p>

</div>
</div>
<a class="anchor" id="a7364ceedc39ddbd16d4f61f89dda4883"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getLevel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The level of this node</dd></dl>
<p>Level 0 is by definition the level of the leaf nodes </p>

</div>
</div>
<a class="anchor" id="a6051e4ba75b59a01e4d0e91ba9786070"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoordBBox getNodeBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the bounding box of this node, i.e., the full index space spanned by the node regardless of its content. </p>

</div>
</div>
<a class="anchor" id="ad3b91d6e713861046431c86630d23ae2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodeLog2Dims </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dims</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Populated an stil::vector with the dimension of all the nodes in the branch starting with this node. </p>

</div>
</div>
<a class="anchor" id="a33a3cd99c0b9c78e1f6da3d9a36fdaff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all nodes of a certain type to a container with the following API: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayT {</div><div class="line">   <span class="keyword">using</span> value_type = ...;<span class="comment">// defines the type of nodes to be added to the array</span></div><div class="line">   <span class="keywordtype">void</span> push_back(value_type nodePtr);<span class="comment">// method that add nodes to the array</span></div><div class="line">};</div></div><!-- fragment --><p>An example of a wrapper around a c-style array is: </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>MyArray {</div><div class="line">    <span class="keyword">using</span> value_type = LeafType*;</div><div class="line">    value_type* ptr;</div><div class="line">    MyArray(value_type* array) : ptr(array) {}</div><div class="line">    <span class="keywordtype">void</span> push_back(value_type leaf) { *ptr++ = leaf; }</div><div class="line">};</div></div><!-- fragment --><p>An example that constructs a list of pointer to all leaf nodes is: </p><div class="fragment"><div class="line">std::vector&lt;const LeafNodeType*&gt; array;<span class="comment">//most std contains have the required API</span></div><div class="line">array.reserve(tree.leafCount());<span class="comment">//this is a fast preallocation.</span></div><div class="line">tree.getNodes(array);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="ab4dda98f1a46783cb8638ef4a17462c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void getNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds all nodes of a certain type to a container with the following API: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayT {</div><div class="line">   <span class="keyword">using</span> value_type = ...;<span class="comment">// defines the type of nodes to be added to the array</span></div><div class="line">   <span class="keywordtype">void</span> push_back(value_type nodePtr);<span class="comment">// method that add nodes to the array</span></div><div class="line">};</div></div><!-- fragment --><p>An example of a wrapper around a c-style array is: </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>MyArray {</div><div class="line">    <span class="keyword">using</span> value_type = LeafType*;</div><div class="line">    value_type* ptr;</div><div class="line">    MyArray(value_type* array) : ptr(array) {}</div><div class="line">    <span class="keywordtype">void</span> push_back(value_type leaf) { *ptr++ = leaf; }</div><div class="line">};</div></div><!-- fragment --><p>An example that constructs a list of pointer to all leaf nodes is: </p><div class="fragment"><div class="line">std::vector&lt;const LeafNodeType*&gt; array;<span class="comment">//most std contains have the required API</span></div><div class="line">array.reserve(tree.leafCount());<span class="comment">//this is a fast preallocation.</span></div><div class="line">tree.getNodes(array);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="aa5a55c00aec3e358c7bb3441d575e445"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a2bccf19ee074e170944b394221e62e7f">UnionType</a>* getTable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8ce49c1d01fb40115f7253b65dd98a38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::ValueType &amp; getValue </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab54f367109416043c0ce7d175be04c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>&amp; getValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value of the voxel at the given coordinates and, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a21c08c3d36ba7fe64cc4861fe4b4cae0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::ValueType&amp; getValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a619e96c166b4b5e8528f70d03318b940"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getValueLevel </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the level of the tree (0 = leaf) at which the value at the given coordinates resides. </p>

</div>
</div>
<a class="anchor" id="a7d6b11a975fc78c2ea13585256b5b720"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> getValueLevelAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the level of the tree (0 = leaf) at which the value at the given coordinates resides. </p>
<p>If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a871b0c9de5a073d114847267e9c22850"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18d90eb4c641fe81f2f17f7e2f7f1fda">NodeMaskType</a>&amp; getValueMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af34978c95b6c2f2975f3fb4d1115001c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18d90eb4c641fe81f2f17f7e2f7f1fda">NodeMaskType</a> getValueOffMask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1e1a133192d9d344c482d4aa83f6da33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasActiveTiles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if this node or any of its child nodes have any active tiles. </p>

</div>
</div>
<a class="anchor" id="a6c323b840e618b6bd5a1e24bc25feeb5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool hasSameTopology </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, OtherLog2Dim &gt; *&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the given tree branch has the same node and active value topology as this tree branch (but possibly a different <code>ValueType</code>). </p>

</div>
</div>
<a class="anchor" id="af1e153ed2a24f3a075035f97aef2b467"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isChildMaskOff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a00e22f49aefc09392060cf5d5c65a8e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isChildMaskOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac78aa9f7537d52f8bb57797469119a38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isChildMaskOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afbde11b027a056fd5b7b196a1173182c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>firstValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__1.html#a9bc9fb4000c5e821a917537e91e21eda">zeroVal</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if all of this node's table entries have the same active state and the same constant value to within the given tolerance, and return that value in <em>firstValue</em> and the active state in <em>state</em>.</p>
<dl class="section note"><dt>Note</dt><dd>This method also returns <code>false</code> if this node contains any child nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a27932bcbc2413401194bfa313a57dbf9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isConstant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>minValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>maxValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__1.html#a9bc9fb4000c5e821a917537e91e21eda">zeroVal</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if all of this node's tables entries have the same active <em>state</em> and the range of its values satisfy (<em>maxValue</em> - <em>minValue</em>) &lt;= <em>tolerance</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minValue</td><td>Is updated with the minimum of all values IF method returns <code>true</code>. Else the value is undefined! </td></tr>
    <tr><td class="paramname">maxValue</td><td>Is updated with the maximum of all values IF method returns <code>true</code>. Else the value is undefined! </td></tr>
    <tr><td class="paramname">state</td><td>Is updated with the state of all values IF method returns <code>true</code>. Else the value is undefined! </td></tr>
    <tr><td class="paramname">tolerance</td><td>The tolerance used to determine if values are approximatly constant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This method also returns <code>false</code> if this node contains any child nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a479432127ee77145cc19d6a2d1590821"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True if this node contains no child nodes. </dd></dl>

</div>
</div>
<a class="anchor" id="a44b7e3231fdb2ff6ee1fb822b2b921eb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isInactive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if this node has no children and only contains inactive values. </p>

</div>
</div>
<a class="anchor" id="aa9feb5633222e4f2d32db3d74a7c7d3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueMaskOff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0cc5de204db737b967e9e6a298ab7ef7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueMaskOff </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5f3eea16a51e9b1e79b091f3d79b2ef1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueMaskOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5fb6db2f511bcdf54777e2402dc59dad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueMaskOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afc695b4cc2c115afbdb51d4997b69747"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueOn </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the voxel at the given coordinates is active. </p>

</div>
</div>
<a class="anchor" id="ab471165041eb1c9de3c9beb14d1ca7b7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueOn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>true</code> if the voxel at the given offset is active. </p>

</div>
</div>
<a class="anchor" id="a7b19bb2b11319fb6eaab50aada9bff01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool isValueOnAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if the voxel at the given coordinates is active and, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a0667d468064aa044670a06a84b9c48ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> leafCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac20b5f81858f56ea4d5b86106434e8bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void makeChildNodeEmpty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8443805eb98462d37d9c3f7b549ede0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> memUsage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total amount of memory in bytes occupied by this node and its children. </p>

</div>
</div>
<a class="anchor" id="a0678918b353a7fa416685a3a5ba6c3fb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; _ChildNodeType, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>background</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>otherBackground</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Efficiently merge another tree into this tree using one of several schemes. </p>
<dl class="section warning"><dt>Warning</dt><dd>This operation cannibalizes the other tree. </dd></dl>

</div>
</div>
<a class="anchor" id="a4119e466f0aaba9e53ef8b8d97af8a18"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>tileValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>tileActive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Merge, using one of several schemes, this node (and its descendants) with a tile of the same dimensions and the given value and active state. </p>

</div>
</div>
<a class="anchor" id="aa6954a428c0ef18a03431f251f4e7d24"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValue </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor to the value of the voxel at the given coordinates and mark the voxel as active. </p>

</div>
</div>
<a class="anchor" id="a5cb69af7e17c3a9a6d6dc360c878448c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValueAndActiveState </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor to the voxel at the given coordinates. </p>

</div>
</div>
<a class="anchor" id="af057648803b9073ce1703dbf061e0d1f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValueAndActiveStateAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply a functor to the voxel at the given coordinates. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a7bed5c7c0d76cacfb514d9744f754402"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void modifyValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ModifyOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a functor to the value of the voxel at the given coordinates and mark the voxel as active. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p>
<dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="abcdb1512395327f8236a4f4a4d4ff648"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void negate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change the sign of all the values represented in this node and its child nodes. </p>

</div>
</div>
<a class="anchor" id="aa4ac16944cc943e8a524cc80824182ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void nodeCount </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8d22ef34f6459bcffc00f6eb8f747b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a917c2f1000852aa31ba9feba206c11ae">Index32</a> nonLeafCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a78ac72edbf61ebf466b06f6bb4f1ffc6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> offLeafVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a79eb1621afd1bcf8ca45386b04a839bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Coord offsetToGlobalCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the global coordinates for a linear table offset. </p>

</div>
</div>
<a class="anchor" id="addacd0d833277c846d6c519fc3a46c68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void offsetToLocalCoord </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the local coordinates for a linear table offset, where offset 0 has coordinates (0, 0, 0). </p>

</div>
</div>
<a class="anchor" id="a22486b1420a67aaf492e7e4ca2ca6fb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> offVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abe2ccd641ba4842769eb649c856d05b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> onLeafVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad8c7f5922acf9662196a81ec4470aedd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> onTileCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae41639979a334066f76633037c605a77"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> onVoxelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a605928767da2cb90e6ad6b5021f49592"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Coord&amp; origin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the grid index coordinates of this node's local origin. </p>

</div>
</div>
<a class="anchor" id="ab0e736a8c396807bd2643176d6e7beee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::LeafNodeType * probeConstLeaf </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a class="anchor" id="a1df4d3142810d501c9a24a329e838536"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a>* probeConstLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeLeaf()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing (x, y, z). </p>

</div>
</div>
<a class="anchor" id="a6df78afa72de28b8ffe278e4b40554f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::LeafNodeType* probeConstLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5d69d156fff1dfe3f65db583558c8d52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const NodeType* probeConstNode </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return nullptr. </p>

</div>
</div>
<a class="anchor" id="ad1db5a3cd9f727c41548cecb5a6c633a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const NodeT* probeConstNode </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add8131519ed759d408a0a4d57563efab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const NodeType* probeConstNodeAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#af75b5bd4a7cdb2d9472f3327e1c28277" title="Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeNode()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing (x, y, z). </p>

</div>
</div>
<a class="anchor" id="a8f6136a9adc7cb5bd213a75f9a37ca03"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const NodeT* probeConstNodeAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a416387666c1bf211debea718d27e5e2f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT::LeafNodeType * probeLeaf </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a class="anchor" id="a0565d3c3e0bd185197352b63e4d7a1e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a>* probeLeaf </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return <code>nullptr</code>. </p>

</div>
</div>
<a class="anchor" id="a69eaa58a07109bba3487f514bc5d03bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a>* probeLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeLeaf()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing (x, y, z). </p>

</div>
</div>
<a class="anchor" id="ac52a4f527e2f7c37f9cacb2e12676628"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a>* probeLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a416387666c1bf211debea718d27e5e2f" title="Return a pointer to the leaf node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeLeaf()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing (x, y, z). </p>

</div>
</div>
<a class="anchor" id="a3337cf5ee7f6e4190d74a28320d226e3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT::LeafNodeType* probeLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a19109c78ded455aa6750cf943d70a96e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const ChildT::LeafNodeType* probeLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af75b5bd4a7cdb2d9472f3327e1c28277"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeType* probeNode </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return nullptr. </p>

</div>
</div>
<a class="anchor" id="ab1f0b235067a11fd0a6a03f48573723c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeT* probeNode </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab553194d6f24e37d0486b99f12d5b970"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">NodeType* probeNodeAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#af75b5bd4a7cdb2d9472f3327e1c28277" title="Return a pointer to the node that contains voxel (x, y, z). If no such node exists, return nullptr. ">probeNode()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing (x, y, z). </p>

</div>
</div>
<a class="anchor" id="a93451bf57e5716c6f7d5d01c28c611d3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeT* probeNodeAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0535ed999c1364a5bc5f31e668e5ef7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool probeValue </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab682876d96e5d4b4c7bd90ef19638d7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool probeValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return, in <em>value</em>, the value of the voxel at the given coordinates and, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section return"><dt>Returns</dt><dd><code>true</code> if the voxel at the given coordinates is active </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a462c7056adc55d8da2cc5828934ff859"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void prune </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespaceopenvdb_1_1v8__1.html#a9bc9fb4000c5e821a917537e91e21eda">zeroVal</a>&lt;<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a>&gt;()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reduce the memory footprint of this tree by replacing with tiles any nodes whose values are all the same (optionally to within a tolerance) and have the same active state. </p>

</div>
</div>
<a class="anchor" id="aef270a4e4900e5e0bd24e6664d6a8a82"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readBuffers </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a9d516efdbb242e00e7c77ae85cc426b6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readBuffers </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoordBBox &amp;&#160;</td>
          <td class="paramname"><em>clipBBox</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abcdf345c3364a34a9b0e3ba2883960e2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void readTopology </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fromHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a588b2f18ac756153e26c68159c29ca01"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resetBackground </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>oldBackground</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>newBackground</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change inactive tiles or voxels with value oldBackground to newBackground or -oldBackground to -newBackground. Active values are unchanged. </p>

</div>
</div>
<a class="anchor" id="a9bb78998d4df933b8c845657ce5ab06e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void resetChildNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b3e82eb582914ac6f31f32fea77292f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setActiveState </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the active state of the voxel at the given coordinates but don't change its value. </p>

</div>
</div>
<a class="anchor" id="ac04db06362bfb5ec0ed6212469eb4ff3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setActiveStateAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the active state of the voxel at the given coordinates without changing its value. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a19c8be044c364a09575e4c25e8c269ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setChildNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#add8e24322cfd0d1561ae0014fc6634e4">ChildNodeType</a> *&#160;</td>
          <td class="paramname"><em>child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a594b25da67e57a3b0f252ce8417bb5e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setOrigin </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>origin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the grid index coordinates of this node's local origin. </p>

</div>
</div>
<a class="anchor" id="a01b75fc2aa129aa05ae677971dc1972e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value of the voxel at the given coordinates and mark it as active. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="aac35a428ae112efe59a8f01d22056dcd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueMask </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Use a mask accessor to ensure consistency between the child and value masks; i.e., the value mask should always be off wherever the child mask is on. </p>

</div>
</div>
<a class="anchor" id="a8a91d631df8f64f84a0aad7436cb11f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOff </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the voxel at the given coordinates as inactive but don't change its value. </p>

</div>
</div>
<a class="anchor" id="a73a6e7c85d37e7d677eddc3cce8aa11b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOff </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates and mark the voxel as inactive. </p>

</div>
</div>
<a class="anchor" id="a6c0c65991a0b3c81933cd944d8fc4267"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOffAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the value of the voxel at the given coordinates and mark it as inactive. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6cf12f28a771762327ba1578bc48e9c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOn </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark the voxel at the given coordinates as active but don't change its value. </p>

</div>
</div>
<a class="anchor" id="ae95653046c85afb743075f139a26df9d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOn </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates and mark the voxel as active. </p>

</div>
</div>
<a class="anchor" id="a63ff695beda11ed9ef625a28ce8a5faf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnly </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the value of the voxel at the given coordinates but don't change its active state. </p>

</div>
</div>
<a class="anchor" id="a5cefbe46cc3180e5394a2f4fc775bfe8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValueOnlyAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the value of the voxel at the given coordinate but preserves its active state. If necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the voxel. </p><dl class="section note"><dt>Note</dt><dd>Used internally by <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1ValueAccessor.html">ValueAccessor</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="ac155d78b56e45b4d18aad6b18d957d5a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void setValuesOn </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Mark all values (both tiles and voxels) as active. </p>

</div>
</div>
<a class="anchor" id="a37a91bb3ba79b24928bc0f68e950c837"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NodeT * stealNode </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a pointer to the node of type <code>NodeT</code> that contains voxel (x, y, z) and replace it with a tile of the specified value and state. If no such node exists, leave the tree unchanged and return <code>nullptr</code>. </p>
<dl class="section note"><dt>Note</dt><dd>The caller takes ownership of the node and is responsible for deleting it.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Since this method potentially removes nodes and branches of the tree, it is important to clear the caches of all ValueAccessors associated with this tree. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4a8fd1479bd7b61a23884680d5d49e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void stealNodes </td>
          <td>(</td>
          <td class="paramtype">ArrayT &amp;&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Steals all nodes of a certain type from the tree and adds them to a container with the following API: </p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ArrayT {</div><div class="line">   <span class="keyword">using</span> value_type = ...;<span class="comment">// defines the type of nodes to be added to the array</span></div><div class="line">   <span class="keywordtype">void</span> push_back(value_type nodePtr);<span class="comment">// method that add nodes to the array</span></div><div class="line">};</div></div><!-- fragment --><p>An example of a wrapper around a c-style array is: </p><div class="fragment"><div class="line"> <span class="keyword">struct </span>MyArray {</div><div class="line">    <span class="keyword">using</span> value_type = LeafType*;</div><div class="line">    value_type* ptr;</div><div class="line">    MyArray(value_type* array) : ptr(array) {}</div><div class="line">    <span class="keywordtype">void</span> push_back(value_type leaf) { *ptr++ = leaf; }</div><div class="line">};</div></div><!-- fragment --><p>An example that constructs a list of pointer to all leaf nodes is: </p><div class="fragment"><div class="line">std::vector&lt;const LeafNodeType*&gt; array;<span class="comment">//most std contains have the required API</span></div><div class="line">array.reserve(tree.leafCount());<span class="comment">//this is a fast preallocation.</span></div><div class="line">tree.stealNodes(array);</div></div><!-- fragment --> 
</div>
</div>
<a class="anchor" id="a77c47237feeecc609582460c08dbb242"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void topologyDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>background</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Difference this node's set of active values with the active values of the other node, whose <code>ValueType</code> may be different. So a resulting voxel will be active only if the original voxel is active in this node and inactive in the other node. </p>
<p>The last dummy argument is required to match the signature for <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a77c47237feeecc609582460c08dbb242" title="Difference this node&#39;s set of active values with the active values of the other node, whose ValueType may be different. So a resulting voxel will be active only if the original voxel is active in this node and inactive in the other node. ">InternalNode::topologyDifference</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation modifies only active states, not values. Also note that this operation can result in all voxels being inactive so consider subsequnetly calling prune. </dd></dl>

</div>
</div>
<a class="anchor" id="a1a557187cdfa2028657e046b6b57ff45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void topologyDifference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildT, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>background</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2973e4d0d6266e3e42f1457262164347"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void topologyIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>background</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Intersects this tree's set of active values with the active values of the other tree, whose <code>ValueType</code> may be different. </p>
<p>The resulting state of a value is active only if the corresponding value was already active AND if it is active in the other tree. Also, a resulting value maps to a voxel if the corresponding value already mapped to an active voxel in either of the two grids and it maps to an active tile or voxel in the other grid.</p>
<dl class="section note"><dt>Note</dt><dd>This operation can delete branches in this grid if they overlap with inactive tiles in the other grid. Likewise active voxels can be turned into unactive voxels resulting in leaf nodes with no active values. Thus, it is recommended to subsequently call prune. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a3d6186a60c1234b213848bd2405ad9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void topologyIntersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildT, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>background</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a81ae377eb1c0cb00c077759d645fd7e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void topologyUnion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildNodeType, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>preserveTiles</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Union this branch's set of active values with the other branch's active values. The value type of the other branch can be different. </p>
<p>The resulting state of a value is active if the corresponding value was already active OR if it is active in the other tree. Also, a resulting value maps to a voxel if the corresponding value already mapped to a voxel OR if it is a voxel in the other tree. Thus, a resulting value can only map to a tile if the corresponding value already mapped to a tile AND if it is a tile value in other tree.</p>
<p>Specifically, active tiles and voxels in this branch are not changed, and tiles or voxels that were inactive in this branch but active in the other branch are marked as active in this branch but left with their original values. </p>

</div>
</div>
<a class="anchor" id="a3a80ad708518280d75afb8f9a96076ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void topologyUnion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a>&lt; OtherChildT, Log2Dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>preserveTiles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab67464c0a432fdd5591c830b5589ce42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT::LeafNodeType * touchLeaf </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the leaf node that contains voxel (x, y, z). If no such node exists, create one, but preserve the values and active states of all voxels. </p>
<p>Use this method to preallocate a static tree topology over which to safely perform multithreaded processing. </p>

</div>
</div>
<a class="anchor" id="a9234b49b656ddd73fb2d5368e6088c06"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a895c61b706c696dee8703fefa057cd8e">LeafNodeType</a>* touchLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab67464c0a432fdd5591c830b5589ce42" title="Return the leaf node that contains voxel (x, y, z). If no such node exists, create one...">touchLeaf()</a> except, if necessary, update the accessor with pointers to the nodes along the path from the root node to the node containing the coordinate. </p>

</div>
</div>
<a class="anchor" id="a1b529733f0b52eb639833f197ca747ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT::LeafNodeType* touchLeafAndCache </td>
          <td>(</td>
          <td class="paramtype">const Coord &amp;&#160;</td>
          <td class="paramname"><em>xyz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AccessorT &amp;&#160;</td>
          <td class="paramname"><em>acc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aec7c1f8ba3b65cdaeb6030d5c8b5011f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ChildT * unsetChildNode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a955a64733ac9d1edca761e573e0efc80">ValueType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a028a58e937882a91e9c1470fb6e73b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit </td>
          <td>(</td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac6e62589958cedae5c2cd4b356f6ba7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit </td>
          <td>(</td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3595aa225add4df3db17545b9250cd6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void visit2 </td>
          <td>(</td>
          <td class="paramtype">IterT &amp;&#160;</td>
          <td class="paramname"><em>otherIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>otherIsLHS</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7de0cadde4e5ded9ae2fff73126718d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void visit2 </td>
          <td>(</td>
          <td class="paramtype">IterT &amp;&#160;</td>
          <td class="paramname"><em>otherIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>otherIsLHS</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a950584ca06c9d4c5d5b6fede669ccd90"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit2 </td>
          <td>(</td>
          <td class="paramtype">OtherChildAllIterType &amp;&#160;</td>
          <td class="paramname"><em>otherIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>otherIsLHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a65d1c12fd73ec28ff666e8878ebace5c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit2 </td>
          <td>(</td>
          <td class="paramtype">OtherChildAllIterType &amp;&#160;</td>
          <td class="paramname"><em>otherIter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>otherIsLHS</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa68756dbd8a216cdc248d4e828927ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit2Node </td>
          <td>(</td>
          <td class="paramtype">OtherNodeType &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2891ea5e9fa708cc8c72bfeddb24eaf4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visit2Node </td>
          <td>(</td>
          <td class="paramtype">OtherNodeType &amp;&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">VisitorOp &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a973ced84fe7b684d6be0acb5cef74c33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void visitActiveBBox </td>
          <td>(</td>
          <td class="paramtype">BBoxOp &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the templated functor BBoxOp with bounding box information for all active tiles and leaf nodes in this node. An additional level argument is provided for each callback. </p>
<dl class="section note"><dt>Note</dt><dd>The bounding boxes are guarenteed to be non-overlapping. </dd></dl>

</div>
</div>
<a class="anchor" id="a39a2211a02fb606e611d3ff5bbd6f50c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void voxelizeActiveTiles </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>threaded</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Densify active tiles, i.e., replace them with leaf-level active voxels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threaded</td><td>if true, this operation is multi-threaded (over the internal nodes). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abb399cd065108e53e7b65612e74372a5" title="Set all voxels within a given axis-aligned box to a constant value and ensure that those voxels are a...">denseFill()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1517c3788b6d11d5e07a577dd38d7c43"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeBuffers </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a72d547afeb73396804509f85ec7043e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void writeTopology </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>toHalf</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a5fc7cbf1929731e78733e1b476142b8a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>During topology-only construction, access is needed to protected/private members of other template instances. </p>

</div>
</div>
<a class="anchor" id="ad4f85768c6ab3bd7b0cc76eb825f5042"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1IteratorBase.html">IteratorBase</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aef8f8dabcd2e6ecc94b7ef598c2308b2">MaskDenseIterator</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allow iterators to call mask accessor methods (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aac35a428ae112efe59a8f01d22056dcd">setValueMask()</a>, setChildMask(), etc.).  </p>

</div>
</div>
<a class="anchor" id="acf55bfd617c2997e7f10c7ae61e112d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1IteratorBase.html">IteratorBase</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ab1ebb112a0c19e228bb5c9bdf5a7ea47">MaskOffIterator</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allow iterators to call mask accessor methods (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aac35a428ae112efe59a8f01d22056dcd">setValueMask()</a>, setChildMask(), etc.).  </p>

</div>
</div>
<a class="anchor" id="a3600507f55f3f4a1e38b481435756f5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1IteratorBase.html">IteratorBase</a>&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#ac919430bc16a7a1183a79efe490159d6">MaskOnIterator</a>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html">InternalNode</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allow iterators to call mask accessor methods (<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#aac35a428ae112efe59a8f01d22056dcd">setValueMask()</a>, setChildMask(), etc.).  </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a785cb9180680cc5b0dcb6efac36579c7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> DIM = 1 &lt;&lt; <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#adff5839c640682a9a122640e11486eaf">TOTAL</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7efd456219bae7db497d009ad92961a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> LEVEL = 1 + ChildNodeType::LEVEL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acbde5e0147479268c2f56863eb0c2775"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> LOG2DIM = Log2Dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2d63b70c1831dd29d599480c447d8015"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18d90eb4c641fe81f2f17f7e2f7f1fda">NodeMaskType</a> mChildMask</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abc5bd21eaa8b0c9fefa604d87a2487ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a2bccf19ee074e170944b394221e62e7f">UnionType</a> mNodes[<a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#abb8a8fff522a3cd8472b242f22ce8cde">NUM_VALUES</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af414bde19eeac7a19348e1c7c795217b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Coord mOrigin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Global grid index coordinates (x,y,z) of the local origin of this node. </p>

</div>
</div>
<a class="anchor" id="a3afa0e552b2ab6c5f3236e98d56b8903"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#a18d90eb4c641fe81f2f17f7e2f7f1fda">NodeMaskType</a> mValueMask</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abb8a8fff522a3cd8472b242f22ce8cde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> NUM_VALUES = 1 &lt;&lt; (3 * Log2Dim)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aea8547ecf74d52579ee34a5ac62d6c0e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">Index64</a> NUM_VOXELS = uint64_t(1) &lt;&lt; (3 * <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1InternalNode.html#adff5839c640682a9a122640e11486eaf">TOTAL</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="adff5839c640682a9a122640e11486eaf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">Index</a> TOTAL = Log2Dim + ChildNodeType::TOTAL</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="InternalNode_8h_source.html">InternalNode.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
