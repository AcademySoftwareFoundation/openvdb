<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: Building OpenVDB</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.1.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenVDB</a></li><li class="navelem"><a class="el" href="openvdbax.html">OpenVDB AX</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Building OpenVDB </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="buildContents"></a>
Contents</h1>
<ul>
<li><a class="el" href="build.html#buildIntroduction">Introduction</a></li>
<li><a class="el" href="build.html#buildCmakeStructure">CMake Structure</a><ul>
<li><a class="el" href="build.html#buildDependencies">Locating Dependencies</a></li>
<li><a class="el" href="build.html#buildMixingDepInstalls">Mixing Dependency Installations</a></li>
<li><a class="el" href="build.html#buildBloscSupport">Blosc Support</a></li>
<li><a class="el" href="build.html#buildZLibSupport">ZLIB Support</a></li>
<li><a class="el" href="build.html#buildVCPKG">Building Dependencies using VCPKG</a></li>
</ul>
</li>
<li><a class="el" href="build.html#buildComponents">OpenVDB Components</a></li>
<li><a class="el" href="build.html#buildGuide">Building With CMake</a><ul>
<li><a class="el" href="build.html#buildBuildTypes">Build Types</a></li>
<li><a class="el" href="build.html#buildBuildHouMaya">Building Against Houdini/Maya</a><ul>
<li><a class="el" href="build.html#buildBuildHou">Building Against Houdini</a></li>
<li><a class="el" href="build.html#buildBuildMaya">Building Against Maya</a></li>
</ul>
</li>
<li><a class="el" href="build.html#buildBuildStandalone">Building Standalone</a></li>
</ul>
</li>
<li><a class="el" href="build.html#buildUsingOpenVDB">Building With OpenVDB</a></li>
<li><a class="el" href="build.html#buildTroubleshooting">Troubleshooting</a></li>
</ul>
<hr/>
<h1><a class="anchor" id="buildIntroduction"></a>
Introduction</h1>
<p><a href="https://cmake.org/">CMake</a> is a cross-platform family of tools designed to help build software. CMake doesn't <em>actually</em> build the project but instead generates the files required for your toolchain, for example makefiles that serve as input to <a href="https://www.gnu.org/software/make/">GNU Make</a>. CMake support ensures a high level of flexibility and pre-compile verification to the build process, making it much easier to control and customize the installation process for a wider range of platforms.</p>
<p>CMake also makes it easier to automatically find and handle dependencies. If you're completely new to CMake, you may find it useful to read over the brief <a href="https://cmake.org/runningcmake/">introduction to CMake</a> and the CMake structure section below. However the <a class="el" href="build.html#buildGuide">build guide</a> runs through the build process step by step.</p>
<h1><a class="anchor" id="buildCmakeStructure"></a>
CMake Structure</h1>
<p>CMake will configure a set of build files which represent the commands and dependencies for the OpenVDB components you wish to install. Finding and handling these dependencies on different platforms comprises the majority of the complexity involved in writing CMake. In general, software which uses CMake is expected to provide their own configuration files which dependent software will locate and use. Not all of OpenVDB's dependencies provide CMake support and therefore do not deploy with CMake configurations that OpenVDB can use. OpenVDB provides a set of <code>FindModules</code> in the <code>cmake</code> folder for finding these various dependencies e.g. <code>FindBlosc.cmake</code>. These are designed such that they can theoretically be used by any project that needs to locate the given library and are invoked by the <code>find_package()</code> call. For more information on FindModules and locating packages with CMake, see the following CMake documentation:</p>
<ul>
<li><a href="https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html#using-packages">Using Packages with CMake</a></li>
<li><a href="https://cmake.org/cmake/help/latest/command/find_package.html">Calling find_package()</a></li>
</ul>
<p>The other type of file provided by OpenVDB are <code>OpenVDBSetupX.cmake</code> includes. These are primarily designed to configure the building of OpenVDB components against supported DCC's (Houdini/Maya) by locating their installations and setting various CMake variables for subsequent <code>find_package()</code> dependency calls. They also represent packages which already provide their own CMake modules, but additionally provide the same input variable interface as OpenVDB's other <code>Find</code> Modules.</p>
<h2><a class="anchor" id="buildDependencies"></a>
Locating Dependencies</h2>
<p>Each CMake FindModule provides a description of the possible inputs which can be provided to help drive the search for OpenVDB dependencies (as well as the resulting outputs). They have been homogenized such that these variables follow a set convention, typically followed by most CMake projects. For a given FindModule e.g. <code>FindBlosc.cmake</code>:</p>
<ul>
<li>FindXxx.cmake provides the module interface where Xxx becomes the library name</li>
<li>Invoked with the called <code>find_package( Xxx )</code></li>
</ul>
<ul>
<li><b>Inputs</b> - The following variables can be used to help drive the search path on first runs of CMake (i.e. these variables are not <a href="https://cmake.org/cmake/help/latest/command/set.html#set-cache-entry">cached</a>). They are listed in priority order. Note that the prefix is always capitalized.<ul>
<li><b>XXX_INCLUDEDIR</b> / <b>XXX_LIBRARYDIR</b> - Preferred include and library directories</li>
<li><b>Xxx_ROOT</b> - Preferred installation prefix. The given dependency is expected to follow a folder structure <code>Xxx_ROOT/include</code> and <code>Xxx_ROOT/lib</code> exist. Note that unlike the above, this is the case matching name of the find package .i.e. Blosc_ROOT, IlmBase_ROOT, TBB_ROOT etc.</li>
<li><b>SYSTEM_LIBRARY_PATHS</b> - A list of paths appended to all include and lib searches.</li>
<li><b>XXX_USE_STATIC_LIBS</b> - Only search for static libraries for the given dependency. If OFF, the shared library is prioritized, falling back to the static library. This is OFF by default.</li>
<li><b>DISABLE_CMAKE_SEARCH_PATHS</b> - The above variables are custom to the OpenVDB project. CMake itself implements its own search system to try and find the given libraries and packages. When ON, this variable disables CMake's inbuilt search, guaranteeing that only the above user provided paths are searched. See <a href="https://cmake.org/cmake/help/latest/command/find_package.html#search-procedure">CMakes Search Procedure</a> for more information. This is OFF by default (and thus CMake's search is enabled).</li>
</ul>
</li>
</ul>
<ul>
<li><b>Outputs</b> The following variables are always set if the project is found:<ul>
<li><b>Xxx_FOUND</b> - True if the headers and library was found and exists</li>
<li><b>Xxx_VERSION</b> - The library version</li>
<li><b>Xxx_INCLUDE_DIRS</b> - A list of paths to all required include directories</li>
<li><b>Xxx_RELEASSE_LIBRARY_DIRS</b> - A list of paths to all required release library directories</li>
<li><b>Xxx_DEBUG_LIBRARY_DIRS</b> - A list of paths to all required debug library directories</li>
<li><b>Xxx_RELEASE_LIBRARIES</b> - A list of libraries needed to use the release version of Xxx</li>
<li><b>Xxx_DEBUG_LIBRARIES</b> - A list of libraries needed to use the debug version of Xxx</li>
</ul>
</li>
<li>Each module produces an <a href="https://cmake.org/cmake/help/latest/command/add_library.html#imported-libraries">imported target</a> in the form <b>Xxx::xxx</b>, and may generate multiple imported targets if multiple components are found.</li>
</ul>
<h2><a class="anchor" id="buildMixingDepInstalls"></a>
Mixing Dependency Installations</h2>
<p>There may be a situation where you use a package manager to install some dependencies, use a DCC such as Maya to provide others and manually build and install others from source. Care must be taken when providing CMake with these locations to ensure that the correct files are used. Incorrect use of the above variables can lead to difficult to diagnose build and runtime errors.</p>
<p>As an example, let's assume we have a manual installation of TBB (either through a Maya installation or a manual installation from source) and we want to use this with other dependencies installed through a package manager such as homebrew. As homebrew copies all headers and libraries it installs to a <code>&lt;homebrew&gt;/include</code> <code>&lt;homebrew&gt;/lib</code> directory structure, it can be tempting to set <b>Xxx_ROOT</b> variables to points to the <code>&lt;homebrew&gt;</code> folder. However you may already have an existing installation of TBB through your package manager, potentially installed by as a dependency of a completely unrelated piece of software. Whilst CMake may report to you the correct include/lib path, this can end up being hidden at compile time through these types of shared installations. You should not rely on the dependency order of the CMake build system - instead, it's important that you try to use the explicit directory paths where possible. For example homebrew will install each piece of software to <code>&lt;homebrew&gt;/Cellar/&lt;dep_name&gt;/&lt;dep_version&gt;</code>, where the subsequent include and library directories can be passed to <b>XXX_INCLUDEDIR</b> and <b>XXX_LIBRARYDIR</b> respectively.</p>
<p>In summary try to stick to a single installation workflow and, if in doubt, provide direct include/lib paths to isolated software locations.</p>
<h2><a class="anchor" id="buildBloscSupport"></a>
Blosc Support</h2>
<p>Blosc is an optional dependency of all OpenVDB components. The documented build steps below treat blosc as a required dependency. There are two reasons for this:</p>
<ul>
<li>Blosc produces significantly smaller <code>.vdb</code> files</li>
<li>If Blosc is disabled, you will not be able to read or use any <code>.vdb</code> files that were created using blosc compression. This includes OpenVDB files from Houdini.</li>
</ul>
<h2><a class="anchor" id="buildZLibSupport"></a>
ZLIB Support</h2>
<p>ZLIB is an optional dependency of all OpenVDB components. The documented build steps below treat ZLib as a required dependency.</p>
<p>You can disable ZLib using <code>-D USE_ZLIB=OFF</code> if Blosc is also disabled using <code>-D USE_BLOSC=OFF</code>.</p>
<h2><a class="anchor" id="buildVCPKG"></a>
Building Dependencies using VCPKG</h2>
<p>It is recommended to set the VCPKG_DEFAULT_TRIPLET=x64-windows environment variable to use 64-bit libraries by default as even on a 64-bit Windows OS, VCPKG builds and installs 32-bit libraries by default.</p>
<h1><a class="anchor" id="buildComponents"></a>
OpenVDB Components</h1>
<p>The following table lists all targets (mainly library and binary components) which can be built through the CMake build system. They can be set when using CMake from the command line with <code>-D VAR=ON/OFF</code> or with a CMake gui:</p>
<table class="doxtable">
<tr>
<th>Component </th><th>Description </th><th>CMake Variable </th><th>Default  </th></tr>
<tr>
<td>OpenVDB Core Library </td><td>The Core OpenVDB shared/static library </td><td>OPENVDB_BUILD_CORE </td><td>ON </td></tr>
<tr>
<td>OpenVDB Print </td><td>Command line binary for displaying information about OpenVDB files </td><td>OPENVDB_BUILD_BINARIES / OPENVDB_BUILD_VDB_PRINT </td><td>ON / ON </td></tr>
<tr>
<td>OpenVDB LOD </td><td>Command line binary for generating volume mipmaps from an OpenVDB grid </td><td>OPENVDB_BUILD_BINARIES / OPENVDB_BUILD_VDB_LOD </td><td>ON / OFF </td></tr>
<tr>
<td>OpenVDB Render </td><td>Command line binary for ray-tracing OpenVDB grids </td><td>OPENVDB_BUILD_BINARIES / OPENVDB_BUILD_VDB_RENDER </td><td>ON / OFF </td></tr>
<tr>
<td>OpenVDB View </td><td>Command line binary for displaying OpenVDB grids in a GL viewport </td><td>OPENVDB_BUILD_BINARIES / OPENVDB_BUILD_VDB_VIEW </td><td>ON / OFF </td></tr>
<tr>
<td>OpenVDB Python </td><td>Python module for OpenVDB C++ Python bindings </td><td>OPENVDB_BUILD_PYTHON_MODULE </td><td>OFF </td></tr>
<tr>
<td>OpenVDB UnitTests </td><td>OpenVDB's Unit Test suite </td><td>OPENVDB_BUILD_UNITTESTS </td><td>OFF </td></tr>
<tr>
<td>OpenVDB Houdini Plugin </td><td>The OpenVDB Houdini shared library and OpenVDB Nodes </td><td>OPENVDB_BUILD_HOUDINI_PLUGIN </td><td>OFF </td></tr>
<tr>
<td>OpenVDB Maya Plugin </td><td>The Maya OpenVDB Nodes </td><td>OPENVDB_BUILD_MAYA_PLUGIN </td><td>OFF </td></tr>
<tr>
<td>OpenVDB AX Library </td><td>The OpenVDB AX library </td><td>OPENVDB_BUILD_AX </td><td>OFF </td></tr>
<tr>
<td>OpenVDB AX Binary </td><td>Command line binary for running OpenVDB AX code </td><td>OPENVDB_BUILD_AX_BINARIES </td><td>OFF </td></tr>
<tr>
<td>OpenVDB AX Grammar </td><td>Allows for re-generation of AX grammar, typically not required </td><td>OPENVDB_BUILD_AX_GRAMMAR </td><td>OFF </td></tr>
<tr>
<td>OpenVDB AX Unit Tests </td><td>OpenVDB AX's Unit Test suite </td><td>OPENVDB_BUILD_AX_UNITTESTS </td><td>OFF </td></tr>
<tr>
<td>Documentation </td><td>The OpenVDB doxygen documentation </td><td>OPENVDB_BUILD_DOCS </td><td>OFF </td></tr>
</table>
<h1><a class="anchor" id="buildGuide"></a>
Building With CMake</h1>
<h2><a class="anchor" id="buildBuildTypes"></a>
Build Types</h2>
<p>The first step is to decide what type of OpenVDB build you're after. This primarily boils down to three main options:</p>
<ul>
<li>A standalone OpenVDB build (no Houdini/Maya plugins)</li>
<li>OpenVDB for <a href="https://www.sidefx.com/">Houdini</a></li>
<li>OpenVDB for <a href="https://www.autodesk.co.uk/products/maya/overview">Maya</a></li>
</ul>
<p>Each option provides various benefits. Apart from the support for either the Houdini or Maya OpenVDB plugins, the latter two options can make it easier for new users to install the range of OpenVDB dependencies without having to worry about using a package manager or manually installing for source. You'll still be able to build and use all components of OpenVDB with these methods. However depending on the DCC (Digital Content Creation) software's version, you may find that some features of the Core library are restricted to ensure compatibility. For more information of building OpenVDB against a Houdini or Maya installation, see <a class="el" href="build.html#buildBuildHouMaya">here</a>.</p>
<p>Developers may wish to build a standalone version of OpenVDB to take advantage of newer dependencies and newer library features. See <a class="el" href="build.html#buildBuildStandalone">here</a> for more information.</p>
<p><b>Note:</b> Blosc and ZLib are treated as required dependencies in these install instructions. See the <a class="el" href="build.html#buildBloscSupport">blosc support</a> and <a class="el" href="build.html#buildZLibSupport">zlib support</a> sections for more information.</p>
<h2><a class="anchor" id="buildBuildHouMaya"></a>
Building Against Houdini/Maya</h2>
<p>Building against a DCC reduces the list of dependencies you need to provide. You should not mix between Houdini and Maya libraries and should not attempt to build the Maya plugin using Houdini libraries and vice-versa. Additionally, it's a good idea to read the above section on <a class="el" href="build.html#buildMixingDepInstalls">mixing dependency installations</a>.</p>
<table class="doxtable">
<tr>
<th>DCC </th><th>Supported Version </th><th>OpenVDB ABI  </th></tr>
<tr>
<td>Houdini </td><td>18.0 </td><td>6 </td></tr>
<tr>
<td>Houdini </td><td>18.5 </td><td>7 </td></tr>
<tr>
<td>Maya </td><td>2017 </td><td>Any </td></tr>
<tr>
<td>Maya </td><td>2018 </td><td>Any </td></tr>
<tr>
<td>Maya </td><td>2019 </td><td>Any </td></tr>
</table>
<h2><a class="anchor" id="buildBuildHou"></a>
Building Against Houdini</h2>
<p>Houdini ships with a number of libraries that OpenVDB requires. When downloading Houdini, take note of the file version information. The version you install will determine the compiler version you should try and use to build OpenVDB. For example, for <b>Linux</b> Houdini 17.5, with a file name of <code>houdini-17.5.219-linux_x86_64_gcc6.3.tar.gz</code>, GCC 6.3 should be used. You will need to install some of the following dependencies depending on which OpenVDB components you wish to build.</p>
<table class="doxtable">
<tr>
<th>Package </th><th>Description </th><th>OpenVDB Components  </th></tr>
<tr>
<td>CMake </td><td>Cross-platform family of tools designed to help build software </td><td>All </td></tr>
<tr>
<td>C++14 Compiler </td><td>Matching Houdini compiler and version </td><td>All </td></tr>
<tr>
<td>Boost </td><td>Components: system, iostreams, python, thread </td><td>All </td></tr>
<tr>
<td>GoogleTest </td><td>A unit testing framework module for C++ </td><td>Unit Tests </td></tr>
<tr>
<td>CppUnit </td><td>A unit testing framework module for C++ </td><td>Unit Tests (AX) </td></tr>
<tr>
<td>GLFW </td><td>Simple API for OpenGL development </td><td>OpenVDB View </td></tr>
<tr>
<td>Doxygen </td><td>Documentation generation from C++ </td><td>Documentation </td></tr>
<tr>
<td>Log4cplus </td><td>An optional dependency for improved OpenVDB Logging </td><td>Optional (All) </td></tr>
<tr>
<td>NumPy </td><td>Scientific computing with Python </td><td>Optional (Python) </td></tr>
<tr>
<td>LLVM </td><td>Target-independent code generation </td><td>OpenVDB AX </td></tr>
</table>
<p>At a minimum, boost, a matching C++14 compiler and CMake will be required. See the full <a class="el" href="dependencies.html">dependency list</a> for help with downloading and installing the above software. Note that as Blosc and ZLib are provided as part of the Houdini installation <code>USE_BLOSC</code> and <code>USE_ZLIB</code> should be left <code>ON</code>.</p>
<p>With the necessary dependencies installed, create and enter a directory for cmake to write to. It's generally useful to create this in the location you've extracted the OpenVDB repository. It will house CMake's generated build files.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mkdir build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd build</div></div><!-- fragment --><p>Now you can call CMake by providing the absolute or relative path to the root of the OpenVDB source tree along with the following options:</p>
<p>Required:</p>
<ul>
<li><b>Houdini_ROOT</b> =<code>/path/to/houdini/install</code> # Path to Houdini Install</li>
<li><b>USE_HOUDINI</b> =<code>ON</code> # Force all components to build against Houdini</li>
<li><b>OPENVDB_BUILD_HOUDINI_PLUGIN</b> =<code>ON</code> # Required for building the Houdini Plugin.</li>
</ul>
<p>Optional:</p>
<ul>
<li><b></b> <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html">CMAKE_INSTALL_PREFIX</a> =<code>/path/to/install/dir</code> # The location you wish to install OpenVDB to. See the link for default values.</li>
<li><b>OPENVDB_HOUDINI_INSTALL_PREFIX</b> =<code>/path/to/install/dir</code> # The location to install the Houdini plugin to. Defaults to directories defined by Houdini:<ul>
<li>Linux: <code>$ENV{HOME}/houdiniX.X</code></li>
<li>Mac: <code>$ENV{HOME}/Library/Preferences/houdini/X.X</code></li>
<li>Windows: <code>$ENV{HOMEDRIVE}$ENV{HOMEPATH}\Documents\houdiniX.X</code></li>
</ul>
</li>
<li><b>USE_DEFAULT_HOUDINI_INSTALL</b> =<code>ON</code> # Use the above default locations if <b>OPENVDB_HOUDINI_INSTALL_PREFIX</b> is not specified. If <code>OFF</code>, uses the value of <b>CMAKE_INSTALL_PREFIX</b>.</li>
<li><b>BOOST_ROOT</b> =<code>/path/to/boost/install</code> # Path to boost. May not be required, CMake may find it automatically</li>
</ul>
<p>For example on MacOS and where the build folder has been created inside the OpenVDB source root:</p>
<div class="fragment"><div class="line">cmake -D BOOST_ROOT=/path/to/boost/install \</div><div class="line">      -D Houdini_ROOT=/Applications/Houdini/Houdini17.0.506/ \</div><div class="line">      -D USE_HOUDINI=ON \</div><div class="line">      ../</div></div><!-- fragment --><p>After the CMake build files have been successfully generated, run the build tool within the build directory to compile the project. On UNIX, you can typically incoke <code>make</code> directly: </p><div class="fragment"><div class="line">make -j4</div></div><!-- fragment --><p>Where the value of the <code>j</code> argument is the number of CPU threads to use for a multi-threaded build. On Windows, you can leverage CMake's build tool to invoke the selected builder (usually msbuild): </p><div class="fragment"><div class="line">cmake --build .</div></div><!-- fragment --><p>Finally, once a successful build has completed, you can install all files. </p><div class="fragment"><div class="line">cmake --build . --target install   # or simply `make install`</div></div><!-- fragment --><p>See the <a class="el" href="build.html#buildTroubleshooting">troubleshooting</a> section for help with CMake and Make errors.</p>
<h2><a class="anchor" id="buildBuildMaya"></a>
Building Against Maya</h2>
<p>Supported versions of maya only ship with TBB.</p>
<table class="doxtable">
<tr>
<th>Package </th><th>Description </th><th>OpenVDB Components  </th></tr>
<tr>
<td>CMake </td><td>Cross-platform family of tools designed to help build software </td><td>All </td></tr>
<tr>
<td>C++14 Compiler </td><td>Matching Houdini compiler and version </td><td>All </td></tr>
<tr>
<td>Boost </td><td>Components: system, iostreams, python, thread </td><td>All </td></tr>
<tr>
<td>ZLIB </td><td>Compression library for disk serialization compression </td><td>All </td></tr>
<tr>
<td>Blosc </td><td>Recommended dependency for improved disk compression </td><td>All* </td></tr>
<tr>
<td>GoogleTest </td><td>A unit testing framework module for C++ </td><td>Unit Tests </td></tr>
<tr>
<td>CppUnit </td><td>A unit testing framework module for C++ </td><td>Unit Tests (AX) </td></tr>
<tr>
<td>GLFW </td><td>Simple API for OpenGL development </td><td>OpenVDB View </td></tr>
<tr>
<td>Doxygen </td><td>Documentation generation from C++ </td><td>Documentation </td></tr>
<tr>
<td>OpenEXR </td><td>EXR serialization support </td><td>OpenVDB Render </td></tr>
<tr>
<td>IlmBase </td><td>Used half precision floating points and EXR serialization support </td><td>Optional (All) </td></tr>
<tr>
<td>Log4cplus </td><td>An optional dependency for improved OpenVDB Logging </td><td>Optional (All) </td></tr>
<tr>
<td>NumPy </td><td>Scientific computing with Python </td><td>Optional (Python) </td></tr>
<tr>
<td>LLVM </td><td>Target-independent code generation </td><td>OpenVDB AX </td></tr>
</table>
<p>See <a class="el" href="build.html#buildBloscSupport">blosc support</a></p>
<p>At a minimum, boost, a matching C++14 compiler, ZLIB, blosc and CMake will be required. See the full <a class="el" href="dependencies.html">dependency list</a> for help with downloading and installing the above software.</p>
<p>With the necessary dependencies installed, create and enter a directory for cmake to write to. It's generally useful to create this in the location you've extracted the OpenVDB repository. It will house CMake's generated build files.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mkdir build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd build</div></div><!-- fragment --><p>Now you can call CMake by providing the absolute or relative path to the root of the OpenVDB source tree along with the following options:</p>
<p>Required:</p>
<ul>
<li><b>Maya_ROOT</b> =<code>/path/to/maya/install</code> # Path to Maya Install</li>
<li><b>USE_MAYA</b> =<code>ON</code> # Force all components to build against Maya</li>
</ul>
<p>Optional:</p>
<ul>
<li><b></b> <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html">CMAKE_INSTALL_PREFIX</a> =<code>/path/to/install/dir</code> # The location you wish to install OpenVDB to. See the link for default values.</li>
<li><b>OPENVDB_MAYA_INSTALL_PREFIX</b> =<code>/path/to/install/dir</code> # The location to install the Maya plugin to. Defaults to the value of <code>${CMAKE_INSTALL_PREFIX}/maya${Maya_VERSION}</code></li>
<li><b>BOOST_ROOT</b> =<code>/path/to/boost/install</code> # Path to boost. May not be required, CMake may find it automatically</li>
<li><b>IlmBase_ROOT</b> =<code>/path/to/ilmbase/install</code> # Path to ilmbase.</li>
</ul>
<p>For example on MacOS and where the build folder has been created inside the OpenVDB source root:</p>
<div class="fragment"><div class="line">cmake -D BOOST_ROOT=/path/to/boost/install \</div><div class="line">      -D IlmBase_ROOT=/path/to/ilmbase/install \</div><div class="line">      -D Maya_ROOT=/Applications/Autodesk/maya2019/ \</div><div class="line">      -D USE_MAYA=ON \</div><div class="line">      ../</div></div><!-- fragment --><p>As the Maya plugin is disabled by default, you may also want to add <code>-D OPENVDB_BUILD_MAYA_PLUGIN=ON</code> to the command. The <a class="el" href="build.html#buildComponents">components</a> section shows which targets are enabled by default.</p>
<p>After the CMake build files have been successfully generated, run the build tool within the build directory to compile the project. On UNIX, you can typically incoke <code>make</code> directly: </p><div class="fragment"><div class="line">make -j4</div></div><!-- fragment --><p>Where the value of the <code>j</code> argument is the number of CPU threads to use for a multi-threaded build. On Windows, you can leverage CMake's build tool to invoke the selected builder (usually msbuild): </p><div class="fragment"><div class="line">cmake --build .</div></div><!-- fragment --><p>Finally, once a successful build has completed, you can install all files. </p><div class="fragment"><div class="line">cmake --build . --target install   # or simply `make install`</div></div><!-- fragment --><p><b>Note:</b> The Maya OpenVDB Visualize Node is <b>only</b> compatible with Legacy OpenGL support. You can enable this in Maya by navigating to <code>Windows-&gt;Settings/Preferences-&gt;Preferences-&gt;Display</code> and changing <code>Rendering Engine</code> to OpenGL - Legacy.</p>
<p>See the <a class="el" href="build.html#buildTroubleshooting">troubleshooting</a> section for help with CMake and Make errors.</p>
<h2><a class="anchor" id="buildBuildStandalone"></a>
Building Standalone</h2>
<p>It's recommended you first visit the <a class="el" href="dependencies.html">dependency list page</a> before attempting to run CMake on a standalone build. With the necessary dependencies installed, create and enter a directory for cmake to write to. It's generally useful to create this in the location you've extracted the OpenVDB repository. It will house CMake's generated build files.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;mkdir build</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;cd build</div></div><!-- fragment --><p>Now you can call CMake by providing the absolute or relative path to the root of the OpenVDB source tree. Below are some common options you may want to provide:</p>
<ul>
<li><b></b> <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_INSTALL_PREFIX.html">CMAKE_INSTALL_PREFIX</a> =<code>/path/to/install/dir</code> # The location you wish to install OpenVDB to. See the link for default values.</li>
<li><b>Xxx_ROOT</b> =<code>/path/to/Xxx/</code> # Give CMake a path to where a package has been installed or simply to where your prefered package is installed if it cannot locate it.</li>
</ul>
<p>For example, a typical first attempt at generating the build files may look as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cmake -D CMAKE_INSTALL_PREFIX=$HOME/openvdb ../</div></div><!-- fragment --><p>See the <a class="el" href="build.html#buildComponents">components</a> section to find which targets are available, their corresponding CMake flags and their default values.</p>
<p>After the CMake build files have been successfully generated, run the build tool within the build directory to compile the project. On UNIX, you can typically incoke <code>make</code> directly: </p><div class="fragment"><div class="line">make -j4</div></div><!-- fragment --><p>Where the value of the <code>j</code> argument is the number of CPU threads to use for a multi-threaded build. On Windows, you can leverage CMake's build tool to invoke the selected builder (usually msbuild): </p><div class="fragment"><div class="line">cmake --build .</div></div><!-- fragment --><p>Finally, once a successful build has completed, you can install all files. </p><div class="fragment"><div class="line">cmake --build . --target install   # or simply `make install`</div></div><!-- fragment --><p>See the <a class="el" href="build.html#buildTroubleshooting">troubleshooting</a> section for help with CMake and Make errors.</p>
<h1><a class="anchor" id="buildUsingOpenVDB"></a>
Building With OpenVDB</h1>
<p>This section is for users wishing to use a build of OpenVDB in their own applications with CMake.</p>
<p>The following assumes that OpenVDB was installed with <code>OPENVDB_BUILD_CORE=ON</code> and <code>OPENVDB_INSTALL_CMAKE_MODULES=ON</code>. Don't worry if you didn't specify these options directly, they both default to <code>ON</code>. This ensures that OpenVDB has installed the required CMake modules that your application will need to use.</p>
<p><b>Note:</b> Typically, projects provide a <b>Config-file</b> rather than a <b>Find-module</b> for downstream use. OpenVDB currently provides a <b>Find-module</b>. This may change in the future. Further information <a href="https://cmake.org/cmake/help/latest/manual/cmake-packages.7.html#using-packages">here</a>.</p>
<p>You can add the below CMake snippet to your main <code>CMakeLists.txt</code> to bring in OpenVDB as a dependency:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cmake_minimum_required(VERSION 3.12)</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;list(APPEND CMAKE_MODULE_PATH &quot;/location/of/openvdb/install/lib/cmake/OpenVDB&quot;)</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;find_package(OpenVDB REQUIRED)</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;target_link_libraries(myapp OpenVDB::openvdb)</div></div><!-- fragment --><p><code>myapp</code> in the above is a CMake target, usually created with <code>add_library()</code> or <code>add_executable()</code>. You can optionally provide <code>CMAKE_MODULE_PATH</code> as a <code>-D</code> argument to the cmake command line instead of specifying it in your <code>CMakeLists.txt</code>.</p>
<p>Note that the <code>FindOpenVDB.cmake</code> module relies on the other <code>FindModules</code> provided in the OpenVDB installation to find it's own dependencies. This may require you to provide additional dependency locations for OpenVDB's dependencies. See <a class="el" href="build.html#buildDependencies">Locating Dependencies</a> or the below troubleshooting for more information. </p><hr/>
<h1><a class="anchor" id="buildTroubleshooting"></a>
Troubleshooting</h1>
<p>If after reading this guide you're unable to find your specific issue below, please get in touch or <a href="https://github.com/AcademySoftwareFoundation/openvdb/issues">file an issue</a> with the OpenVDB TSC.</p>
<p><b>Note:</b> If running into issues when changing CMake settings/dependency paths, try clearing the designated CMake build directory and running your <code>cmake</code> command again.</p>
<h2><a class="anchor" id="troubleshoot1"></a>
CMake Error ... Could NOT find XXX (missing: ... )</h2>
<p>It's fairly typical that CMake may fail to find some dependencies on first runs, especially if you've manually compiled from source your own dependencies. Analyzing any dependency errors will help with running further invocations of cmake. The <a class="el" href="build.html#buildDependencies">Locating Dependencies</a> section details the variable format required to point CMake to the correct locations. Alternatively, with interactive cmake systems such as <code>ccmake</code> or CMake GUI, variables which are not found will be shown, allowing you to provide them directly.</p>
<p>As an example, earlier versions of <a href="https://www.threadingbuildingblocks.org/">Threading Building Blocks (TBB)</a> do not come with CMake modules or <a href="https://www.freedesktop.org/wiki/Software/pkg-config/">pkg-config</a> modules. For OpenVDB to locate TBB, you typically need to provide this location manually:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cmake -D CMAKE_INSTALL_PREFIX=$HOME/openvdb -D TBB_ROOT=/path/to/tbb/install ../</div></div><!-- fragment --><p>Note that this is also equivalent to:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;cmake -D CMAKE_INSTALL_PREFIX=$HOME/openvdb \</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    -D TBB_INCLUDEDIR=/path/to/tbb/install/include \</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    -D TBB_LIBRARYDIR=/path/to/tbb/install/lib \</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;    ../</div></div><!-- fragment --><h2><a class="anchor" id="troubleshoot2"></a>
CMake Error ... Could NOT find XXX (Found unsuitable version: ... )</h2>
<p>By default, OpenVDB sets a number of minimum version requires for its dependencies. These can be found in the root CMakeList.txt or in the <a class="el" href="dependencies.html">dependency table</a>. These minimum versions either track the oldest supported <a href="https://www.vfxplatform.com/">VFX Reference Platform</a> or are otherwise required for compatibility. Although not recommended, you can bypass these checks with <code>-D DISABLE_DEPENDENCY_VERSION_CHECKS=ON</code> if necessary. Note that using older or untested dependencies may produce undesired behavior. Older versions in particular are not supported by OpenVDB.</p>
<p><b>Note:</b> Boost will produce a version error in the format <code>Detected version of Boost is too old.</code></p>
<h2><a class="anchor" id="troubleshoot3"></a>
CMake warnings/errors in FindBoost.cmake</h2>
<p>There are a variety of potential warnings and errors that may arise from the version compatibility of Boost and CMake. These are related to how both Boost and CMake have historically been kept in sync. A common warning and error combination is:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;CMake Warning at ...  Imported targets not available for Boost version XXXXXX</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;...</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;Target &quot;...&quot; links to target &quot;Boost::XXX&quot; but the target</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;was not found.  Perhaps a find_package() call is missing for an IMPORTED</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;target, or an ALIAS target is missing?</div></div><!-- fragment --><p>OpenVDB uses <a href="https://cmake.org/cmake/help/latest/command/add_library.html#imported-libraries">imported targets</a> for all its dependencies. For imported Boost compatibility, the following versions of CMake are required:</p>
<ul>
<li>Boost 1.68, 1.69 require CMake 3.13 or newer.</li>
<li>Boost 1.70 requires CMake 3.14 or newer.</li>
</ul>
<p>Use the above list to identify the version of CMake you require for your version of Boost. Note that this may be implemented into the OpenVDB CMake in the future.</p>
<h2><a class="anchor" id="troubleshoot4"></a>
Detected VCPKG toolchain is using a mismatching triplet for OpenVDB build artifacts</h2>
<p>If you are on Windows and using vcpkg, builds of OpenVDB should usually only build the static OR shared library depending on your vcpkg triplet. This is related to how libraries link against the Windows CRT. In vcpkg, static triplets, such as <b>x64-windows-static</b>, will use the <b>MultiThreaded</b> (/MT) flag and dynamic triplets, such as <b>x64-windows</b>, will use the <b>MultiThreadedDLL</b> (/MD) flag. These flags <b>must</b> match throughout all software artifacts in your toolchain (regardless if you are using vcpkg or not).</p>
<p>This warning is shown when OpenVDB detects you using either a dynamic or static VCPKG toolchain on Windows, but have the opposite core library variant enabled. By default, the static build of OpenVDB links against the <b>MultiThreaded</b> (/MT) CRT and the dynamic library links against the <b>MultiThreadedDLL</b> (/MD) CRT. As OpenVDB configures both by default, it is typical that you may want to disable one or the other depending on your needs.</p>
<p>Note that you can provide a value for <code>CMAKE_MSVC_RUNTIME_LIBRARY</code> which is a native CMake variable to override any CRT selection done by OpenVDB.</p>
<p>For more information, see the following articles: Description of CRT selection: <a href="https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library">https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library</a> In depth descriptopn of the CRT on Windows: <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features">https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features</a> Related errors: <a href="https://docs.microsoft.com/en-us/cpp/error-messages/tool-errors/linker-tools-error-lnk2038">https://docs.microsoft.com/en-us/cpp/error-messages/tool-errors/linker-tools-error-lnk2038</a> <code>CMAKE_MSVC_RUNTIME_LIBRARY</code> docs: <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_MSVC_RUNTIME_LIBRARY.html">https://cmake.org/cmake/help/latest/variable/CMAKE_MSVC_RUNTIME_LIBRARY.html</a></p>
<h2><a class="anchor" id="troubleshoot5"></a>
Unexpected value for the Windows CRT with target build artifacts.</h2>
<p>On Windows, it is typical for static builds to link to static libraries and dynamic builds to link to dynamic library variants. This is not related to the libraries themselves, rather it is due to the way that all libraries used within a specific toolchain must use the same version of the CRT. The rule of thumb is to configure static builds against the static CRT and dynamic builds against the dynamic CRT.</p>
<p>This warning is shown if you have provided a value for the CMake variable <code>CMAKE_MSVC_RUNTIME_LIBRARY</code>, but this value is the opposite of what's expected for a target library.</p>
<p>Note that there are some cases where it makes sense to link static builds of OpenVDB against the dynamic (/MD) CRT. However, unless you are confident in your usage, it is strongly encouraged to match the selection against your desired build type.</p>
<p>For more information, see the following articles: Description of CRT selection: <a href="https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library">https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library</a> In depth descriptopn of the CRT on Windows: <a href="https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features">https://docs.microsoft.com/en-us/cpp/c-runtime-library/crt-library-features</a> Related errors: <a href="https://docs.microsoft.com/en-us/cpp/error-messages/tool-errors/linker-tools-error-lnk2038">https://docs.microsoft.com/en-us/cpp/error-messages/tool-errors/linker-tools-error-lnk2038</a> <code>CMAKE_MSVC_RUNTIME_LIBRARY</code> docs: <a href="https://cmake.org/cmake/help/latest/variable/CMAKE_MSVC_RUNTIME_LIBRARY.html">https://cmake.org/cmake/help/latest/variable/CMAKE_MSVC_RUNTIME_LIBRARY.html</a></p>
<h2><a class="anchor" id="troubleshoot6"></a>
error LNK2038: mismatch detected for 'RuntimeLibrary'</h2>
<p>A build artifact of OpenVDB has been linked against a dependency which uses a different version of the Window CRT. See the <a class="el" href="build.html#troubleshoot5">above section</a> on dealing with CRT selection for static and dynamic library builds on Windows. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
