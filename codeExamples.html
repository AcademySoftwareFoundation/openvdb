<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>OpenVDB: OpenVDB Cookbook</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenVDB
   &#160;<span id="projectnumber">8.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">OpenVDB</a></li><li class="navelem"><a class="el" href="faq.html">Frequently Asked Questions</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">OpenVDB Cookbook </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This section provides code snippets and some complete programs that illustrate how to use OpenVDB and how to perform common tasks.</p>
<h1><a class="anchor" id="sCookbookContents"></a>
Contents</h1>
<ul>
<li><a class="el" href="codeExamples.html#sHelloWorld">&ldquo;Hello, World&rdquo; for OpenVDB</a></li>
<li><a class="el" href="codeExamples.html#sAllocatingGrids">Creating and writing a grid</a></li>
<li><a class="el" href="codeExamples.html#sPopulatingGrids">Populating a grid with values</a></li>
<li><a class="el" href="codeExamples.html#sModifyingGrids">Reading and modifying a grid</a></li>
<li><a class="el" href="codeExamples.html#sStreamIO">Stream I/O</a></li>
<li><a class="el" href="codeExamples.html#sHandlingMetadata">Handling metadata</a><ul>
<li><a class="el" href="codeExamples.html#sAddingMetadata">Adding metadata</a></li>
<li><a class="el" href="codeExamples.html#sGettingMetadata">Retrieving metadata</a></li>
<li><a class="el" href="codeExamples.html#sRemovingMetadata">Removing metadata</a></li>
</ul>
</li>
<li><a class="el" href="codeExamples.html#sIteration">Iteration</a><ul>
<li><a class="el" href="codeExamples.html#sNodeIterator">Node Iterator</a></li>
<li><a class="el" href="codeExamples.html#sLeafIterator">Leaf Node Iterator</a></li>
<li><a class="el" href="codeExamples.html#sValueIterator">Value Iterator</a></li>
<li><a class="el" href="codeExamples.html#sIteratorRange">Iterator Range</a></li>
</ul>
</li>
<li><a class="el" href="codeExamples.html#sInterpolation">Interpolation of grid values</a><ul>
<li><a class="el" href="codeExamples.html#sSamplers">Index-space samplers</a></li>
<li><a class="el" href="codeExamples.html#sGridSampler">Grid Sampler</a></li>
<li><a class="el" href="codeExamples.html#sDualGridSampler">Dual Grid Sampler</a></li>
</ul>
</li>
<li><a class="el" href="codeExamples.html#sXformTools">Transforming grids</a><ul>
<li><a class="el" href="codeExamples.html#sResamplingTools">Geometric transformation</a></li>
<li><a class="el" href="codeExamples.html#sValueXformTools">Value transformation</a></li>
</ul>
</li>
<li><a class="el" href="codeExamples.html#sCombiningGrids">Combining grids</a><ul>
<li><a class="el" href="codeExamples.html#sCsgTools">Level set CSG operations</a></li>
<li><a class="el" href="codeExamples.html#sCompTools">Compositing operations</a></li>
<li><a class="el" href="codeExamples.html#sCombineTools">Generic combination</a></li>
</ul>
</li>
<li><a class="el" href="codeExamples.html#sGenericProg">Generic programming</a><ul>
<li><a class="el" href="codeExamples.html#sTypedGridMethods">Calling Grid methods</a></li>
</ul>
</li>
<li><a class="el" href="codeExamples.html#sPointsHelloWorld">&ldquo;Hello, World&rdquo; for OpenVDB Points</a></li>
<li><a class="el" href="codeExamples.html#sPointsConversion">Converting Point Attributes</a></li>
<li><a class="el" href="codeExamples.html#sPointsGeneration">Random Point Generation</a></li>
<li><a class="el" href="codeExamples.html#sPointIterationFiltering">Point Iteration, Groups and Filtering</a><ul>
<li><a class="el" href="codeExamples.html#sPointIteration">Point Iteration</a></li>
<li><a class="el" href="codeExamples.html#sPointGroups">Creating and Assigning Point Groups</a></li>
<li><a class="el" href="codeExamples.html#sPointFiltering">Point Filtering using Groups</a></li>
<li><a class="el" href="codeExamples.html#sPointCustomFiltering">Point Filtering using Custom Filters</a></li>
</ul>
</li>
<li><a class="el" href="codeExamples.html#sPointStride">Strided Point Attributes</a><ul>
<li><a class="el" href="codeExamples.html#sConstantStride">Constant Stride Attributes</a></li>
</ul>
</li>
<li><a class="el" href="codeExamples.html#sPointMove">Moving Points in Space</a><ul>
<li><a class="el" href="codeExamples.html#sPointAdvect">Advecting Points</a></li>
<li><a class="el" href="codeExamples.html#sPointCustomDeformer">Moving Points with a Custom Deformer</a></li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="sHelloWorld"></a>
“Hello, World” for OpenVDB</h1>
<p>This is a very simple example showing how to create a grid and access its voxels. OpenVDB supports both random access to voxels by coordinates and sequential access by means of iterators. This example illustrates both types of access: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// Initialize the OpenVDB library.  This must be called at least</span></div><div class="line">    <span class="comment">// once per program and may safely be called multiple times.</span></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a446befa7deee56e243fee79c37263eaa">openvdb::initialize</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Create an empty floating-point grid with background value 0.</span></div><div class="line">    <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> grid = <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afed9748b2280ee9155aa1033cc583bc7">openvdb::FloatGrid::create</a>();</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Testing random access:&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Get an accessor for coordinate-based access to voxels.</span></div><div class="line">    <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#a52aaec5921d1852ab1d33a064f1d13eb">openvdb::FloatGrid::Accessor</a> accessor = grid-&gt;getAccessor();</div><div class="line"></div><div class="line">    <span class="comment">// Define a coordinate with large signed indices.</span></div><div class="line">    openvdb::Coord xyz(1000, -200000000, 30000000);</div><div class="line"></div><div class="line">    <span class="comment">// Set the voxel value at (1000, -200000000, 30000000) to 1.</span></div><div class="line">    accessor.setValue(xyz, 1.0);</div><div class="line"></div><div class="line">    <span class="comment">// Verify that the voxel value at (1000, -200000000, 30000000) is 1.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Grid&quot;</span> &lt;&lt; xyz &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; accessor.getValue(xyz) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Reset the coordinates to those of a different voxel.</span></div><div class="line">    xyz.reset(1000, 200000000, -30000000);</div><div class="line"></div><div class="line">    <span class="comment">// Verify that the voxel value at (1000, 200000000, -30000000) is</span></div><div class="line">    <span class="comment">// the background value, 0.</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Grid&quot;</span> &lt;&lt; xyz &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; accessor.getValue(xyz) &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Set the voxel value at (1000, 200000000, -30000000) to 2.</span></div><div class="line">    accessor.setValue(xyz, 2.0);</div><div class="line"></div><div class="line">    <span class="comment">// Set the voxels at the two extremes of the available coordinate space.</span></div><div class="line">    <span class="comment">// For 32-bit signed coordinates these are (-2147483648, -2147483648, -2147483648)</span></div><div class="line">    <span class="comment">// and (2147483647, 2147483647, 2147483647).</span></div><div class="line">    accessor.setValue(<a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools_1_1composite.html#acd26c9d63364141f1b222bb2f7d08a02">openvdb::Coord::min</a>(), 3.0f);</div><div class="line">    accessor.setValue(<a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools_1_1composite.html#a5f16766bff85d9c17429a43bd490343c">openvdb::Coord::max</a>(), 4.0f);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Testing sequential access:&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Print all active (&quot;on&quot;) voxels by means of an iterator.</span></div><div class="line">    <span class="keywordflow">for</span> (<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">openvdb::FloatGrid::ValueOnCIter</a> iter = grid-&gt;cbeginValueOn(); iter; ++iter) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Grid&quot;</span> &lt;&lt; iter.getCoord() &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; *iter &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><div class="fragment"><div class="line">Testing random access:</div><div class="line"><a class="code" href="namespaceopenvdb__houdini.html#ab68e398333046373641f36c9d3ba33d0">Grid</a>[1000, -200000000, 30000000] = 1</div><div class="line"><a class="code" href="namespaceopenvdb__houdini.html#ab68e398333046373641f36c9d3ba33d0">Grid</a>[1000, 200000000, -30000000] = 0</div><div class="line">Testing sequential access:</div><div class="line"><a class="code" href="namespaceopenvdb__houdini.html#ab68e398333046373641f36c9d3ba33d0">Grid</a>[-2147483648, -2147483648, -2147483648] = 3</div><div class="line"><a class="code" href="namespaceopenvdb__houdini.html#ab68e398333046373641f36c9d3ba33d0">Grid</a>[1000, -200000000, 30000000] = 1</div><div class="line"><a class="code" href="namespaceopenvdb__houdini.html#ab68e398333046373641f36c9d3ba33d0">Grid</a>[1000, 200000000, -30000000] = 2</div><div class="line"><a class="code" href="namespaceopenvdb__houdini.html#ab68e398333046373641f36c9d3ba33d0">Grid</a>[2147483647, 2147483647, 2147483647] = 4</div></div><!-- fragment --><h1><a class="anchor" id="sAllocatingGrids"></a>
Creating and writing a grid</h1>
<p>This example is a complete program that illustrates some of the basic steps to create grids and write them to disk. (See <a class="el" href="codeExamples.html#sPopulatingGrids">Populating a grid with values</a>, below, for the implementation of the <b>makeSphere</b> function.) </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a446befa7deee56e243fee79c37263eaa">openvdb::initialize</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Create a shared pointer to a newly-allocated grid of a built-in type:</span></div><div class="line">    <span class="comment">// in this case, a FloatGrid, which stores one single-precision floating point</span></div><div class="line">    <span class="comment">// value per voxel.  Other built-in grid types include BoolGrid, DoubleGrid,</span></div><div class="line">    <span class="comment">// Int32Grid and Vec3SGrid (see openvdb.h for the complete list).</span></div><div class="line">    <span class="comment">// The grid comprises a sparse tree representation of voxel data,</span></div><div class="line">    <span class="comment">// user-supplied metadata and a voxel space to world space transform,</span></div><div class="line">    <span class="comment">// which defaults to the identity transform.</span></div><div class="line">    <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> grid =</div><div class="line">        <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afed9748b2280ee9155aa1033cc583bc7">openvdb::FloatGrid::create</a>(<span class="comment">/*background value=*/</span>2.0);</div><div class="line"></div><div class="line">    <span class="comment">// Populate the grid with a sparse, narrow-band level set representation</span></div><div class="line">    <span class="comment">// of a sphere with radius 50 voxels, located at (1.5, 2, 3) in index space.</span></div><div class="line">    makeSphere(*grid, <span class="comment">/*radius=*/</span>50.0, <span class="comment">/*center=*/</span><a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3f</a>(1.5, 2, 3));</div><div class="line"></div><div class="line">    <span class="comment">// Associate some metadata with the grid.</span></div><div class="line">    grid-&gt;insertMeta(<span class="stringliteral">&quot;radius&quot;</span>, <a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html">openvdb::FloatMetadata</a>(50.0));</div><div class="line"></div><div class="line">    <span class="comment">// Associate a scaling transform with the grid that sets the voxel size</span></div><div class="line">    <span class="comment">// to 0.5 units in world space.</span></div><div class="line">    grid-&gt;setTransform(</div><div class="line">        openvdb::math::Transform::createLinearTransform(<span class="comment">/*voxel size=*/</span>0.5));</div><div class="line"></div><div class="line">    <span class="comment">// Identify the grid as a level set.</span></div><div class="line">    grid-&gt;setGridClass(<a class="code" href="namespaceopenvdb_1_1v8__1.html#a511a7f5bd868162ec06bcc20b98e160eac12b83a53c9998ec7823ba0ac9c1521d">openvdb::GRID_LEVEL_SET</a>);</div><div class="line"></div><div class="line">    <span class="comment">// Name the grid &quot;LevelSetSphere&quot;.</span></div><div class="line">    grid-&gt;setName(<span class="stringliteral">&quot;LevelSetSphere&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Create a VDB file object.</span></div><div class="line">    openvdb::io::File file(<span class="stringliteral">&quot;mygrids.vdb&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Add the grid pointer to a container.</span></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a0c9703e6ff5cc9deb6410c53412c22c3">openvdb::GridPtrVec</a> grids;</div><div class="line">    grids.push_back(grid);</div><div class="line"></div><div class="line">    <span class="comment">// Write out the contents of the container.</span></div><div class="line">    file.write(grids);</div><div class="line">    file.close();</div><div class="line">}</div></div><!-- fragment --><p>The OpenVDB library includes optimized routines for many common tasks. For example, most of the steps given above are encapsulated in the function <a class="el" href="namespaceopenvdb_1_1v8__1_1_1tools.html#a47e7b3c363d0d3a15b5859c4b06e9d8b">tools::createLevelSetSphere</a>, so that the above can be written simply as follows:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="LevelSetSphere_8h.html">openvdb/tools/LevelSetSphere.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a446befa7deee56e243fee79c37263eaa">openvdb::initialize</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Create a FloatGrid and populate it with a narrow-band</span></div><div class="line">    <span class="comment">// signed distance field of a sphere.</span></div><div class="line">    <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> grid =</div><div class="line">        openvdb::tools::createLevelSetSphere&lt;openvdb::FloatGrid&gt;(</div><div class="line">            <span class="comment">/*radius=*/</span>50.0, <span class="comment">/*center=*/</span><a class="code" href="namespaceopenvdb_1_1v8__1.html#a4873ae29d5d8d4f1cb7c7717af41a993">openvdb::Vec3f</a>(1.5, 2, 3),</div><div class="line">            <span class="comment">/*voxel size=*/</span>0.5, <span class="comment">/*width=*/</span>4.0);</div><div class="line"></div><div class="line">    <span class="comment">// Associate some metadata with the grid.</span></div><div class="line">    grid-&gt;insertMeta(<span class="stringliteral">&quot;radius&quot;</span>, <a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html">openvdb::FloatMetadata</a>(50.0));</div><div class="line"></div><div class="line">    <span class="comment">// Name the grid &quot;LevelSetSphere&quot;.</span></div><div class="line">    grid-&gt;setName(<span class="stringliteral">&quot;LevelSetSphere&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Create a VDB file object and write out the grid.</span></div><div class="line">    openvdb::io::File(<span class="stringliteral">&quot;mygrids.vdb&quot;</span>).write({grid});</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="sPopulatingGrids"></a>
Populating a grid with values</h1>
<p>The following code is templated so as to operate on grids containing values of any scalar type, provided that the value type supports negation and comparison. Note that this algorithm is only meant as an example and should never be used in production; use the much more efficient routines in <a class="el" href="LevelSetSphere_8h.html" title="Generate a narrow-band level set of sphere. ">tools/LevelSetSphere.h</a> instead.</p>
<p>See <a class="el" href="codeExamples.html#sGenericProg">Generic programming</a> for more on processing grids of arbitrary type. <a class="anchor" id="makeSphereCode"></a></p><div class="fragment"><div class="line"><span class="comment">// Populate the given grid with a narrow-band level set representation of a sphere.</span></div><div class="line"><span class="comment">// The width of the narrow band is determined by the grid&#39;s background value.</span></div><div class="line"><span class="comment">// (Example code only; use tools::createSphereSDF() in production.)</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> Gr<span class="keywordtype">id</span>Type&gt;</div><div class="line"><span class="keywordtype">void</span></div><div class="line">makeSphere(GridType&amp; grid, <span class="keywordtype">float</span> radius, <span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3f</a>&amp; c)</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> ValueT = <span class="keyword">typename</span> GridType::ValueType;</div><div class="line"></div><div class="line">    <span class="comment">// Distance value for the constant region exterior to the narrow band</span></div><div class="line">    <span class="keyword">const</span> ValueT outside = grid.background();</div><div class="line"></div><div class="line">    <span class="comment">// Distance value for the constant region interior to the narrow band</span></div><div class="line">    <span class="comment">// (by convention, the signed distance is negative in the interior of</span></div><div class="line">    <span class="comment">// a level set)</span></div><div class="line">    <span class="keyword">const</span> ValueT inside = -outside;</div><div class="line"></div><div class="line">    <span class="comment">// Use the background value as the width in voxels of the narrow band.</span></div><div class="line">    <span class="comment">// (The narrow band is centered on the surface of the sphere, which</span></div><div class="line">    <span class="comment">// has distance 0.)</span></div><div class="line">    <span class="keywordtype">int</span> padding = int(<a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#af4f6ea9074437812788c734cb9437469">openvdb::math::RoundUp</a>(<a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a2d2329005770a7a3731a49f482d05ef6">openvdb::math::Abs</a>(outside)));</div><div class="line">    <span class="comment">// The bounding box of the narrow band is 2*dim voxels on a side.</span></div><div class="line">    <span class="keywordtype">int</span> dim = int(radius + padding);</div><div class="line"></div><div class="line">    <span class="comment">// Get a voxel accessor.</span></div><div class="line">    <span class="keyword">typename</span> GridType::Accessor accessor = grid.getAccessor();</div><div class="line"></div><div class="line">    <span class="comment">// Compute the signed distance from the surface of the sphere of each</span></div><div class="line">    <span class="comment">// voxel within the bounding box and insert the value into the grid</span></div><div class="line">    <span class="comment">// if it is smaller in magnitude than the background value.</span></div><div class="line">    openvdb::Coord ijk;</div><div class="line">    <span class="keywordtype">int</span> &amp;i = ijk[0], &amp;j = ijk[1], &amp;k = ijk[2];</div><div class="line">    <span class="keywordflow">for</span> (i = c[0] - dim; i &lt; c[0] + dim; ++i) {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">float</span> x2 = <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a243fce36009d57492cf9656754c3bdae">openvdb::math::Pow2</a>(i - c[0]);</div><div class="line">        <span class="keywordflow">for</span> (j = c[1] - dim; j &lt; c[1] + dim; ++j) {</div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">float</span> x2y2 = <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a243fce36009d57492cf9656754c3bdae">openvdb::math::Pow2</a>(j - c[1]) + x2;</div><div class="line">            <span class="keywordflow">for</span> (k = c[2] - dim; k &lt; c[2] + dim; ++k) {</div><div class="line"></div><div class="line">                <span class="comment">// The distance from the sphere surface in voxels</span></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">float</span> dist = <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a269b6a877f8af902ae74596d7fb355ae">openvdb::math::Sqrt</a>(x2y2</div><div class="line">                    + <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a243fce36009d57492cf9656754c3bdae">openvdb::math::Pow2</a>(k - c[2])) - radius;</div><div class="line"></div><div class="line">                <span class="comment">// Convert the floating-point distance to the grid&#39;s value type.</span></div><div class="line">                ValueT val = ValueT(dist);</div><div class="line"></div><div class="line">                <span class="comment">// Only insert distances that are smaller in magnitude than</span></div><div class="line">                <span class="comment">// the background value.</span></div><div class="line">                <span class="keywordflow">if</span> (val &lt; inside || outside &lt; val) <span class="keywordflow">continue</span>;</div><div class="line"></div><div class="line">                <span class="comment">// Set the distance for voxel (i,j,k).</span></div><div class="line">                accessor.setValue(ijk, val);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Propagate the outside/inside sign information from the narrow band</span></div><div class="line">    <span class="comment">// throughout the grid.</span></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ab8c1921d688e3c65c71aac5405f155a9">openvdb::tools::signedFloodFill</a>(grid.tree());</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="sModifyingGrids"></a>
Reading and modifying a grid</h1>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ChangeBackground_8h.html">openvdb/tools/ChangeBackground.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#a446befa7deee56e243fee79c37263eaa">openvdb::initialize</a>();</div><div class="line"></div><div class="line"><span class="comment">// Create a VDB file object.</span></div><div class="line">openvdb::io::File file(<span class="stringliteral">&quot;mygrids.vdb&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Open the file.  This reads the file header, but not any grids.</span></div><div class="line">file.open();</div><div class="line"></div><div class="line"><span class="comment">// Loop over all grids in the file and retrieve a shared pointer</span></div><div class="line"><span class="comment">// to the one named &quot;LevelSetSphere&quot;.  (This can also be done</span></div><div class="line"><span class="comment">// more simply by calling file.readGrid(&quot;LevelSetSphere&quot;).)</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1GridBase.html#ad98d7556003ccc2ef810f87d97159de4">openvdb::GridBase::Ptr</a> baseGrid;</div><div class="line"><span class="keywordflow">for</span> (openvdb::io::File::NameIterator nameIter = file.beginName();</div><div class="line">    nameIter != file.endName(); ++nameIter)</div><div class="line">{</div><div class="line">    <span class="comment">// Read in only the grid we are interested in.</span></div><div class="line">    <span class="keywordflow">if</span> (nameIter.gridName() == <span class="stringliteral">&quot;LevelSetSphere&quot;</span>) {</div><div class="line">        baseGrid = file.readGrid(nameIter.gridName());</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;skipping grid &quot;</span> &lt;&lt; nameIter.gridName() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">file.close();</div><div class="line"></div><div class="line"><span class="comment">// From the example above, &quot;LevelSetSphere&quot; is known to be a FloatGrid,</span></div><div class="line"><span class="comment">// so cast the generic grid pointer to a FloatGrid pointer.</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> grid = openvdb::gridPtrCast&lt;openvdb::FloatGrid&gt;(baseGrid);</div><div class="line"></div><div class="line"><span class="comment">// Convert the level set sphere to a narrow-band fog volume, in which</span></div><div class="line"><span class="comment">// interior voxels have value 1, exterior voxels have value 0, and</span></div><div class="line"><span class="comment">// narrow-band voxels have values varying linearly from 0 to 1.</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> outside = grid-&gt;background();</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">float</span> width = 2.0 * outside;</div><div class="line"></div><div class="line"><span class="comment">// Visit and update all of the grid&#39;s active values, which correspond to</span></div><div class="line"><span class="comment">// voxels on the narrow band.</span></div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#aa20792587df8cc92cff821e68e70ace7">openvdb::FloatGrid::ValueOnIter</a> iter = grid-&gt;beginValueOn(); iter; ++iter) {</div><div class="line">    <span class="keywordtype">float</span> dist = iter.getValue();</div><div class="line">    iter.setValue((outside - dist) / width);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Visit all of the grid&#39;s inactive tile and voxel values and update the values</span></div><div class="line"><span class="comment">// that correspond to the interior region.</span></div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#a13619aa65f687f53c08ed0b0123fd4de">openvdb::FloatGrid::ValueOffIter</a> iter = grid-&gt;beginValueOff(); iter; ++iter) {</div><div class="line">    <span class="keywordflow">if</span> (iter.getValue() &lt; 0.0) {</div><div class="line">        iter.setValue(1.0);</div><div class="line">        iter.setValueOff();</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Set exterior voxels to 0.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ad795f2f3910144753a5e03d12f4703de">openvdb::tools::changeBackground</a>(grid-&gt;tree(), 0.0);</div></div><!-- fragment --><h1><a class="anchor" id="sStreamIO"></a>
Stream I/O</h1>
<p>The <a class="el" href="classopenvdb_1_1v8__1_1_1io_1_1Stream.html">io::Stream</a> class allows grids to be written to and read from streams that do not support random access, with the restriction that all grids must be written or read at once. (With <a class="el" href="classopenvdb_1_1v8__1_1_1io_1_1File.html">io::File</a>, grids can be read individually by name, provided that they were originally written with <b>io::File</b>, rather than streamed to a file.)</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Stream_8h.html">openvdb/io/Stream.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#a446befa7deee56e243fee79c37263eaa">openvdb::initialize</a>();</div><div class="line"></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#a8290647a1d16e177501c207ea20fee7a">openvdb::GridPtrVecPtr</a> grids(<span class="keyword">new</span> <a class="code" href="namespaceopenvdb_1_1v8__1.html#a0c9703e6ff5cc9deb6410c53412c22c3">GridPtrVec</a>);</div><div class="line">grids-&gt;push_back(...);</div><div class="line"></div><div class="line"><span class="comment">// Stream the grids to a string.</span></div><div class="line">std::ostringstream ostr(std::ios_base::binary);</div><div class="line">openvdb::io::Stream(ostr).write(*grids);</div><div class="line"></div><div class="line"><span class="comment">// Stream the grids to a file.</span></div><div class="line">std::ofstream ofile(<span class="stringliteral">&quot;mygrids.vdb&quot;</span>, std::ios_base::binary);</div><div class="line">openvdb::io::Stream(ofile).write(*grids);</div><div class="line"></div><div class="line"><span class="comment">// Stream in grids from a string.</span></div><div class="line"><span class="comment">// Note that io::Stream::getGrids() returns a shared pointer</span></div><div class="line"><span class="comment">// to an openvdb::GridPtrVec.</span></div><div class="line">std::istringstream istr(ostr.str(), std::ios_base::binary);</div><div class="line">openvdb::io::Stream strm(istr);</div><div class="line">grids = strm.getGrids();</div><div class="line"></div><div class="line"><span class="comment">// Stream in grids from a file.</span></div><div class="line">std::ifstream ifile(<span class="stringliteral">&quot;mygrids.vdb&quot;</span>, std::ios_base::binary);</div><div class="line">grids = openvdb::io::Stream(ifile).getGrids();</div></div><!-- fragment --><h1><a class="anchor" id="sHandlingMetadata"></a>
Handling metadata</h1>
<p>Metadata of various types (string, floating point, integer, etc.&mdash;see <a class="el" href="Metadata_8h.html">Metadata.h</a> for more) can be attached both to individual <b>Grid</b>s and to files on disk. The examples that follow refer to <b>Grid</b>s, but the usage is the same for the <a class="el" href="classopenvdb_1_1v8__1_1_1MetaMap.html">MetaMap</a> that can optionally be supplied to a <a class="el" href="classopenvdb_1_1v8__1_1_1io_1_1File.html#a3f92305001c2ce9ef5ba0ace3644872c">file</a> or <a class="el" href="classopenvdb_1_1v8__1_1_1io_1_1Stream.html#a3f92305001c2ce9ef5ba0ace3644872c">stream</a> for writing.</p>
<h2><a class="anchor" id="sAddingMetadata"></a>
Adding metadata</h2>
<p>The <a class="el" href="classopenvdb_1_1v8__1_1_1MetaMap.html#afe07d56e50899edf5934fd2a5c47096b">Grid::insertMeta</a> method either adds a new (<em>name</em>, <em>value</em>) pair if the name is unique, or overwrites the existing value if the name matches an existing one. An existing value cannot be overwritten with a new value of a different type; the old metadata must be removed first. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::Vec3SGrid::Ptr</a> grid = <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afed9748b2280ee9155aa1033cc583bc7">openvdb::Vec3SGrid::create</a>();</div><div class="line"></div><div class="line">grid-&gt;insertMeta(<span class="stringliteral">&quot;vector type&quot;</span>, <a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html">openvdb::StringMetadata</a>(<span class="stringliteral">&quot;covariant (gradient)&quot;</span>));</div><div class="line">grid-&gt;insertMeta(<span class="stringliteral">&quot;radius&quot;</span>, <a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html">openvdb::FloatMetadata</a>(50.0));</div><div class="line">grid-&gt;insertMeta(<span class="stringliteral">&quot;center&quot;</span>, <a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html">openvdb::Vec3SMetadata</a>(openvdb::Vec3S(10, 15, 10)));</div><div class="line"></div><div class="line"><span class="comment">// OK, overwrites existing value:</span></div><div class="line">grid-&gt;insertMeta(<span class="stringliteral">&quot;center&quot;</span>, <a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html">openvdb::Vec3SMetadata</a>(openvdb::Vec3S(10.5, 15, 30)));</div><div class="line"></div><div class="line"><span class="comment">// Error (throws openvdb::TypeError), can&#39;t overwrite a value of type Vec3S</span></div><div class="line"><span class="comment">// with a value of type float:</span></div><div class="line">grid-&gt;insertMeta(<span class="stringliteral">&quot;center&quot;</span>, <a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html">openvdb::FloatMetadata</a>(0.0));</div></div><!-- fragment --><h2><a class="anchor" id="sGettingMetadata"></a>
Retrieving metadata</h2>
<p>Call <a class="el" href="classopenvdb_1_1v8__1_1_1MetaMap.html#a82ecd84c09b4debc8275c79f8dca1c74">Grid::metaValue</a> to retrieve the value of metadata of a known type. For example, </p><div class="fragment"><div class="line">std::string s = grid-&gt;metaValue&lt;std::string&gt;(<span class="stringliteral">&quot;vector type&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">float</span> r = grid-&gt;metaValue&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;radius&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Error (throws openvdb::TypeError), can&#39;t read a value of type Vec3S as a float:</span></div><div class="line"><span class="keywordtype">float</span> center = grid-&gt;metaValue&lt;<span class="keywordtype">float</span>&gt;(<span class="stringliteral">&quot;center&quot;</span>);</div></div><!-- fragment --><p><a class="el" href="classopenvdb_1_1v8__1_1_1MetaMap.html#aaffd4267064b4952be89781e5d077568">Grid::beginMeta</a> and <a class="el" href="classopenvdb_1_1v8__1_1_1MetaMap.html#ae3d6c7c49617306f867619dea07caa30">Grid::endMeta</a> return <b>std::map</b> iterators over all of the metadata associated with a grid: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classopenvdb_1_1v8__1_1_1MetaMap.html#a73207c1a8506641e9bc8a36b3895429d">openvdb::MetaMap::MetaIterator</a> iter = grid-&gt;beginMeta();</div><div class="line">    iter != grid-&gt;endMeta(); ++iter)</div><div class="line">{</div><div class="line">    <span class="keyword">const</span> std::string&amp; name = iter-&gt;first;</div><div class="line">    <a class="code" href="classopenvdb_1_1v8__1_1_1Metadata.html#ace3ea7af32684cd869611506ad3e12e8">openvdb::Metadata::Ptr</a> value = iter-&gt;second;</div><div class="line">    std::string valueAsString = value-&gt;str();</div><div class="line">    std::cout &lt;&lt; name &lt;&lt; <span class="stringliteral">&quot; = &quot;</span> &lt;&lt; valueAsString &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p>If the type of the metadata is not known, use the <a class="el" href="classopenvdb_1_1v8__1_1_1MetaMap.html#a68d753337de4f85f9fa5cde7b916c102">index operator</a> to retrieve a shared pointer to a generic <a class="el" href="classopenvdb_1_1v8__1_1_1Metadata.html">Metadata</a> object, then query its type: </p><div class="fragment"><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Metadata.html#ace3ea7af32684cd869611506ad3e12e8">openvdb::Metadata::Ptr</a> metadata = grid[<span class="stringliteral">&quot;center&quot;</span>];</div><div class="line"></div><div class="line"><span class="comment">// See typenameAsString&lt;T&gt;() in Types.h for a list of strings that can be</span></div><div class="line"><span class="comment">// returned by the typeName() method.</span></div><div class="line">std::cout &lt;&lt; metadata-&gt;typeName() &lt;&lt; std::endl; <span class="comment">// prints &quot;vec3s&quot;</span></div><div class="line"></div><div class="line"><span class="comment">// One way to process metadata of arbitrary types:</span></div><div class="line"><span class="keywordflow">if</span> (metadata-&gt;typeName() == <a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html#acf959bd7e94562323ed426e09721a789">openvdb::StringMetadata::staticTypeName</a>()) {</div><div class="line">    std::string s = <span class="keyword">static_cast&lt;</span><a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html">openvdb::StringMetadata</a>&amp;<span class="keyword">&gt;</span>(*metadata).<a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html#ab49416ba38b750a3ac3a320185f5224f">value</a>();</div><div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (metadata-&gt;typeName() == <a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html#acf959bd7e94562323ed426e09721a789">openvdb::FloatMetadata::staticTypeName</a>()) {</div><div class="line">    <span class="keywordtype">float</span> f = <span class="keyword">static_cast&lt;</span><a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html">openvdb::FloatMetadata</a>&amp;<span class="keyword">&gt;</span>(*metadata).<a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html#ab49416ba38b750a3ac3a320185f5224f">value</a>();</div><div class="line">} <span class="keywordflow">else</span> <span class="keywordflow">if</span> (metadata-&gt;typeName() == <a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html#acf959bd7e94562323ed426e09721a789">openvdb::Vec3SMetadata::staticTypeName</a>()) {</div><div class="line">    openvdb::Vec3S v = <span class="keyword">static_cast&lt;</span><a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html">openvdb::Vec3SMetadata</a>&amp;<span class="keyword">&gt;</span>(*metadata).<a class="code" href="classopenvdb_1_1v8__1_1_1TypedMetadata.html#ab49416ba38b750a3ac3a320185f5224f">value</a>();</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="sRemovingMetadata"></a>
Removing metadata</h2>
<p><a class="el" href="classopenvdb_1_1v8__1_1_1MetaMap.html#abdae196275a55f43c1219169c5a2ed59">Grid::removeMeta</a> removes metadata by name. If the given name is not found, the call has no effect. </p><div class="fragment"><div class="line">grid-&gt;removeMeta(<span class="stringliteral">&quot;vector type&quot;</span>);</div><div class="line">grid-&gt;removeMeta(<span class="stringliteral">&quot;center&quot;</span>);</div><div class="line">grid-&gt;removeMeta(<span class="stringliteral">&quot;vector type&quot;</span>); <span class="comment">// OK (no effect)</span></div></div><!-- fragment --><h1><a class="anchor" id="sIteration"></a>
Iteration</h1>
<h2><a class="anchor" id="sNodeIterator"></a>
Node Iterator</h2>
<p>A <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html#a5863d8ed73c4bb7a064b678843cfce2d">Tree::NodeIter</a> visits each node in a tree exactly once. In the following example, the tree is known to have a depth of 4; see the <a class="el" href="overview.html#treeNodeIterRef">Overview</a> for a discussion of why node iteration can be complicated when the tree depth is not known. There are techniques (beyond the scope of this Cookbook) for operating on trees of arbitrary depth. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> GridType = <a class="code" href="namespaceopenvdb_1_1v8__1.html#a2ae45d4df056c7d0d936a496fec925ee">openvdb::FloatGrid</a>;</div><div class="line"><span class="keyword">using</span> TreeType = GridType::TreeType;</div><div class="line"><span class="keyword">using</span> RootType = TreeType::RootNodeType;   <span class="comment">// level 3 RootNode</span></div><div class="line">assert(RootType::LEVEL == 3);</div><div class="line"><span class="keyword">using</span> Int1Type = RootType::ChildNodeType;  <span class="comment">// level 2 InternalNode</span></div><div class="line"><span class="keyword">using</span> Int2Type = Int1Type::ChildNodeType;  <span class="comment">// level 1 InternalNode</span></div><div class="line"><span class="keyword">using</span> LeafType = TreeType::LeafNodeType;   <span class="comment">// level 0 LeafNode</span></div><div class="line"></div><div class="line">GridType::Ptr grid = ...;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (TreeType::NodeIter iter = grid-&gt;tree().beginNode(); iter; ++iter) {</div><div class="line">    <span class="keywordflow">switch</span> (iter.getDepth()) {</div><div class="line">    <span class="keywordflow">case</span> 0: { RootType* node = <span class="keyword">nullptr</span>; iter.getNode(node); <span class="keywordflow">if</span> (node) ...; <span class="keywordflow">break</span>; }</div><div class="line">    <span class="keywordflow">case</span> 1: { Int1Type* node = <span class="keyword">nullptr</span>; iter.getNode(node); <span class="keywordflow">if</span> (node) ...; <span class="keywordflow">break</span>; }</div><div class="line">    <span class="keywordflow">case</span> 2: { Int2Type* node = <span class="keyword">nullptr</span>; iter.getNode(node); <span class="keywordflow">if</span> (node) ...; <span class="keywordflow">break</span>; }</div><div class="line">    <span class="keywordflow">case</span> 3: { LeafType* node = <span class="keyword">nullptr</span>; iter.getNode(node); <span class="keywordflow">if</span> (node) ...; <span class="keywordflow">break</span>; }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="sLeafIterator"></a>
Leaf Node Iterator</h2>
<p>A <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html#aa71c9eea9da1f0718ecd069e34823f3f">Tree::LeafIter</a> visits each leaf node in a tree exactly once. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> GridType = <a class="code" href="namespaceopenvdb_1_1v8__1.html#a2ae45d4df056c7d0d936a496fec925ee">openvdb::FloatGrid</a>;</div><div class="line"><span class="keyword">using</span> TreeType = GridType::TreeType;</div><div class="line"></div><div class="line">GridType::Ptr grid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Iterate over references to const LeafNodes.</span></div><div class="line"><span class="keywordflow">for</span> (TreeType::LeafCIter iter = grid-&gt;tree().cbeginLeaf(); iter; ++iter) {</div><div class="line">    <span class="keyword">const</span> TreeType::LeafNodeType&amp; leaf = *iter;</div><div class="line">    ...</div><div class="line">}</div><div class="line"><span class="comment">// Iterate over references to non-const LeafNodes.</span></div><div class="line"><span class="keywordflow">for</span> (TreeType::LeafIter iter = grid-&gt;tree().beginLeaf(); iter; ++iter) {</div><div class="line">    TreeType::LeafNodeType&amp; leaf = *iter;</div><div class="line">    ...</div><div class="line">}</div><div class="line"><span class="comment">// Iterate over pointers to const LeafNodes.</span></div><div class="line"><span class="keywordflow">for</span> (TreeType::LeafCIter iter = grid-&gt;tree().cbeginLeaf(); iter; ++iter) {</div><div class="line">    <span class="keyword">const</span> TreeType::LeafNodeType* leaf = iter.getLeaf();</div><div class="line">    ...</div><div class="line">}</div><div class="line"><span class="comment">// Iterate over pointers to non-const LeafNodes.</span></div><div class="line"><span class="keywordflow">for</span> (TreeType::LeafIter iter = grid-&gt;tree().beginLeaf(); iter; ++iter) {</div><div class="line">    TreeType::LeafNodeType* leaf = iter.getLeaf();</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p> See the <a class="el" href="overview.html#treeLeafIterRef">Overview</a> for more on leaf node iterators.</p>
<h2><a class="anchor" id="sValueIterator"></a>
Value Iterator</h2>
<p>A <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html#a6ccc5d0e86ce5b20fe01cb1ab2c897fe">Tree::ValueIter</a> visits each <a class="el" href="overview.html#subsecValues">value</a> (both tile and voxel) in a tree exactly once. Iteration can be unrestricted or can be restricted to only active values or only inactive values. Note that tree-level value iterators (unlike the node iterators described above) can be accessed either through a grid's tree or directly through the grid itself, as in the following example: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ChangeBackground_8h.html">openvdb/tools/ChangeBackground.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">using</span> GridType = <a class="code" href="namespaceopenvdb_1_1v8__1.html#a77ff1a3a38ec99a56b4d99a15a2970bf">openvdb::Vec3SGrid</a>;</div><div class="line"><span class="keyword">using</span> TreeType = GridType::TreeType;</div><div class="line"></div><div class="line">GridType::Ptr grid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Iterate over all active values but don&#39;t allow them to be changed.</span></div><div class="line"><span class="keywordflow">for</span> (GridType::ValueOnCIter iter = grid-&gt;cbeginValueOn(); iter.test(); ++iter) {</div><div class="line">    <span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3f</a>&amp; value = *iter;</div><div class="line"></div><div class="line">    <span class="comment">// Print the coordinates of all voxels whose vector value has</span></div><div class="line">    <span class="comment">// a length greater than 10, and print the bounding box coordinates</span></div><div class="line">    <span class="comment">// of all tiles whose vector value length is greater than 10.</span></div><div class="line">    <span class="keywordflow">if</span> (value.<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html#ac391672014f7b4faed37018787333e4b">length</a>() &gt; 10.0) {</div><div class="line">        <span class="keywordflow">if</span> (iter.isVoxelValue()) {</div><div class="line">            std::cout &lt;&lt; iter.getCoord() &lt;&lt; std::endl;</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            openvdb::CoordBBox bbox;</div><div class="line">            iter.getBoundingBox(bbox);</div><div class="line">            std::cout &lt;&lt; bbox &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Iterate over and normalize all inactive values.</span></div><div class="line"><span class="keywordflow">for</span> (GridType::ValueOffIter iter = grid-&gt;beginValueOff(); iter.test(); ++iter) {</div><div class="line">    <a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3f</a> value = *iter;</div><div class="line">    value.<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html#ae37fa555d3e29bc5ee4b0c813f86f18d">normalize</a>();</div><div class="line">    iter.setValue(value);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Normalize the (inactive) background value as well.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ad795f2f3910144753a5e03d12f4703de">openvdb::tools::changeBackground</a>(grid-&gt;tree(), grid-&gt;background().unit());</div></div><!-- fragment --><p> See the <a class="el" href="overview.html#treeValueIterRef">Overview</a> for more on value iterators.</p>
<h2><a class="anchor" id="sIteratorRange"></a>
Iterator Range</h2>
<p>A <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1IteratorRange.html">tree::IteratorRange</a> wraps any grid or tree iterator and gives the iterator <a href="http://www.threadingbuildingblocks.org">TBB</a> splittable range semantics, so that it can be used as the Range argument to functions like <b>tbb::parallel_for</b> and <b>tbb::parallel_reduce</b>. (This is in fact how <a class="el" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ada1c7e219f36d148510ce22d7599171b">tools::foreach</a> and <a class="el" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ae870e81ce652b9c057d92dbe4b4b9811">tools::transformValues</a> are implemented; see <a class="el" href="codeExamples.html#sValueXformTools">Value transformation</a>, below, for more on those functions.) There is some overhead to splitting, since grid and tree iterators are not random-access, but the overhead should typically be negligible compared with the amount of work done per subrange.</p>
<p>The following is a complete program that uses <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1IteratorRange.html">tree::IteratorRange</a>. The program iterates in parallel over the leaf nodes of a tree (by splitting the iteration range of a <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html#a30cc6e43580444de39db347e1c0a9dee">Tree::LeafCIter</a>) and computes the total number of active leaf-level voxels by incrementing a global, thread-safe counter. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="LevelSetSphere_8h.html">openvdb/tools/LevelSetSphere.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;tbb/parallel_for.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;atomic&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;cassert&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Global active voxel counter, atomically updated from multiple threads</span></div><div class="line">std::atomic&lt;openvdb::Index64&gt; activeLeafVoxelCount;</div><div class="line"></div><div class="line"><span class="comment">// Functor for use with tbb::parallel_for() that operates on a grid&#39;s leaf nodes</span></div><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Gr<span class="keywordtype">id</span>Type&gt;</div><div class="line"><span class="keyword">struct </span>LeafProcessor</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> TreeType = <span class="keyword">typename</span> GridType::TreeType;</div><div class="line">    <span class="keyword">using</span> LeafNode = <span class="keyword">typename</span> TreeType::LeafNodeType;</div><div class="line">    <span class="comment">// Define an IteratorRange that splits the iteration space of a leaf iterator.</span></div><div class="line">    <span class="keyword">using</span> IterRange = openvdb::tree::IteratorRange&lt;typename TreeType::LeafCIter&gt;;</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> operator()(IterRange&amp; range)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        <span class="comment">// Note: this code must be thread-safe.</span></div><div class="line"></div><div class="line">        <span class="comment">// Iterate over a subrange of the leaf iterator&#39;s iteration space.</span></div><div class="line">        <span class="keywordflow">for</span> ( ; range; ++range) {</div><div class="line">            <span class="comment">// Retrieve the leaf node to which the iterator is pointing.</span></div><div class="line">            <span class="keyword">const</span> LeafNode&amp; leaf = *range.iterator();</div><div class="line">            <span class="comment">// Update the global counter.</span></div><div class="line">            activeLeafVoxelCount.fetch_add(leaf.onVoxelCount());</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">main()</div><div class="line">{</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a446befa7deee56e243fee79c37263eaa">openvdb::initialize</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Generate a level set grid.</span></div><div class="line">    <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> grid =</div><div class="line">        openvdb::tools::createLevelSetSphere&lt;openvdb::FloatGrid&gt;(<span class="comment">/*radius=*/</span>20.0,</div><div class="line">            <span class="comment">/*center=*/</span><a class="code" href="namespaceopenvdb_1_1v8__1.html#a4873ae29d5d8d4f1cb7c7717af41a993">openvdb::Vec3f</a>(1.5, 2, 3), <span class="comment">/*voxel size=*/</span>0.5);</div><div class="line"></div><div class="line">    <span class="comment">// Construct a functor for use with tbb::parallel_for()</span></div><div class="line">    <span class="comment">// that processes the leaf nodes of a FloatGrid.</span></div><div class="line">    <span class="keyword">using</span> FloatLeafProc = LeafProcessor&lt;openvdb::FloatGrid&gt;;</div><div class="line">    FloatLeafProc proc;</div><div class="line"></div><div class="line">    <span class="comment">// Wrap a leaf iterator in an IteratorRange.</span></div><div class="line">    FloatLeafProc::IterRange range(grid-&gt;tree().cbeginLeaf());</div><div class="line">    <span class="comment">// Iterate over leaf nodes in parallel.</span></div><div class="line">    tbb::parallel_for(range, proc);</div><div class="line"></div><div class="line">    std::cout &lt;&lt; activeLeafVoxelCount &lt;&lt; <span class="stringliteral">&quot; active leaf voxels&quot;</span> &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// The computed voxel count should equal the grid&#39;s active voxel count,</span></div><div class="line">    <span class="comment">// since all of the active voxels in a level set grid are stored at the</span></div><div class="line">    <span class="comment">// leaf level (that is, there are no active tiles in a level set grid).</span></div><div class="line">    assert(activeLeafVoxelCount == grid-&gt;activeVoxelCount());</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="sInterpolation"></a>
Interpolation of grid values</h1>
<p>Applications such as rendering require evaluation of grids at arbitrary, fractional coordinates in either index or world space. This is achieved, of course, by interpolating between known grid values at neighboring whole-voxel locations, that is, at integer coordinates in index space. The following sections introduce OpenVDB&rsquo;s various interpolation schemes as well as the <a class="el" href="codeExamples.html#sGridSampler">Grid Sampler</a> and <a class="el" href="codeExamples.html#sDualGridSampler">Dual Grid Sampler</a> classes for efficient, continuous sampling of grids. In most cases, <b>GridSampler</b> is the preferred interface for interpolation, but note that when a fixed transform is to be applied to all values in a grid (that is, the grid is to be resampled), it is both easier and more efficient to use the multithreaded <a class="el" href="classopenvdb_1_1v8__1_1_1tools_1_1GridTransformer.html">GridTransformer</a> class, introduced in <a class="el" href="codeExamples.html#sXformTools">Transforming grids</a>.</p>
<h2><a class="anchor" id="sSamplers"></a>
Index-space samplers</h2>
<p>OpenVDB offers low-level zero-, first- and second-order interpolators <a class="el" href="structopenvdb_1_1v8__1_1_1tools_1_1PointSampler.html">PointSampler</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tools_1_1BoxSampler.html">BoxSampler</a> and <a class="el" href="structopenvdb_1_1v8__1_1_1tools_1_1QuadraticSampler.html">QuadraticSampler</a>, in addition to the variants <a class="el" href="structopenvdb_1_1v8__1_1_1tools_1_1StaggeredPointSampler.html">StaggeredPointSampler</a>, <a class="el" href="structopenvdb_1_1v8__1_1_1tools_1_1StaggeredBoxSampler.html">StaggeredBoxSampler</a> and <a class="el" href="structopenvdb_1_1v8__1_1_1tools_1_1StaggeredQuadraticSampler.html">StaggeredQuadraticSampler</a> for <a class="el" href="transformsAndMaps.html#sStaggered">staggered</a> velocity grids.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Interpolation_8h.html">openvdb/tools/Interpolation.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> GridType grid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Choose fractional coordinates in index space.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a> ijk(10.5, -100.2, 50.3);</div><div class="line"></div><div class="line"><span class="comment">// Compute the value of the grid at ijk via nearest-neighbor (zero-order)</span></div><div class="line"><span class="comment">// interpolation.</span></div><div class="line">GridType::ValueType v0 = openvdb::tools::PointSampler::sample(grid.tree(), ijk);</div><div class="line"></div><div class="line"><span class="comment">// Compute the value via trilinear (first-order) interpolation.</span></div><div class="line">GridType::ValueType v1 = openvdb::tools::BoxSampler::sample(grid.tree(), ijk);</div><div class="line"></div><div class="line"><span class="comment">// Compute the value via triquadratic (second-order) interpolation.</span></div><div class="line">GridType::ValueType v2 = openvdb::tools::QuadraticSampler::sample(grid.tree(), ijk);</div></div><!-- fragment --><p>These examples invoke the <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html#ac5110ef8248d5f0510bc583de349c196">getValue</a> method on the grid&rsquo;s tree to fetch sample values in the neighborhood of (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>). Accessing values via the tree is thread-safe due to the lack of caching, but for that reason it is also suboptimal. For better performance, use <a class="el" href="overview.html#subsecValueAccessor">value accessors</a> (but be careful to use one accessor per computational thread): </p><div class="fragment"><div class="line">GridType::ConstAccessor accessor = grid.getConstAccessor();</div><div class="line"></div><div class="line">GridType::ValueType v0 = openvdb::tools::PointSampler::sample(accessor, ijk);</div><div class="line">GridType::ValueType v1 = openvdb::tools::BoxSampler::sample(accessor, ijk);</div><div class="line">GridType::ValueType v2 = openvdb::tools::QuadraticSampler::sample(accessor, ijk);</div></div><!-- fragment --><p>Another issue with these low-level interpolators is that they operate only in index space. To interpolate in world space, use the higher-level classes discussed below.</p>
<h2><a class="anchor" id="sGridSampler"></a>
Grid Sampler</h2>
<p>The <a class="el" href="classopenvdb_1_1v8__1_1_1tools_1_1GridSampler.html">GridSampler</a> class allows for continuous sampling in both world space and index space and can be used with grids, trees or value accessors.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Interpolation_8h.html">openvdb/tools/Interpolation.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> GridType grid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Instantiate the GridSampler template on the grid type and on a box sampler</span></div><div class="line"><span class="comment">// for thread-safe but uncached trilinear interpolation.</span></div><div class="line">openvdb::tools::GridSampler&lt;GridType, openvdb::tools::BoxSampler&gt; sampler(grid);</div><div class="line"></div><div class="line"><span class="comment">// Compute the value of the grid at fractional coordinates in index space.</span></div><div class="line">GridType::ValueType indexValue = sampler.isSample(<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a>(10.5, -100.2, 50.3));</div><div class="line"></div><div class="line"><span class="comment">// Compute the value of the grid at a location in world space.</span></div><div class="line">GridType::ValueType worldValue = sampler.wsSample(<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a>(0.25, 1.4, -1.1));</div><div class="line"></div><div class="line"><span class="comment">// Request a value accessor for accelerated access.</span></div><div class="line"><span class="comment">// (Because value accessors employ a cache, it is important to declare</span></div><div class="line"><span class="comment">// one accessor per thread.)</span></div><div class="line">GridType::ConstAccessor accessor = grid.getConstAccessor();</div><div class="line"></div><div class="line"><span class="comment">// Instantiate the GridSampler template on the accessor type and on</span></div><div class="line"><span class="comment">// a box sampler for accelerated trilinear interpolation.</span></div><div class="line">openvdb::tools::GridSampler&lt;GridType::ConstAccessor, openvdb::tools::BoxSampler&gt;</div><div class="line">    fastSampler(accessor, grid.transform());</div><div class="line"></div><div class="line"><span class="comment">// Compute the value of the grid at fractional coordinates in index space.</span></div><div class="line">indexValue = fastSampler.isSample(<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a>(10.5, -100.2, 50.3));</div><div class="line"></div><div class="line"><span class="comment">// Compute the value of the grid at a location in world space.</span></div><div class="line">worldValue = fastSampler.wsSample(<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a>(0.25, 1.4, -1.1));</div></div><!-- fragment --><p> Note that when constructing a <b>GridSampler</b> with either a tree or a value accessor, you must also supply an index-to-world transform. When constructing a <b>GridSampler</b> with a grid, the grid's transform is used automatically.</p>
<h2><a class="anchor" id="sDualGridSampler"></a>
Dual Grid Sampler</h2>
<p>It might sometimes be necessary to interpolate values from a source grid into the index space of a target grid. If this transformation is to be applied to all of the values in the source grid, then it is best to use the tools in <a class="el" href="GridTransformer_8h.html">GridTransformer.h</a>. For other cases, consider using the <a class="el" href="classopenvdb_1_1v8__1_1_1tools_1_1DualGridSampler.html">DualGridSampler</a> class. Like the <b>GridSampler</b> class, this class can be used with grids, trees or value accessors. In addition, <b>DualGridSampler</b> checks if the source and target grids are aligned (that is, they have the same transform), in which case it avoids unnecessary interpolation.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Interpolation_8h.html">openvdb/tools/Interpolation.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> GridType sourceGrid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Instantiate the DualGridSampler template on the grid type and on</span></div><div class="line"><span class="comment">// a box sampler for thread-safe but uncached trilinear interpolation.</span></div><div class="line">openvdb::tools::DualGridSampler&lt;GridType, openvdb::tools::BoxSampler&gt;</div><div class="line">    sampler(sourceGrid, targetGrid.constTransform());</div><div class="line"></div><div class="line"><span class="comment">// Compute the value of the source grid at a location in the</span></div><div class="line"><span class="comment">// target grid&#39;s index space.</span></div><div class="line">GridType::ValueType value = sampler(openvdb::Coord(-23, -50, 202));</div><div class="line"></div><div class="line"><span class="comment">// Request a value accessor for accelerated access to the source grid.</span></div><div class="line"><span class="comment">// (Because value accessors employ a cache, it is important to declare</span></div><div class="line"><span class="comment">// one accessor per thread.)</span></div><div class="line">GridType::ConstAccessor accessor = sourceGrid.getConstAccessor();</div><div class="line"></div><div class="line"><span class="comment">// Instantiate the DualGridSampler template on the accessor type and on</span></div><div class="line"><span class="comment">// a box sampler for accelerated trilinear interpolation.</span></div><div class="line">openvdb::tools::DualGridSampler&lt;GridType::ConstAccessor, openvdb::tools::BoxSampler&gt;</div><div class="line">    fastSampler(accessor, sourceGrid.constTransform(), targetGrid.constTransform());</div><div class="line"></div><div class="line"><span class="comment">// Compute the value of the source grid at a location in the</span></div><div class="line"><span class="comment">// target grid&#39;s index space.</span></div><div class="line">value = fastSampler(openvdb::Coord(-23, -50, 202));</div></div><!-- fragment --><p> Note that interpolation is done by invoking a <b>DualGridSampler</b> as a functor, in contrast to the more general-purpose <b>GridSampler</b>.</p>
<h1><a class="anchor" id="sXformTools"></a>
Transforming grids</h1>
<h2><a class="anchor" id="sResamplingTools"></a>
Geometric transformation</h2>
<p>A <a class="el" href="classopenvdb_1_1v8__1_1_1tools_1_1GridTransformer.html">GridTransformer</a> applies a geometric transformation to an input grid using one of several sampling schemes, and stores the result in an output grid. The operation is multithreaded by default, though threading can be disabled by calling <a class="el" href="classopenvdb_1_1v8__1_1_1tools_1_1GridResampler.html#ac3fa2c9a94b6643ed5244fca102e11a8">setThreaded(false)</a>. A <b>GridTransformer</b> object can be reused to apply the same transformation to multiple input grids, optionally using different sampling schemes. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="GridTransformer_8h.html">openvdb/tools/GridTransformer.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a></div><div class="line">    sourceGrid = ...</div><div class="line">    targetGrid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Get the source and target grids&#39; index space to world space transforms.</span></div><div class="line"><span class="keyword">const</span> openvdb::math::Transform</div><div class="line">    &amp;sourceXform = sourceGrid-&gt;transform(),</div><div class="line">    &amp;targetXform = targetGrid-&gt;transform();</div><div class="line"><span class="comment">// Compute a source grid to target grid transform.</span></div><div class="line"><span class="comment">// (For this example, we assume that both grids&#39; transforms are linear,</span></div><div class="line"><span class="comment">// so that they can be represented as 4 x 4 matrices.)</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Mat4.html">openvdb::Mat4R</a> xform =</div><div class="line">    sourceXform.baseMap()-&gt;getAffineMap()-&gt;getMat4() *</div><div class="line">    targetXform.baseMap()-&gt;getAffineMap()-&gt;getMat4().<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Mat4.html#a26a6d7acc07d370764b895b848f846e0">inverse</a>();</div><div class="line"></div><div class="line"><span class="comment">// Create the transformer.</span></div><div class="line">openvdb::tools::GridTransformer transformer(xform);</div><div class="line"></div><div class="line"><span class="comment">// Resample using nearest-neighbor interpolation.</span></div><div class="line">transformer.transformGrid&lt;openvdb::tools::PointSampler, <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::FloatGrid</a>&gt;(</div><div class="line">    *sourceGrid, *targetGrid);</div><div class="line"></div><div class="line"><span class="comment">// Resample using trilinear interpolation.</span></div><div class="line">transformer.transformGrid&lt;openvdb::tools::BoxSampler, <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::FloatGrid</a>&gt;(</div><div class="line">    *sourceGrid, *targetGrid);</div><div class="line"></div><div class="line"><span class="comment">// Resample using triquadratic interpolation.</span></div><div class="line">transformer.transformGrid&lt;openvdb::tools::QuadraticSampler, <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::FloatGrid</a>&gt;(</div><div class="line">    *sourceGrid, *targetGrid);</div><div class="line"></div><div class="line"><span class="comment">// Prune the target tree for optimal sparsity.</span></div><div class="line">targetGrid-&gt;<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#a9041f381eeb1287165c1287603de9663">tree</a>().prune();</div></div><!-- fragment --><h2><a class="anchor" id="sValueXformTools"></a>
Value transformation</h2>
<p>This example uses <a class="el" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ada1c7e219f36d148510ce22d7599171b">tools::foreach</a> to multiply all values (both tile and voxel and both active and inactive) of a scalar, floating-point grid by two: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ValueTransformer_8h.html">openvdb/tools/ValueTransformer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a local function that doubles the value to which the given</span></div><div class="line"><span class="comment">// value iterator points.</span></div><div class="line"><span class="keyword">struct </span>Local {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> op(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#ae60f7ec90327837088fbe58242f78745">openvdb::FloatGrid::ValueAllIter</a>&amp; iter) {</div><div class="line">        iter.setValue(*iter * 2);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> grid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Apply the function to all values.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ada1c7e219f36d148510ce22d7599171b">openvdb::tools::foreach</a>(grid-&gt;beginValueAll(), Local::op);</div></div><!-- fragment --><p>This example uses <a class="el" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ada1c7e219f36d148510ce22d7599171b">tools::foreach</a> to rotate all active vectors of a vector-valued grid by 45&deg; about the <em>y</em> axis: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ValueTransformer_8h.html">openvdb/tools/ValueTransformer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a functor that multiplies the vector to which the given</span></div><div class="line"><span class="comment">// value iterator points by a fixed matrix.</span></div><div class="line"><span class="keyword">struct </span>MatMul {</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a85b140686e0a81e6b7e47e021428005e">openvdb::math::Mat3s</a> M;</div><div class="line">    MatMul(<span class="keyword">const</span> <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a85b140686e0a81e6b7e47e021428005e">openvdb::math::Mat3s</a>&amp; mat): M(mat) {}</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#aa20792587df8cc92cff821e68e70ace7">openvdb::Vec3SGrid::ValueOnIter</a>&amp; iter)<span class="keyword"> const </span>{</div><div class="line">        iter.setValue(M.transform(*iter));</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::Vec3SGrid::Ptr</a> grid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Construct the rotation matrix.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a85b140686e0a81e6b7e47e021428005e">openvdb::math::Mat3s</a> rot45 =</div><div class="line">    openvdb::math::rotation&lt;openvdb::math::Mat3s&gt;(<a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#ae3996976d8ffb3e58d88f58227473f8eaa1ec9649c0a631b27ad7280af3522dd0">openvdb::math::Y_AXIS</a>, M_PI_4);</div><div class="line"></div><div class="line"><span class="comment">// Apply the functor to all active values.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ada1c7e219f36d148510ce22d7599171b">openvdb::tools::foreach</a>(grid-&gt;beginValueOn(), MatMul(rot45));</div></div><!-- fragment --><p><a class="el" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ae870e81ce652b9c057d92dbe4b4b9811">tools::transformValues</a> is similar to <a class="el" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ada1c7e219f36d148510ce22d7599171b">tools::foreach</a>, but it populates an output grid with transformed values from an input grid that may have a different value type. The following example populates a scalar, floating-point grid with the lengths of all active vectors from a vector-valued grid (like <a class="el" href="namespaceopenvdb_1_1v8__1_1_1tools.html#a9370eee6dbb6de354a68a54b9cdd1dba">tools::magnitude</a>): </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ValueTransformer_8h.html">openvdb/tools/ValueTransformer.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a local function that, given an iterator pointing to a vector value</span></div><div class="line"><span class="comment">// in an input grid, sets the corresponding tile or voxel in a scalar,</span></div><div class="line"><span class="comment">// floating-point output grid to the length of the vector.</span></div><div class="line"><span class="keyword">struct </span>Local {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> op(</div><div class="line">        <span class="keyword">const</span> <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#a7ccc223c434beb0d880d1675bd716b12">openvdb::Vec3SGrid::ValueOnCIter</a>&amp; iter,</div><div class="line">        openvdb::FloatGrid::ValueAccessor&amp; accessor)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (iter.isVoxelValue()) { <span class="comment">// set a single voxel</span></div><div class="line">            accessor.setValue(iter.getCoord(), iter-&gt;length());</div><div class="line">        } <span class="keywordflow">else</span> { <span class="comment">// fill an entire tile</span></div><div class="line">            openvdb::CoordBBox bbox;</div><div class="line">            iter.getBoundingBox(bbox);</div><div class="line">            accessor.getTree().fill(bbox, iter-&gt;length());</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#a84f71739738652d0987c7456128389be">openvdb::Vec3SGrid::ConstPtr</a> inGrid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Create a scalar grid to hold the transformed values.</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> outGrid = <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afed9748b2280ee9155aa1033cc583bc7">openvdb::FloatGrid::create</a>();</div><div class="line"></div><div class="line"><span class="comment">// Populate the output grid with transformed values.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ae870e81ce652b9c057d92dbe4b4b9811">openvdb::tools::transformValues</a>(inGrid-&gt;cbeginValueOn(), *outGrid, Local::op);</div></div><!-- fragment --><h1><a class="anchor" id="sCombiningGrids"></a>
Combining grids</h1>
<p>The following examples show various ways in which a pair of grids can be combined in <a class="el" href="overview.html#subsecVoxSpace">index space</a>. The assumption is that index coordinates (<em>i</em>,&amp;nbsp <em>j</em>,&amp;nbsp <em>k</em>) in both grids correspond to the same physical, <a class="el" href="overview.html#subsecWorSpace">world space</a> location. When the grids have different transforms, it is usually necessary to first <a class="el" href="codeExamples.html#sResamplingTools">resample</a> one grid into the other grid's <a class="el" href="overview.html#subsecVoxSpace">index space</a>.</p>
<h2><a class="anchor" id="sCsgTools"></a>
Level set CSG operations</h2>
<p>The level set CSG functions in <a class="el" href="Composite_8h.html" title="Functions to efficiently perform various compositing operations on grids. ">tools/Composite.h</a> operate on pairs of grids of the same type, using sparse traversal for efficiency. These operations always leave the second grid empty. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Composite_8h.html">openvdb/tools/Composite.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Two grids of the same type containing level set volumes</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> gridA(...), gridB(...);</div><div class="line"></div><div class="line"><span class="comment">// Save copies of the two grids; CSG operations always modify</span></div><div class="line"><span class="comment">// the A grid and leave the B grid empty.</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#a84f71739738652d0987c7456128389be">openvdb::FloatGrid::ConstPtr</a></div><div class="line">    copyOfGridA = gridA-&gt;deepCopy(),</div><div class="line">    copyOfGridB = gridB-&gt;deepCopy();</div><div class="line"></div><div class="line"><span class="comment">// Compute the union (A u B) of the two level sets.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#a003db10da0696d7e120eff0477bc782c">openvdb::tools::csgUnion</a>(*gridA, *gridB);</div><div class="line"></div><div class="line"><span class="comment">// Restore the original level sets.</span></div><div class="line">gridA = copyOfGridA-&gt;deepCopy();</div><div class="line">gridB = copyOfGridB-&gt;deepCopy();</div><div class="line"></div><div class="line"><span class="comment">// Compute the intersection (A n B) of the two level sets.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#a7de3e11a37615c24f9c5e50bdc2a06e7">openvdb::tools::csgIntersection</a>(*gridA, *gridB);</div><div class="line"></div><div class="line"><span class="comment">// Restore the original level sets.</span></div><div class="line">gridA = copyOfGridA-&gt;deepCopy();</div><div class="line">gridB = copyOfGridB-&gt;deepCopy();</div><div class="line"></div><div class="line"><span class="comment">// Compute the difference (A / B) of the two level sets.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#a1e2d62ce38b1969798cdc45baf2c9df3">openvdb::tools::csgDifference</a>(*gridA, *gridB);</div></div><!-- fragment --><h2><a class="anchor" id="sCompTools"></a>
Compositing operations</h2>
<p>Like the <a class="el" href="codeExamples.html#sCsgTools">CSG operations</a>, the compositing functions in <a class="el" href="Composite_8h.html" title="Functions to efficiently perform various compositing operations on grids. ">tools/Composite.h</a> operate on pairs of grids of the same type, and they always leave the second grid empty. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="Composite_8h.html">openvdb/tools/Composite.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Two grids of the same type</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> gridA = ..., gridB = ...;</div><div class="line"></div><div class="line"><span class="comment">// Save copies of the two grids; compositing operations always</span></div><div class="line"><span class="comment">// modify the A grid and leave the B grid empty.</span></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#a84f71739738652d0987c7456128389be">openvdb::FloatGrid::ConstPtr</a></div><div class="line">    copyOfGridA = gridA-&gt;deepCopy(),</div><div class="line">    copyOfGridB = gridB-&gt;deepCopy();</div><div class="line"></div><div class="line"><span class="comment">// At each voxel, compute a = max(a, b).</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ab89a5ef4e61074f401e72aef834afda1">openvdb::tools::compMax</a>(*gridA, *gridB);</div><div class="line"></div><div class="line"><span class="comment">// Restore the original grids.</span></div><div class="line">gridA = copyOfGridA-&gt;deepCopy();</div><div class="line">gridB = copyOfGridB-&gt;deepCopy();</div><div class="line"></div><div class="line"><span class="comment">// At each voxel, compute a = min(a, b).</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ad0f06ce463a63898a09fea378ac6912e">openvdb::tools::compMin</a>(*gridA, *gridB);</div><div class="line"></div><div class="line"><span class="comment">// Restore the original grids.</span></div><div class="line">gridA = copyOfGridA-&gt;deepCopy();</div><div class="line">gridB = copyOfGridB-&gt;deepCopy();</div><div class="line"></div><div class="line"><span class="comment">// At each voxel, compute a = a + b.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#ab3e57293906eddd0c42c4df3e64cc800">openvdb::tools::compSum</a>(*gridA, *gridB);</div><div class="line"></div><div class="line"><span class="comment">// Restore the original grids.</span></div><div class="line">gridA = copyOfGridA-&gt;deepCopy();</div><div class="line">gridB = copyOfGridB-&gt;deepCopy();</div><div class="line"></div><div class="line"><span class="comment">// At each voxel, compute a = a * b.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#abdd7d6918702cd795e831789812c9ac1">openvdb::tools::compMul</a>(*gridA, *gridB);</div></div><!-- fragment --><h2><a class="anchor" id="sCombineTools"></a>
Generic combination</h2>
<p>The <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html#a11ca864d49b3df73bd482307bd800577">Tree::combine</a> family of methods apply a user-supplied operator to pairs of corresponding values of two trees. These methods are efficient because they take into account the sparsity of the trees; they are not multithreaded, however.</p>
<p>This example uses the <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html#a11ca864d49b3df73bd482307bd800577">Tree::combine</a> method to compute the difference between corresponding voxels of two floating-point grids: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a local function that subtracts two floating-point values.</span></div><div class="line"><span class="keyword">struct </span>Local {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> diff(<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; b, <span class="keywordtype">float</span>&amp; result) {</div><div class="line">        result = a - b;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> aGrid = ..., bGrid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Compute the difference between corresponding voxels of aGrid and bGrid</span></div><div class="line"><span class="comment">// and store the result in aGrid, leaving bGrid empty.</span></div><div class="line">aGrid-&gt;tree().combine(bGrid-&gt;tree(), Local::diff);</div></div><!-- fragment --><p>Another <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html#a11ca864d49b3df73bd482307bd800577">Tree::combine</a> example, this time using a functor to preserve state: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a functor that computes f * a + (1 - f) * b  for pairs of</span></div><div class="line"><span class="comment">// floating-point values a and b.</span></div><div class="line"><span class="keyword">struct </span>Blend {</div><div class="line">    Blend(<span class="keywordtype">float</span> f): frac(f) {}</div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; b, <span class="keywordtype">float</span>&amp; result)<span class="keyword"> const </span>{</div><div class="line">        result = frac * a + (1.0 - frac) * b;</div><div class="line">    }</div><div class="line">    <span class="keywordtype">float</span> frac;</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> aGrid = ..., bGrid = ...;</div><div class="line"></div><div class="line"><span class="comment">// Compute a = 0.25 * a + 0.75 * b for all corresponding voxels of</span></div><div class="line"><span class="comment">// aGrid and bGrid.  Store the result in aGrid and empty bGrid.</span></div><div class="line">aGrid-&gt;tree().combine(bGrid-&gt;tree(), Blend(0.25));</div></div><!-- fragment --><p>The <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html#a71140d5e67f0fce2c7fe0ae119db9711">Tree::combineExtended</a> method invokes a function of the form <code>void f(CombineArgs&lt;T&gt;&amp; args)</code>, where the <a class="el" href="classopenvdb_1_1v8__1_1_1CombineArgs.html">CombineArgs</a> object encapsulates an <em>a</em> and a <em>b</em> value and their active states as well as a result value and its active state. In the following example, voxel values in floating-point <em>aGrid</em> are replaced with corresponding values from floating-point <em>bGrid</em> (leaving <em>bGrid</em> empty) wherever the <em>b</em> values are larger. The active states of any transferred values are preserved. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a local function that retrieves a and b values from a CombineArgs</span></div><div class="line"><span class="comment">// struct and then sets the result member to the maximum of a and b.</span></div><div class="line"><span class="keyword">struct </span>Local {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools_1_1composite.html#a5f16766bff85d9c17429a43bd490343c">max</a>(CombineArgs&lt;float&gt;&amp; args) {</div><div class="line">        <span class="keywordflow">if</span> (args.b() &gt; args.a()) {</div><div class="line">            <span class="comment">// Transfer the B value and its active state.</span></div><div class="line">            args.setResult(args.b());</div><div class="line">            args.setResultIsActive(args.bIsActive());</div><div class="line">        } <span class="keywordflow">else</span> {</div><div class="line">            <span class="comment">// Preserve the A value and its active state.</span></div><div class="line">            args.setResult(args.a());</div><div class="line">            args.setResultIsActive(args.aIsActive());</div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> aGrid = ..., bGrid = ...;</div><div class="line"></div><div class="line">aGrid-&gt;tree().combineExtended(bGrid-&gt;tree(), <a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools_1_1composite.html#a5f16766bff85d9c17429a43bd490343c">Local::max</a>);</div></div><!-- fragment --><p>Like <b>combine</b>, <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html#af1cbd79b5ac7b0898386849c5d93e4cc">Tree::combine2</a> applies an operation to pairs of corresponding values of two trees. However, <b>combine2</b> writes the result to a third, output tree and does not modify either of the two input trees. (As a result, it is less space-efficient than the <b>combine</b> method.) Here, the voxel differencing example above is repeated using <b>combine2:</b> </p><div class="fragment"><div class="line"><span class="preprocessor"> #include</span></div><div class="line">&lt;<a class="code" href="namespaceopenvdb.html">openvdb</a>/<a class="code" href="namespaceopenvdb.html">openvdb</a>.h&gt;</div><div class="line"></div><div class="line"><span class="keyword">struct </span>Local {</div><div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> <span class="keywordtype">void</span> diff(<span class="keyword">const</span> <span class="keywordtype">float</span>&amp; a, <span class="keyword">const</span> <span class="keywordtype">float</span>&amp; b, <span class="keywordtype">float</span>&amp; result) {</div><div class="line">        result = a - b;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#a84f71739738652d0987c7456128389be">openvdb::FloatGrid::ConstPtr</a> aGrid = ..., bGrid = ...;</div><div class="line"><a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> resultGrid = <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afed9748b2280ee9155aa1033cc583bc7">openvdb::FloatGrid::create</a>();</div><div class="line"></div><div class="line"><span class="comment">// Combine aGrid and bGrid and write the result into resultGrid.</span></div><div class="line"><span class="comment">// The input grids are not modified.</span></div><div class="line">resultGrid-&gt;tree().combine2(aGrid-&gt;tree(), bGrid-&gt;tree(), Local::diff);</div></div><!-- fragment --><p> An <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html#a878302f18a7f23adac7da7a9fc5f7441">extended combine2</a> is also available.</p>
<h1><a class="anchor" id="sGenericProg"></a>
Generic programming</h1>
<h2><a class="anchor" id="sTypedGridMethods"></a>
Calling Grid methods</h2>
<p>A common task is to perform some operation on all of the grids in a file, where the operation involves <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html">Grid</a> method calls and the grids are of different types. Only a handful of <b>Grid</b> methods, such as <a class="el" href="classopenvdb_1_1v8__1_1_1Grid.html#a520c048155f7e980738fae2e20b94de1">activeVoxelCount</a>, are virtual and can be called through a <a class="el" href="classopenvdb_1_1v8__1_1_1GridBase.html">GridBase</a> pointer; most are not, because they require knowledge of the <b>Grid</b>'s value type. For example, one might want to <a class="el" href="classopenvdb_1_1v8__1_1_1tree_1_1Tree.html#a462c7056adc55d8da2cc5828934ff859">prune</a> the trees of all of the grids in a file regardless of their type, but <b>Tree::prune</b> is non-virtual because it accepts an optional pruning tolerance argument whose type is the grid's value type.</p>
<p>The <b>processTypedGrid</b> function below makes this kind of task easier. It is called with a <b>GridBase</b> pointer and a functor whose call operator accepts a pointer to a <b>Grid</b> of arbitrary type. The call operator should be templated on the grid type and, if necessary, overloaded for specific grid types.</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> OpType&gt;</div><div class="line"><span class="keywordtype">void</span> processTypedGrid(<a class="code" href="classopenvdb_1_1v8__1_1_1GridBase.html#ad98d7556003ccc2ef810f87d97159de4">openvdb::GridBase::Ptr</a> grid, OpType&amp; op)</div><div class="line">{</div><div class="line"><span class="preprocessor">#define CALL_OP(GridType) \</span></div><div class="line"><span class="preprocessor">    op.template operator()&lt;GridType&gt;(openvdb::gridPtrCast&lt;GridType&gt;(grid))</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (grid-&gt;isType&lt;<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::BoolGrid</a>&gt;())        CALL_OP(<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::BoolGrid</a>);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (grid-&gt;isType&lt;<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::FloatGrid</a>&gt;())  CALL_OP(<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::FloatGrid</a>);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (grid-&gt;isType&lt;<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::DoubleGrid</a>&gt;()) CALL_OP(<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::DoubleGrid</a>);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (grid-&gt;isType&lt;<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::Int32Grid</a>&gt;())  CALL_OP(<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::Int32Grid</a>);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (grid-&gt;isType&lt;<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::Int64Grid</a>&gt;())  CALL_OP(<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::Int64Grid</a>);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (grid-&gt;isType&lt;<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::Vec3IGrid</a>&gt;())  CALL_OP(<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::Vec3IGrid</a>);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (grid-&gt;isType&lt;<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::Vec3SGrid</a>&gt;())  CALL_OP(<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::Vec3SGrid</a>);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (grid-&gt;isType&lt;<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::Vec3DGrid</a>&gt;())  CALL_OP(<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::Vec3DGrid</a>);</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (grid-&gt;isType&lt;<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::StringGrid</a>&gt;()) CALL_OP(<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html">openvdb::StringGrid</a>);</div><div class="line"></div><div class="line"><span class="preprocessor">#undef CALL_OP</span></div><div class="line"><span class="preprocessor">}</span></div></div><!-- fragment --><p>The following example shows how to use <b>processTypedGrid</b> to implement a generic pruning operation for grids of all built-in types: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Define a functor that prunes the trees of grids of arbitrary type</span></div><div class="line"><span class="comment">// with a fixed pruning tolerance.</span></div><div class="line"><span class="keyword">struct </span>PruneOp {</div><div class="line">    <span class="keywordtype">double</span> tolerance;</div><div class="line">    PruneOp(<span class="keywordtype">double</span> t): tolerance(t) {}</div><div class="line"></div><div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Gr<span class="keywordtype">id</span>Type&gt;</div><div class="line">    <span class="keywordtype">void</span> operator()(<span class="keyword">typename</span> GridType::Ptr grid)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        grid-&gt;tree().prune(<span class="keyword">typename</span> GridType::ValueType(tolerance));</div><div class="line">    }</div><div class="line">    <span class="comment">// Overload to handle string-valued grids</span></div><div class="line">    <span class="keywordtype">void</span> operator()(<a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::StringGrid::Ptr</a> grid)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        grid-&gt;tree().prune();</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Read all grids from a file.</span></div><div class="line">openvdb::io::File file(<span class="stringliteral">&quot;mygrids.vdb&quot;</span>);</div><div class="line">file.open();</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#a8290647a1d16e177501c207ea20fee7a">openvdb::GridPtrVecPtr</a> myGrids = file.getGrids();</div><div class="line">file.close();</div><div class="line"></div><div class="line"><span class="comment">// Prune each grid with a tolerance of 1%.</span></div><div class="line"><span class="keyword">const</span> PruneOp pruner(<span class="comment">/*tolerance=*/</span>0.01);</div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="namespaceopenvdb_1_1v8__1.html#ad2bd1302ad511bce0d5e906caa687119">openvdb::GridPtrVecIter</a> iter = myGrids-&gt;begin();</div><div class="line">    iter != myGrids-&gt;end(); ++iter)</div><div class="line">{</div><div class="line">    <a class="code" href="classopenvdb_1_1v8__1_1_1GridBase.html#ad98d7556003ccc2ef810f87d97159de4">openvdb::GridBase::Ptr</a> grid = *iter;</div><div class="line">    processTypedGrid(grid, pruner);</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="openvdbPointsHelloWorld"></a> </p>
<h1><a class="anchor" id="sPointsHelloWorld"></a>
“Hello, World” for OpenVDB Points</h1>
<p>This is a simple example showing how to convert a few points, perform I/O and iterate over them to extract their world-space positions.</p>
<p>For more information about using OpenVDB to store point data, see the <a class="el" href="points.html#openvdbPointsOverview">OpenVDB Points Documentation</a>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="PointConversion_8h.html">openvdb/points/PointConversion.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="PointCount_8h.html">openvdb/points/PointCount.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// Initialize grid types and point attributes types.</span></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a446befa7deee56e243fee79c37263eaa">openvdb::initialize</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Create a vector with four point positions.</span></div><div class="line">    std::vector&lt;openvdb::Vec3R&gt; positions;</div><div class="line">    positions.push_back(<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a>(0, 1, 0));</div><div class="line">    positions.push_back(<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a>(1.5, 3.5, 1));</div><div class="line">    positions.push_back(<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a>(-1, 6, -2));</div><div class="line">    positions.push_back(<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a>(1.1, 1.25, 0.06));</div><div class="line"></div><div class="line">    <span class="comment">// The VDB Point-Partioner is used when bucketing points and requires a</span></div><div class="line">    <span class="comment">// specific interface. For convenience, we use the PointAttributeVector</span></div><div class="line">    <span class="comment">// wrapper around an stl vector wrapper here, however it is also possible to</span></div><div class="line">    <span class="comment">// write one for a custom data structure in order to match the interface</span></div><div class="line">    <span class="comment">// required.</span></div><div class="line">    openvdb::points::PointAttributeVector&lt;openvdb::Vec3R&gt; positionsWrapper(positions);</div><div class="line"></div><div class="line">    <span class="comment">// This method computes a voxel-size to match the number of</span></div><div class="line">    <span class="comment">// points / voxel requested. Although it won&#39;t be exact, it typically offers</span></div><div class="line">    <span class="comment">// a good balance of memory against performance.</span></div><div class="line">    <span class="keywordtype">int</span> pointsPerVoxel = 8;</div><div class="line">    <span class="keywordtype">float</span> voxelSize =</div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#ab9ec3ffe5c7a9e7745c3a55de49ea125">openvdb::points::computeVoxelSize</a>(positionsWrapper, pointsPerVoxel);</div><div class="line"></div><div class="line">    <span class="comment">// Print the voxel-size to cout</span></div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;VoxelSize=&quot;</span> &lt;&lt; voxelSize &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Create a transform using this voxel-size.</span></div><div class="line">    openvdb::math::Transform::Ptr transform =</div><div class="line">        openvdb::math::Transform::createLinearTransform(voxelSize);</div><div class="line"></div><div class="line">    <span class="comment">// Create a PointDataGrid containing these four points and using the</span></div><div class="line">    <span class="comment">// transform given. This function has two template parameters, (1) the codec</span></div><div class="line">    <span class="comment">// to use for storing the position, (2) the grid we want to create</span></div><div class="line">    <span class="comment">// (ie a PointDataGrid).</span></div><div class="line">    <span class="comment">// We use no compression here for the positions.</span></div><div class="line">    openvdb::points::PointDataGrid::Ptr grid =</div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#ab15a1ee82d506999536458071ba44299">openvdb::points::createPointDataGrid</a>&lt;openvdb::points::NullCodec,</div><div class="line">                        <a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#acf438a63a8a41ec38b6d7ceae6467678">openvdb::points::PointDataGrid</a>&gt;(positions, *transform);</div><div class="line"></div><div class="line">    <span class="comment">// Set the name of the grid</span></div><div class="line">    grid-&gt;setName(<span class="stringliteral">&quot;Points&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Create a VDB file object and write out the grid.</span></div><div class="line">    openvdb::io::File(<span class="stringliteral">&quot;mypoints.vdb&quot;</span>).write({grid});</div><div class="line"></div><div class="line">    <span class="comment">// Create a new VDB file object for reading.</span></div><div class="line">    openvdb::io::File newFile(<span class="stringliteral">&quot;mypoints.vdb&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Open the file. This reads the file header, but not any grids.</span></div><div class="line">    newFile.open();</div><div class="line"></div><div class="line">    <span class="comment">// Read the grid by name.</span></div><div class="line">    <a class="code" href="classopenvdb_1_1v8__1_1_1GridBase.html#ad98d7556003ccc2ef810f87d97159de4">openvdb::GridBase::Ptr</a> baseGrid = newFile.readGrid(<span class="stringliteral">&quot;Points&quot;</span>);</div><div class="line">    newFile.close();</div><div class="line"></div><div class="line">    <span class="comment">// From the example above, &quot;Points&quot; is known to be a PointDataGrid,</span></div><div class="line">    <span class="comment">// so cast the generic grid pointer to a PointDataGrid pointer.</span></div><div class="line">    grid = openvdb::gridPtrCast&lt;openvdb::points::PointDataGrid&gt;(baseGrid);</div><div class="line"></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">openvdb::Index64</a> count = <a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#a8dbfd50108bbe665a6e1a0607335a5df">openvdb::points::pointCount</a>(grid-&gt;tree());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;PointCount=&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</div><div class="line"></div><div class="line">    <span class="comment">// Iterate over all the leaf nodes in the grid.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> leafIter = grid-&gt;tree().cbeginLeaf(); leafIter; ++leafIter) {</div><div class="line"></div><div class="line">        <span class="comment">// Verify the leaf origin.</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Leaf&quot;</span> &lt;&lt; leafIter-&gt;origin() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="comment">// Extract the position attribute from the leaf by name (P is position).</span></div><div class="line">        <span class="keyword">const</span> openvdb::points::AttributeArray&amp; array =</div><div class="line">            leafIter-&gt;constAttributeArray(<span class="stringliteral">&quot;P&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Create a read-only AttributeHandle. Position always uses Vec3f.</span></div><div class="line">        openvdb::points::AttributeHandle&lt;openvdb::Vec3f&gt; positionHandle(array);</div><div class="line"></div><div class="line">        <span class="comment">// Iterate over the point indices in the leaf.</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> indexIter = leafIter-&gt;beginIndexOn(); indexIter; ++indexIter) {</div><div class="line"></div><div class="line">            <span class="comment">// Extract the voxel-space position of the point.</span></div><div class="line">            <a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3f</a> voxelPosition = positionHandle.get(*indexIter);</div><div class="line"></div><div class="line">            <span class="comment">// Extract the world-space position of the voxel.</span></div><div class="line">            <span class="keyword">const</span> <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a> xyz = indexIter.getCoord().asVec3d();</div><div class="line"></div><div class="line">            <span class="comment">// Compute the world-space position of the point.</span></div><div class="line">            <a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3f</a> worldPosition =</div><div class="line">                grid-&gt;transform().indexToWorld(voxelPosition + xyz);</div><div class="line"></div><div class="line">            <span class="comment">// Verify the index and world-space position of the point</span></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;* PointIndex=[&quot;</span> &lt;&lt; *indexIter &lt;&lt; <span class="stringliteral">&quot;] &quot;</span>;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;WorldPosition=&quot;</span> &lt;&lt; worldPosition &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><div class="fragment"><div class="line">VoxelSize=3.34716</div><div class="line">PointCount=4</div><div class="line">Leaf[0, 0, -8]</div><div class="line">  PointIndex=[0] WorldPosition=[-1, 6, -2]</div><div class="line">Leaf[0, 0, 0]</div><div class="line">  PointIndex=[0] WorldPosition=[0, 1, 0]</div><div class="line">  PointIndex=[1] WorldPosition=[1.1, 1.25, 0.06]</div><div class="line">  PointIndex=[2] WorldPosition=[1.5, 3.5, 1]</div></div><!-- fragment --><h1><a class="anchor" id="sPointsConversion"></a>
Converting Point Attributes</h1>
<p>This example is the same as the <a class="el" href="codeExamples.html#sPointsHelloWorld">&ldquo;Hello, World&rdquo; for OpenVDB Points</a> example, however it demonstrates converting radius in addition to position. It uses a tailored attribute compression for the radius to demonstrate how to reduce memory.</p>
<p>These methods heavily rely on the point conversion methods contained in <a class="el" href="PointConversion_8h.html" title="Convert points and attributes to and from VDB Point Data grids. ">points/PointConversion.h</a>. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="PointConversion_8h.html">openvdb/points/PointConversion.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="PointCount_8h.html">openvdb/points/PointCount.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// Initialize grid types and point attributes types.</span></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a446befa7deee56e243fee79c37263eaa">openvdb::initialize</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Create a vector with four point positions.</span></div><div class="line">    std::vector&lt;openvdb::Vec3R&gt; positions;</div><div class="line">    positions.push_back(<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a>(0, 1, 0));</div><div class="line">    positions.push_back(<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a>(1.5, 3.5, 1));</div><div class="line">    positions.push_back(<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a>(-1, 6, -2));</div><div class="line">    positions.push_back(<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3R</a>(1.1, 1.25, 0.06));</div><div class="line"></div><div class="line">    <span class="comment">// Create a vector with four radii.</span></div><div class="line">    std::vector&lt;float&gt; radius;</div><div class="line">    radius.push_back(0.1);</div><div class="line">    radius.push_back(0.15);</div><div class="line">    radius.push_back(0.2);</div><div class="line">    radius.push_back(0.5);</div><div class="line"></div><div class="line">    <span class="comment">// The VDB Point-Partioner is used when bucketing points and requires a</span></div><div class="line">    <span class="comment">// specific interface. For convenience, we use the PointAttributeVector</span></div><div class="line">    <span class="comment">// wrapper around an stl vector wrapper here, however it is also possible to</span></div><div class="line">    <span class="comment">// write one for a custom data structure in order to match the interface</span></div><div class="line">    <span class="comment">// required.</span></div><div class="line">    openvdb::points::PointAttributeVector&lt;openvdb::Vec3R&gt; positionsWrapper(positions);</div><div class="line"></div><div class="line">    <span class="comment">// This method computes a voxel-size to match the number of</span></div><div class="line">    <span class="comment">// points / voxel requested. Although it won&#39;t be exact, it typically offers</span></div><div class="line">    <span class="comment">// a good balance of memory against performance.</span></div><div class="line">    <span class="keywordtype">int</span> pointsPerVoxel = 8;</div><div class="line">    <span class="keywordtype">float</span> voxelSize =</div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#ab9ec3ffe5c7a9e7745c3a55de49ea125">openvdb::points::computeVoxelSize</a>(positionsWrapper, pointsPerVoxel);</div><div class="line"></div><div class="line">    <span class="comment">// Create a transform using this voxel-size.</span></div><div class="line">    openvdb::math::Transform::Ptr transform =</div><div class="line">        openvdb::math::Transform::createLinearTransform(voxelSize);</div><div class="line"></div><div class="line">    <span class="comment">// Create a PointIndexGrid. This can be done automatically on creation of</span></div><div class="line">    <span class="comment">// the grid, however as this index grid is required for the position and</span></div><div class="line">    <span class="comment">// radius attributes, we create one we can use for both attribute creation.</span></div><div class="line">    openvdb::tools::PointIndexGrid::Ptr pointIndexGrid =</div><div class="line">        openvdb::tools::createPointIndexGrid&lt;openvdb::tools::PointIndexGrid&gt;(</div><div class="line">            positionsWrapper, *transform);</div><div class="line"></div><div class="line">    <span class="comment">// Create a PointDataGrid containing these four points and using the point</span></div><div class="line">    <span class="comment">// index grid. This requires the positions wrapper.</span></div><div class="line">    openvdb::points::PointDataGrid::Ptr grid =</div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#ab15a1ee82d506999536458071ba44299">openvdb::points::createPointDataGrid</a>&lt;openvdb::points::NullCodec,</div><div class="line">            <a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#acf438a63a8a41ec38b6d7ceae6467678">openvdb::points::PointDataGrid</a>&gt;(*pointIndexGrid, positionsWrapper, *transform);</div><div class="line"></div><div class="line">    <span class="comment">// Append a &quot;pscale&quot; attribute to the grid to hold the radius.</span></div><div class="line">    <span class="comment">// This attribute storage uses a unit range codec to reduce the memory</span></div><div class="line">    <span class="comment">// storage requirements down from 4-bytes to just 1-byte per value. This is</span></div><div class="line">    <span class="comment">// only possible because accuracy of the radius is not that important to us</span></div><div class="line">    <span class="comment">// and the values are always within unit range (0.0 =&gt; 1.0).</span></div><div class="line">    <span class="comment">// Note that this attribute type is not registered by default so needs to be</span></div><div class="line">    <span class="comment">// explicitly registered.</span></div><div class="line">    <span class="keyword">using</span> Codec = openvdb::points::FixedPointCodec&lt;<span class="comment">/*1-byte=*/</span><span class="keyword">false</span>,</div><div class="line">            openvdb::points::UnitRange&gt;;</div><div class="line">    openvdb::points::TypedAttributeArray&lt;float, Codec&gt;::registerType();</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a3907786c2430dbab9f198bfd5b31ff7c">openvdb::NamePair</a> radiusAttribute =</div><div class="line">        openvdb::points::TypedAttributeArray&lt;float, Codec&gt;::attributeType();</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#a9f8216e14812f6a9c9aaf1af5b2ad36b">openvdb::points::appendAttribute</a>(grid-&gt;tree(), <span class="stringliteral">&quot;pscale&quot;</span>, radiusAttribute);</div><div class="line"></div><div class="line">    <span class="comment">// Create a wrapper around the radius vector.</span></div><div class="line">    openvdb::points::PointAttributeVector&lt;float&gt; radiusWrapper(radius);</div><div class="line"></div><div class="line">    <span class="comment">// Populate the &quot;pscale&quot; attribute on the points</span></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#ad7557b731e5392e4448f933a84139950">openvdb::points::populateAttribute</a>&lt;<a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#a7fec47b2a3d864d85c53f69c3655fdbf">openvdb::points::PointDataTree</a>,</div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v8__1_1_1tools.html#af59b06fbf7e8c0f817695e92b0a86db1">openvdb::tools::PointIndexTree</a>, openvdb::points::PointAttributeVector&lt;float&gt;&gt;(</div><div class="line">            grid-&gt;tree(), pointIndexGrid-&gt;tree(), <span class="stringliteral">&quot;pscale&quot;</span>, radiusWrapper);</div><div class="line"></div><div class="line">    <span class="comment">// Set the name of the grid</span></div><div class="line">    grid-&gt;setName(<span class="stringliteral">&quot;Points&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Iterate over all the leaf nodes in the grid.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> leafIter = grid-&gt;tree().cbeginLeaf(); leafIter; ++leafIter) {</div><div class="line"></div><div class="line">        <span class="comment">// Verify the leaf origin.</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Leaf&quot;</span> &lt;&lt; leafIter-&gt;origin() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="comment">// Extract the position attribute from the leaf by name (P is position).</span></div><div class="line">        <span class="keyword">const</span> openvdb::points::AttributeArray&amp; positionArray =</div><div class="line">            leafIter-&gt;constAttributeArray(<span class="stringliteral">&quot;P&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Extract the radius attribute from the leaf by name (pscale is radius).</span></div><div class="line">        <span class="keyword">const</span> openvdb::points::AttributeArray&amp; radiusArray =</div><div class="line">            leafIter-&gt;constAttributeArray(<span class="stringliteral">&quot;pscale&quot;</span>);</div><div class="line"></div><div class="line">        <span class="comment">// Create read-only handles for position and radius.</span></div><div class="line">        openvdb::points::AttributeHandle&lt;openvdb::Vec3f&gt; positionHandle(positionArray);</div><div class="line">        openvdb::points::AttributeHandle&lt;float&gt; radiusHandle(radiusArray);</div><div class="line"></div><div class="line">        <span class="comment">// Iterate over the point indices in the leaf.</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> indexIter = leafIter-&gt;beginIndexOn(); indexIter; ++indexIter) {</div><div class="line"></div><div class="line">            <span class="comment">// Extract the voxel-space position of the point.</span></div><div class="line">            <a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3f</a> voxelPosition = positionHandle.get(*indexIter);</div><div class="line"></div><div class="line">            <span class="comment">// Extract the world-space position of the voxel.</span></div><div class="line">            <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a> xyz = indexIter.getCoord().asVec3d();</div><div class="line"></div><div class="line">            <span class="comment">// Compute the world-space position of the point.</span></div><div class="line">            <a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html">openvdb::Vec3f</a> worldPosition =</div><div class="line">                grid-&gt;transform().indexToWorld(voxelPosition + xyz);</div><div class="line"></div><div class="line">            <span class="comment">// Extract the radius of the point.</span></div><div class="line">            <span class="keywordtype">float</span> radius = radiusHandle.get(*indexIter);</div><div class="line"></div><div class="line">            <span class="comment">// Verify the index, world-space position and radius of the point.</span></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;* PointIndex=[&quot;</span> &lt;&lt; *indexIter &lt;&lt; <span class="stringliteral">&quot;] &quot;</span>;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;WorldPosition=&quot;</span> &lt;&lt; worldPosition &lt;&lt; <span class="stringliteral">&quot; &quot;</span>;</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Radius=&quot;</span> &lt;&lt; radius &lt;&lt; std::endl;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><div class="fragment"><div class="line">Leaf[0, 0, -8]</div><div class="line">  PointIndex=[0] WorldPosition=[-1, 6, -2] Radius=0.2</div><div class="line">Leaf[0, 0, 0]</div><div class="line">  PointIndex=[0] WorldPosition=[0, 1, 0] Radius=0.0999924</div><div class="line">  PointIndex=[1] WorldPosition=[1.1, 1.25, 0.06] Radius=0.499992</div><div class="line">  PointIndex=[2] WorldPosition=[1.5, 3.5, 1] Radius=0.149996</div></div><!-- fragment --><h1><a class="anchor" id="sPointsGeneration"></a>
Random Point Generation</h1>
<p>This example demonstrates how to create a new point grid and to populate it with random point positions initialized inside a level set sphere.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="openvdb_8h.html">openvdb/openvdb.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="LevelSetSphere_8h.html">openvdb/tools/LevelSetSphere.h</a>&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="PointCount_8h.html">openvdb/points/PointCount.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <span class="comment">// Initialize grid types and point attributes types.</span></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a446befa7deee56e243fee79c37263eaa">openvdb::initialize</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Generate a level set grid.</span></div><div class="line">    <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afc0f397bf0d1638f08250c19bc02d39e">openvdb::FloatGrid::Ptr</a> sphereGrid =</div><div class="line">        openvdb::tools::createLevelSetSphere&lt;openvdb::FloatGrid&gt;(<span class="comment">/*radius=*/</span>20.0,</div><div class="line">            <span class="comment">/*center=*/</span><a class="code" href="namespaceopenvdb_1_1v8__1.html#a4873ae29d5d8d4f1cb7c7717af41a993">openvdb::Vec3f</a>(1.5, 2, 3), <span class="comment">/*voxel size=*/</span>0.5);</div><div class="line"></div><div class="line">    <span class="comment">// Retrieve the number of leaf nodes in the grid.</span></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">openvdb::Index</a> leafCount = sphereGrid-&gt;tree().leafCount();</div><div class="line"></div><div class="line">    <span class="comment">// Use the topology to create a PointDataTree</span></div><div class="line">    openvdb::points::PointDataTree::Ptr pointTree(</div><div class="line">        <span class="keyword">new</span> openvdb::points::PointDataTree(sphereGrid-&gt;tree(), 0, <a class="code" href="classopenvdb_1_1v8__1_1_1TopologyCopy.html">openvdb::TopologyCopy</a>()));</div><div class="line"></div><div class="line">    <span class="comment">// Ensure all tiles have been voxelized</span></div><div class="line">    pointTree-&gt;voxelizeActiveTiles();</div><div class="line"></div><div class="line">    <span class="comment">// Define the position type and codec using fixed-point 16-bit compression.</span></div><div class="line">    <span class="keyword">using</span> PositionAttribute = openvdb::points::TypedAttributeArray&lt;<a class="code" href="namespaceopenvdb_1_1v8__1.html#a4873ae29d5d8d4f1cb7c7717af41a993">openvdb::Vec3f</a>,</div><div class="line">        openvdb::points::FixedPointCodec&lt;false&gt;&gt;;</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a3907786c2430dbab9f198bfd5b31ff7c">openvdb::NamePair</a> positionType = PositionAttribute::attributeType();</div><div class="line"></div><div class="line">    <span class="comment">// Create a new Attribute Descriptor with position only</span></div><div class="line">    openvdb::points::AttributeSet::Descriptor::Ptr descriptor(</div><div class="line">        openvdb::points::AttributeSet::Descriptor::create(positionType));</div><div class="line"></div><div class="line">    <span class="comment">// Determine the number of points / voxel and points / leaf.</span></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">openvdb::Index</a> pointsPerVoxel = 8;</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">openvdb::Index</a> voxelsPerLeaf = openvdb::points::PointDataGrid::TreeType::LeafNodeType::SIZE;</div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">openvdb::Index</a> pointsPerLeaf = pointsPerVoxel * voxelsPerLeaf;</div><div class="line"></div><div class="line">    <span class="comment">// Iterate over the leaf nodes in the point tree.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> leafIter = pointTree-&gt;beginLeaf(); leafIter; ++leafIter) {</div><div class="line"></div><div class="line">        <span class="comment">// Initialize the attributes using the descriptor and point count.</span></div><div class="line">        leafIter-&gt;initializeAttributes(descriptor, pointsPerLeaf);</div><div class="line"></div><div class="line">        <span class="comment">// Initialize the voxel offsets</span></div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">openvdb::Index</a> offset(0);</div><div class="line">        <span class="keywordflow">for</span> (<a class="code" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">openvdb::Index</a> index = 0; index &lt; voxelsPerLeaf; ++index) {</div><div class="line">            offset += pointsPerVoxel;</div><div class="line">            leafIter-&gt;setOffsetOn(index, offset);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Create the points grid.</span></div><div class="line">    openvdb::points::PointDataGrid::Ptr points =</div><div class="line">        openvdb::points::PointDataGrid::create(pointTree);</div><div class="line"></div><div class="line">    <span class="comment">// Set the name of the grid.</span></div><div class="line">    points-&gt;setName(<span class="stringliteral">&quot;Points&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Copy the transform from the sphere grid.</span></div><div class="line">    points-&gt;setTransform(sphereGrid-&gt;transform().copy());</div><div class="line"></div><div class="line">    <span class="comment">// Randomize the point positions.</span></div><div class="line">    std::mt19937 generator(<span class="comment">/*seed=*/</span>0);</div><div class="line">    std::uniform_real_distribution&lt;&gt; distribution(-0.5, 0.5);</div><div class="line"></div><div class="line">    <span class="comment">// Iterate over the leaf nodes in the point tree.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> leafIter = points-&gt;tree().beginLeaf(); leafIter; ++leafIter) {</div><div class="line"></div><div class="line">        <span class="comment">// Create an AttributeWriteHandle for position.</span></div><div class="line">        <span class="comment">// Note that the handle only requires the value type, not the codec.</span></div><div class="line">        openvdb::points::AttributeArray&amp; array = leafIter-&gt;attributeArray(<span class="stringliteral">&quot;P&quot;</span>);</div><div class="line">        openvdb::points::AttributeWriteHandle&lt;openvdb::Vec3f&gt; handle(array);</div><div class="line"></div><div class="line">        <span class="comment">// Iterate over the point indices in the leaf.</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> indexIter = leafIter-&gt;beginIndexOn(); indexIter; ++indexIter) {</div><div class="line"></div><div class="line">            <span class="comment">// Compute a new random position (in the range -0.5 =&gt; 0.5).</span></div><div class="line">            openvdb::Vec3f positionVoxelSpace(distribution(generator));</div><div class="line"></div><div class="line">            <span class="comment">// Set the position of this point.</span></div><div class="line">            <span class="comment">// As point positions are stored relative to the voxel center, it is</span></div><div class="line">            <span class="comment">// not necessary to convert these voxel space values into</span></div><div class="line">            <span class="comment">// world-space during this process.</span></div><div class="line">            handle.set(*indexIter, positionVoxelSpace);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Verify the point count.</span></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">openvdb::Index</a> count = <a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#a8dbfd50108bbe665a6e1a0607335a5df">openvdb::points::pointCount</a>(points-&gt;tree());</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;LeafCount=&quot;</span> &lt;&lt; leafCount &lt;&lt; std::endl;</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;PointCount=&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</div><div class="line">}</div></div><!-- fragment --><p> Output: </p><div class="fragment"><div class="line">LeafCount=660</div><div class="line">PointCount=2703360</div></div><!-- fragment --><h1><a class="anchor" id="sPointIterationFiltering"></a>
Point Iteration, Groups and Filtering</h1>
<p>This section demonstrates how to iterate over points and to use point groups and custom filters during iteration.</p>
<p>See the documentation describing iteration and filtering under <a class="el" href="points.html#openvdbPointsIterators">OpenVDB Points Iteration</a> for more information.</p>
<h2><a class="anchor" id="sPointIteration"></a>
Point Iteration</h2>
<p>Iterating over point attribute data is most easily done by iterating over the leaf nodes of a PointDataGrid and then the index indices of the attribute within the leaf and extracting the values from a handle bound to the attribute stored within the leaf.</p>
<p>This example demonstrates single-threaded, read-only iteration over all float values of an attribute called "name".</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> leafIter = pointTree.beginLeaf(); leafIter; ++leafIter) {</div><div class="line">    openvdb::points::AttributeArray&amp; array =</div><div class="line">        leafIter-&gt;constAttributeArray(<span class="stringliteral">&quot;name&quot;</span>);</div><div class="line">    openvdb::points::AttributeHandle&lt;float&gt; handle(array);</div><div class="line"></div><div class="line">    <span class="comment">// Iterate over active indices in the leaf.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> indexIter = leafIter-&gt;beginIndexOn(); indexIter; ++indexIter) {</div><div class="line"></div><div class="line">        <span class="comment">// Retrieve value</span></div><div class="line">        <span class="keywordtype">float</span> value = handle.get(*indexIter);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>This example demonstrates single-threaded, read-write iteration for a similar float attribute by setting all values to be 5.0f.</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> leafIter = pointTree.beginLeaf(); leafIter; ++leafIter) {</div><div class="line">    openvdb::points::AttributeArray&amp; array =</div><div class="line">        leafIter-&gt;attributeArray(<span class="stringliteral">&quot;name&quot;</span>);</div><div class="line">    openvdb::points::AttributeWriteHandle&lt;float&gt; handle(array);</div><div class="line"></div><div class="line">    <span class="comment">// Iterate over active indices in the leaf.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> indexIter = leafIter-&gt;beginIndexOn(); indexIter; ++indexIter) {</div><div class="line"></div><div class="line">        <span class="comment">// Set value</span></div><div class="line">        handle.set(*indexIter, 5.0f);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Here is the same read-only example using TBB and a custom operator for reading values using multi-threaded access.</p>
<p>In this example, we also find the index of the attribute in the descriptor to avoid having to look this up each time (assuming that all leaf nodes share the same descriptor).</p>
<p>A similar approach can be used for multi-threaded writing.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ReadValueOp</div><div class="line">{</div><div class="line">    <span class="keyword">explicit</span> ReadValueOp(<a class="code" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">openvdb::Index64</a> index) : mIndex(index) { }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> operator()(<span class="keyword">const</span> openvdb::tree::LeafManager&lt;</div><div class="line">        openvdb::points::PointDataTree&gt;::LeafRange&amp; range)<span class="keyword"> const </span>{</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> leafIter = range.begin(); leafIter; ++leafIter) {</div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keyword">auto</span> indexIter = leafIter-&gt;beginIndexOn();</div><div class="line">                indexIter; ++indexIter) {</div><div class="line"></div><div class="line">                <span class="keyword">const</span> openvdb::points::AttributeArray&amp; array =</div><div class="line">                    leafIter-&gt;constAttributeArray(mIndex);</div><div class="line">                openvdb::points::AttributeHandle&lt;float&gt; handle(array);</div><div class="line"></div><div class="line">                <span class="keywordtype">float</span> value = handle.get(*indexIter);</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">openvdb::Index64</a> mIndex;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Create a leaf iterator for the PointDataTree.</span></div><div class="line"><span class="keyword">auto</span> leafIter = pointTree.cbeginLeaf();</div><div class="line"></div><div class="line"><span class="comment">// Check that the tree has leaf nodes.</span></div><div class="line"><span class="keywordflow">if</span> (!leafIter) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;No Leaf Nodes&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Retrieve the index from the descriptor.</span></div><div class="line"><span class="keyword">auto</span> descriptor = leafIter-&gt;attributeSet().descriptor();</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">openvdb::Index64</a> index = descriptor.find(<span class="stringliteral">&quot;name&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Check that the attribute has been found.</span></div><div class="line"><span class="keywordflow">if</span> (index == openvdb::points::AttributeSet::INVALID_POS) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;Invalid Attribute&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Create a leaf manager for the points tree.</span></div><div class="line">openvdb::tree::LeafManager&lt;openvdb::points::PointDataTree&gt; leafManager(</div><div class="line">    pointsTree);</div><div class="line"><span class="comment">// Create a new operator</span></div><div class="line">ReadValueOp op(index);</div><div class="line"><span class="comment">// Evaluate in parallel</span></div><div class="line">tbb::parallel_for(leafManager.leafRange(), op);</div></div><!-- fragment --><p>Tip: To run a multi-threaded operator as single-threaded for debugging, set the grainsize argument to a number larger than the number of leaf nodes (it defaults to 1).</p>
<div class="fragment"><div class="line"><span class="comment">// Evaluate parallel operator in serial</span></div><div class="line">tbb::parallel_for(leafManager.leafRange(<span class="comment">/*grainsize=*/</span>1000000), op);</div></div><!-- fragment --><h2><a class="anchor" id="sPointGroups"></a>
Creating and Assigning Point Groups</h2>
<p>Point groups in OpenVDB are analagous to Houdini point groups as an efficient way of tagging specific points to belong to a named group.</p>
<p>This example uses the data set generated in the <a class="el" href="codeExamples.html#sPointsGeneration">Random Point Generation</a> example.</p>
<div class="fragment"><div class="line"><span class="comment">// Append a new (empty) group to the point tree.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#a6df5f0462ae9d328e4987971cda4c7ee">openvdb::points::appendGroup</a>(points-&gt;tree(), <span class="stringliteral">&quot;positiveY&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Count all points that belong to this group.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">openvdb::Index</a> groupCount =</div><div class="line">    openvdb::points::groupPointCount(points-&gt;tree(), <span class="stringliteral">&quot;positiveY&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Verify group is empty.</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;PointCount=&quot;</span> &lt;&lt; count &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;EmptyGroupPointCount=&quot;</span> &lt;&lt; groupCount &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="comment">// Create leaf node iterator for points tree.</span></div><div class="line"><span class="keyword">auto</span> leafIter = points-&gt;tree().beginLeaf();</div><div class="line"><span class="keywordflow">if</span> (!leafIter) {</div><div class="line">    std::cerr &lt;&lt; <span class="stringliteral">&quot;No Leaf Nodes&quot;</span> &lt;&lt; std::endl;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Extract the group index.</span></div><div class="line">openvdb::points::AttributeSet::Descriptor::GroupIndex groupIndex =</div><div class="line">    leafIter-&gt;attributeSet().groupIndex(<span class="stringliteral">&quot;positiveY&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Iterate over leaf nodes.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> leafIter = points-&gt;tree().beginLeaf(); leafIter; ++leafIter) {</div><div class="line"></div><div class="line">    <span class="comment">// Create a read-only position handle.</span></div><div class="line">    <span class="keyword">const</span> openvdb::points::AttributeArray&amp; positionArray =</div><div class="line">        leafIter-&gt;constAttributeArray(<span class="stringliteral">&quot;P&quot;</span>);</div><div class="line">    openvdb::points::AttributeHandle&lt;openvdb::Vec3f&gt; positionHandle(</div><div class="line">        positionArray);</div><div class="line"></div><div class="line">    <span class="comment">// Create a read-write group handle.</span></div><div class="line">    openvdb::points::GroupWriteHandle groupHandle =</div><div class="line">        leafIter-&gt;groupWriteHandle(<span class="stringliteral">&quot;positiveY&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Iterate over the point indices in the leaf.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> indexIter = leafIter-&gt;beginIndexOn(); indexIter; ++indexIter) {</div><div class="line"></div><div class="line">        <span class="comment">// Extract the voxel-space position of the point.</span></div><div class="line">        openvdb::Vec3f voxelPosition = positionHandle.get(*indexIter);</div><div class="line"></div><div class="line">        <span class="comment">// Extract the world-space position of the voxel.</span></div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a> xyz = indexIter.getCoord().asVec3d();</div><div class="line"></div><div class="line">        <span class="comment">// Compute the world-space position of the point.</span></div><div class="line">        openvdb::Vec3f worldPosition =</div><div class="line">            points-&gt;transform().indexToWorld(voxelPosition + xyz);</div><div class="line"></div><div class="line">        <span class="comment">// If the world-space position is greater than zero in Y, add this</span></div><div class="line">        <span class="comment">// point to the group.</span></div><div class="line">        <span class="keywordflow">if</span> (worldPosition.<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html#a67e4fec98374cd34f20fd6896c8760d0">y</a>() &gt; 0.0f) {</div><div class="line">            groupHandle.set(*indexIter, <span class="comment">/*on=*/</span><span class="keyword">true</span>);</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// Attempt to compact the array for efficiency if all points in a leaf</span></div><div class="line">    <span class="comment">// have the same membership for example.</span></div><div class="line">    groupHandle.compact();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Count all points in this group once again.</span></div><div class="line">groupCount = openvdb::points::groupPointCount(points-&gt;tree(), <span class="stringliteral">&quot;positiveY&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Verify group membership.</span></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;GroupPointCount=&quot;</span> &lt;&lt; groupCount &lt;&lt; std::endl;</div></div><!-- fragment --><p> Output: </p><div class="fragment"><div class="line">PointCount=2703360</div><div class="line">EmptyGroupPointCount=0</div><div class="line">GroupPointCount=1463740</div></div><!-- fragment --><h2><a class="anchor" id="sPointFiltering"></a>
Point Filtering using Groups</h2>
<p>One highly useful feature of groups is to be able to use them for performing filtered iteration.</p>
<p>Here is an example iterating over all the points in the same data set to compute the average position in Y.</p>
<div class="fragment"><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#ac69cfd22ec6d99378ea1e829dc42781e">openvdb::Index64</a> iterationCount(0);</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> averageY(0.0);</div><div class="line"></div><div class="line"><span class="comment">// Iterate over leaf nodes.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> leafIter = points-&gt;tree().beginLeaf(); leafIter; ++leafIter) {</div><div class="line"></div><div class="line">    <span class="comment">// Create a read-only position handle.</span></div><div class="line">    <span class="keyword">const</span> openvdb::points::AttributeArray&amp; positionArray =</div><div class="line">        leafIter-&gt;constAttributeArray(<span class="stringliteral">&quot;P&quot;</span>);</div><div class="line">    openvdb::points::AttributeHandle&lt;openvdb::Vec3f&gt; positionHandle(</div><div class="line">        positionArray);</div><div class="line"></div><div class="line">    <span class="comment">// Iterate over the point indices in the leaf.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> indexIter = leafIter-&gt;beginIndexOn(); indexIter; ++indexIter) {</div><div class="line"></div><div class="line">        <span class="comment">// Extract the world-space position of the point.</span></div><div class="line">        openvdb::Vec3f voxelPosition = positionHandle.get(*indexIter);</div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a> xyz = indexIter.getCoord().asVec3d();</div><div class="line">        openvdb::Vec3f worldPosition =</div><div class="line">            points-&gt;transform().indexToWorld(voxelPosition + xyz);</div><div class="line"></div><div class="line">        <span class="comment">// Increment the sum.</span></div><div class="line">        averageY += worldPosition.<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html#a67e4fec98374cd34f20fd6896c8760d0">y</a>();</div><div class="line"></div><div class="line">        <span class="comment">// Track iteration</span></div><div class="line">        iterationCount++;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">averageY /= double(count);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;IterationCount=&quot;</span> &lt;&lt; iterationCount &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;AveragePositionInY=&quot;</span> &lt;&lt; averageY &lt;&lt; std::endl;</div></div><!-- fragment --><p> Output: </p><div class="fragment"><div class="line">IterationCount=2703360</div><div class="line">AveragePositionInY=1.89564</div></div><!-- fragment --><p>And the same example filtering using the "positiveY" group during iteration.</p>
<div class="fragment"><div class="line">iterationCount = 0;</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> averageYPositive(0.0);</div><div class="line"></div><div class="line"><span class="comment">// Create a &quot;positiveY&quot; group filter.</span></div><div class="line">openvdb::points::GroupFilter filter(<span class="stringliteral">&quot;positiveY&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Iterate over leaf nodes.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> leafIter = points-&gt;tree().beginLeaf(); leafIter; ++leafIter) {</div><div class="line"></div><div class="line">    <span class="comment">// Create a read-only position handle.</span></div><div class="line">    <span class="keyword">const</span> openvdb::points::AttributeArray&amp; positionArray =</div><div class="line">        leafIter-&gt;constAttributeArray(<span class="stringliteral">&quot;P&quot;</span>);</div><div class="line">    openvdb::points::AttributeHandle&lt;openvdb::Vec3f&gt; positionHandle(</div><div class="line">        positionArray);</div><div class="line"></div><div class="line">    <span class="comment">// Iterate over the point indices in the leaf that match the filter.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> indexIter = leafIter-&gt;beginIndexOn(filter); indexIter; ++indexIter) {</div><div class="line"></div><div class="line">        <span class="comment">// Extract the world-space position of the point.</span></div><div class="line">        openvdb::Vec3f voxelPosition = positionHandle.get(*indexIter);</div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a> xyz = indexIter.getCoord().asVec3d();</div><div class="line">        openvdb::Vec3f worldPosition =</div><div class="line">            points-&gt;transform().indexToWorld(voxelPosition + xyz);</div><div class="line"></div><div class="line">        <span class="comment">// Increment the sum.</span></div><div class="line">        averageYPositive += worldPosition.<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html#a67e4fec98374cd34f20fd6896c8760d0">y</a>();</div><div class="line"></div><div class="line">        <span class="comment">// Track iteration</span></div><div class="line">        iterationCount++;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">averageYPositive /= double(groupCount);</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;IterationCount=&quot;</span> &lt;&lt; iterationCount &lt;&lt; std::endl;</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;AveragePositivePositionInY=&quot;</span> &lt;&lt; averageYPositive &lt;&lt; std::endl;</div></div><!-- fragment --><p> Output: </p><div class="fragment"><div class="line">IterationCount=1463740</div><div class="line">AveragePositivePositionInY=11.373</div></div><!-- fragment --><p>This approach still performs this operation in two passes, (1) creating and assigning the groups and (2) iterating using the group.</p>
<h2><a class="anchor" id="sPointCustomFiltering"></a>
Point Filtering using Custom Filters</h2>
<p>For common operations, it is typically faster to sacrifice the flexibility of point groups for a custom filter. This is using the same data set from the previous example.</p>
<div class="fragment"><div class="line"><span class="comment">// Evalutate true for points that are positive in Y only</span></div><div class="line"><span class="keyword">struct </span>PositiveYFilter</div><div class="line">{</div><div class="line">    <span class="keyword">using</span> Handle = openvdb::points::AttributeHandle&lt;openvdb::Vec3f&gt;;</div><div class="line"></div><div class="line">    <span class="keyword">explicit</span> PositiveYFilter(<span class="keyword">const</span> openvdb::math::Transform&amp; transform)</div><div class="line">            : mTransform(transform) { }</div><div class="line"></div><div class="line">    PositiveYFilter(<span class="keyword">const</span> PositiveYFilter&amp; filter)</div><div class="line">        : mTransform(filter.mTransform)</div><div class="line">    {</div><div class="line">        <span class="keywordflow">if</span> (filter.mPositionHandle) {</div><div class="line">            mPositionHandle.reset(<span class="keyword">new</span> Handle(*filter.mPositionHandle));</div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">inline</span> <span class="keywordtype">bool</span> initialized()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> bool(mPositionHandle); }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LeafT&gt;</div><div class="line">    <span class="keywordtype">void</span> reset(<span class="keyword">const</span> LeafT&amp; leaf) {</div><div class="line">        mPositionHandle.reset(<span class="keyword">new</span> Handle(leaf.constAttributeArray(<span class="stringliteral">&quot;P&quot;</span>)));</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> IterT&gt;</div><div class="line">    <span class="keywordtype">bool</span> valid(<span class="keyword">const</span> IterT&amp; indexIter)<span class="keyword"> const </span>{</div><div class="line">        openvdb::Vec3f voxelPosition = mPositionHandle-&gt;get(*indexIter);</div><div class="line">        <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a> xyz = indexIter.getCoord().asVec3d();</div><div class="line">        openvdb::Vec3f worldPosition =</div><div class="line">            mTransform.indexToWorld(voxelPosition + xyz);</div><div class="line">        <span class="keywordflow">return</span> worldPosition.<a class="code" href="classopenvdb_1_1v8__1_1_1math_1_1Vec3.html#a67e4fec98374cd34f20fd6896c8760d0">y</a>() &gt; 0.0f;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keyword">const</span> openvdb::math::Transform&amp; mTransform;</div><div class="line">    Handle::UniquePtr mPositionHandle;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Drop the &quot;positiveY&quot; group.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#ac1f0afec32f566e10a0a25fde4466dba">openvdb::points::dropGroup</a>(points-&gt;tree(), <span class="stringliteral">&quot;positiveY&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Create a new positive-Y filter.</span></div><div class="line">PositiveYFilter positiveYFilter(points-&gt;transform());</div><div class="line"></div><div class="line">iterationCount = 0.0;</div><div class="line"></div><div class="line"><span class="comment">// Iterate over the points using the custom filter</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> leafIter = points-&gt;tree().beginLeaf(); leafIter; ++leafIter) {</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> indexIter = leafIter-&gt;beginIndexOn(positiveYFilter);</div><div class="line">        indexIter; ++indexIter) {</div><div class="line"></div><div class="line">        <span class="comment">// Track iteration</span></div><div class="line">        iterationCount++;</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;IterationCount=&quot;</span> &lt;&lt; iterationCount &lt;&lt; std::endl;</div></div><!-- fragment --><p> Output: </p><div class="fragment"><div class="line">IterationCount=1463740</div></div><!-- fragment --><h1><a class="anchor" id="sPointStride"></a>
Strided Point Attributes</h1>
<p>Point attributes can have a stride greater than one in order to store multiple values with each attribute with each point.</p>
<h2><a class="anchor" id="sConstantStride"></a>
Constant Stride Attributes</h2>
<p>A stride can be constant so that each attribute has the same number of values. This example demonstrates using a hard-coded 10 samples per point in an attribute called "samples".</p>
<div class="fragment"><div class="line"><span class="comment">// Store 10 values per point in an attribute called samples.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1.html#a1a68fb76e3d6897fa878760b6bcbda7a">openvdb::Index</a> stride(10);</div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#a9f8216e14812f6a9c9aaf1af5b2ad36b">openvdb::points::appendAttribute</a>(points-&gt;tree(), <span class="stringliteral">&quot;samples&quot;</span>,</div><div class="line">    openvdb::points::TypedAttributeArray&lt;float&gt;::attributeType(), stride);</div><div class="line"></div><div class="line"><span class="comment">// Iterate over leaf nodes.</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> leafIter = points-&gt;tree().beginLeaf(); leafIter; ++leafIter) {</div><div class="line"></div><div class="line">    <span class="comment">// Create a read-write samples handle.</span></div><div class="line">    openvdb::points::AttributeArray&amp; array(</div><div class="line">        leafIter-&gt;attributeArray(<span class="stringliteral">&quot;samples&quot;</span>));</div><div class="line">    openvdb::points::AttributeWriteHandle&lt;float&gt; handle(array);</div><div class="line"></div><div class="line">    <span class="comment">// Iterate over the point indices in the leaf.</span></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> indexIter = leafIter-&gt;beginIndexOn(); indexIter; ++indexIter) {</div><div class="line"></div><div class="line">        <span class="comment">// Use ascending sample values for each element in the strided array</span></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) {</div><div class="line">            handle.set(*indexIter, <span class="comment">/*strideIndex=*/</span>i, <span class="keywordtype">float</span>(i));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="sPointMove"></a>
Moving Points in Space</h1>
<p>As points are stored within voxels in an implicit spatially organised data structure, moving points in space requires re-bucketing the data.</p>
<h2><a class="anchor" id="sPointAdvect"></a>
Advecting Points</h2>
<p>Advection uses a specified integration order (4 = runge-kutta 4th) as well as delta time and time-step parameters to advect the points in-place using the supplied velocity grid.</p>
<div class="fragment"><div class="line"><span class="comment">// Create an empty velocity grid with gravity as background value</span></div><div class="line"><span class="keyword">auto</span> gravity = <a class="code" href="classopenvdb_1_1v8__1_1_1Grid.html#afed9748b2280ee9155aa1033cc583bc7">openvdb::Vec3SGrid::create</a>(<a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#ae60b991a87c83e25ec51e0576209be11">openvdb::Vec3s</a>(0, -9.81, 0));</div><div class="line"></div><div class="line"><span class="comment">// Advect points in-place using gravity velocity grid</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#ab79ffb24dc5aee12a75d1507966164bc">openvdb::points::advectPoints</a>(*points, *gravity,</div><div class="line">    <span class="comment">/*integrationOrder=*/</span>4, <span class="comment">/*dt=*/</span>1.0/24.0, <span class="comment">/*timeSteps=*/</span>1);</div></div><!-- fragment --><h2><a class="anchor" id="sPointCustomDeformer"></a>
Moving Points with a Custom Deformer</h2>
<p>A custom deformer generates the new position of each existing point in a point set. This can use any number of mechanisms to achieve this such as a static value, a hard-coded list of positions, a function that uses the existing position to compute the new one or a function that uses the index of the point within the leaf array in some other way. This example simply takes the input position and adds a Y offset. Note that it is also possible to configure a custom deformer to operate in index-space.</p>
<div class="fragment"><div class="line"><span class="comment">// This custom deformer is also used in the TestPointMove unit tests.</span></div><div class="line"><span class="keyword">struct </span>OffsetDeformer</div><div class="line">{</div><div class="line">    OffsetDeformer(<span class="keyword">const</span> <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a>&amp; _offset)</div><div class="line">        : offset(_offset){ }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> LeafIterT&gt;</div><div class="line">    <span class="keywordtype">void</span> reset(<span class="keyword">const</span> LeafIterT&amp;) { }</div><div class="line"></div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> IndexIterT&gt;</div><div class="line">    <span class="keywordtype">void</span> apply(<a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a>&amp; position, <span class="keyword">const</span> IndexIterT&amp;)<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">        position += offset;</div><div class="line">    }</div><div class="line"></div><div class="line">    <a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a> offset;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Create an OffsetDeformer that moves the points downwards in Y by 10 world-space units.</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1math.html#a98d94999010cb92dfb5f652c353d1d82">openvdb::Vec3d</a> offset(0, -10, 0);</div><div class="line">OffsetDeformer deformer(offset);</div><div class="line"></div><div class="line"><span class="comment">// Move the points using this deformer</span></div><div class="line"><a class="code" href="namespaceopenvdb_1_1v8__1_1_1points.html#a2d0082c20c402a864700014eae174838">openvdb::points::movePoints</a>(*points, deformer);</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
